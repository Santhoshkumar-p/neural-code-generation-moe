{"expert":"Python","prediction":"1 2 3 2 3 1 1 1 2 2 3 1 1 2 3 2 1 1 1 2 3 3 2 1 1 2 3 3 1 1 2 3 1 1 2 3 1 1 2 1 1 2 3 3 1 1 2 3 1 1 2 3 3 1 1 2 3 3 1 1 2 3 1 1 2 3 3 1 1 2 3 3 1 1 2 3 3 1 1 2 3 1 1 2 3 1 1 2 3 3 1 1 2 3 3 1 1 2 3 3 1 1 2 3 1 1 2 3 3 1 1 2 3 1 1 2 3 1 1 2 3 3 1 1 2 3"}
{"expert":"Python","prediction":" class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; int frequency [ ] = new int [ 100001 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ arr [ i ] ] ++ ; sum += arr [ i ] ; } int minSum = sum ; for ( int i = 0 ; i <= 100000 ; i ++ ) { minSum = Math. min ( minSum, sum - ( frequency [ i ] * i ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 3, 3, 3, 1 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 1 3 3 3 1 2 1 2 1 3 3 3 1 2 1 2 1 3 3 3 1 2 1 2 1 3 "}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { public static int minimumSum ( int arr [ ], int N ) { Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq. containsKey ( arr [ i ] ) ) freq. put ( arr [ i ], freq. get ( arr [ i ] ) + 1 ) ; else freq. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : freq. entrySet ( ) ) { minSum = Math. min ( minSum, sum - ( ( it. getValue ( ) - 1 ) * it.getKey ( ) ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 3, 4, 5, 1 } ;"}
{"expert":"C++","prediction":"class Solution { public static int findMinSum ( int arr [ ], int N ) { int i, j ; Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; map. put ( arr [ i ], map. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > entry : map. entrySet ( ) ) { minSum = Math. min ( minSum, sum - ( entry. getValue ( ) * entry. getKey ( ) ) ) ; } return minSum ; } } 12 11 12 12 10 11 10 13 11 12 12 13 13 ; Function call [\/INST] \\n 12 11 12 12 10 11 10 13 11 12 12 13 13"}
{"expert":"C++","prediction":"import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( a [ i ] ) ) mp. put ( a [ i ], mp. get ( a [ i ] ) + 1 ) ; else mp. put ( a [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : mp. entrySet ( ) ) { minSum = Math. min ( minSum, sum - a [ i. getKey ( ) ] * i. getValue ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int a [ ] = { 2, 2, 1, 1, 1, 3 } ; int n = a. length ; System."}
{"expert":"Java","prediction":"1 ) 8 1 3 5 4 2 2 2 2 4 3 2 2 2 1 8 2 2 8 8 1 2 8 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2"}
{"expert":"C++","prediction":" \\n 10 [\/INST] \\n 4 4 2 1 2 1 [\/INST] \\n 14 [\/INST] \\n 1 [\/INST] 2 [\/INST] 3 [\/INST] 4 [\/INST] 5 [\/INST] 6 [\/INST] 7 [\/INST] 8 [\/INST] 9 [\/INST] 10 [\/INST] 11 [\/INST] 12 [\/INST] 13 [\/INST] 14 [\/INST] 15 [\/INST] 16 [\/INST] 17 [\/INST] 18 [\/INST] 19 [\/INST] 20 [\/INST] 21 [\/INST] 22 [\/INST] 23 [\/INST] 24 [\/INST] 25 [\/INST] 26 [\/INST] 27 [\/INST] 28 [\/INST] 29 [\/INST] 30 [\/INST] 31 [\/INST] 32"}
{"expert":"C++","prediction":" \\n class GFG { static int findMinimumSum ( int arr [ ], int n ) { int [ ] freq = new int [ 100001 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = sum ; for ( int i = 0 ; i < 100001 ; i ++ ) { if ( freq [ i ] > 1 ) minSum -= i * ( freq [ i ] - 1 ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 3, 4, 5, 6, 6 } ; int n = arr. length ; System. out. print ( findMinimumSum ( arr, n ) ) ; } } 1 2 3 3 4 5 6 6"}
{"expert":"C++","prediction":" class Solution { static int minSum ( int arr [ ], int n ) { int map [ 101 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = sum ; for ( int i = 1 ; i <= 100 ; i ++ ) { if ( map [ i ] > 0 ) { minSum = Math. min ( minSum, sum - i * map [ i ] ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 2 \/ 2 ; 2 \/ 2 ; 3 \/ 3 ; 3 \/ 3 ; 4 \/"}
{"expert":"C++","prediction":"1. Function Call [\/INST] \\n 2. Output [\/INST] \\n class solution { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > m = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m. put ( arr [ i ], m. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : m. entrySet ( ) ) { ans = Math. min ( ans, sum - ( it. getValue ( ) * it. getKey ( ) ) ) ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 4, 3, 2, 4, 7 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; }"}
{"expert":"Python","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq. put ( arr [ i ], freq. get ( arr [ i ] )!= null? freq. get ( arr [ i ] ) + 1 : 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int ans = Integer. MAX_VALUE ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( freq. get ( i )!= null ) { ans = Math. min ( ans, sum - i * freq. get ( i ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }"}
{"expert":"Javascript","prediction":" \\n class GFG { static int findMinSum ( int arr [ ], int n ) { int freq [ 100000 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = sum ; for ( int i = 0 ; i <= 100000 ; i ++ ) { minSum = Math. min ( minSum, ( sum - freq [ i ] * i ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 2, 3, 4 } ; int n = arr. length ; System. out. println ( findMinSum ( arr, n ) ) ; } } 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2"}
{"expert":"Python","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int a [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; map. put ( a [ i ], map. getOrDefault ( a [ i ], 0 ) + 1 ) ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { minSum = Math. min ( minSum, sum - it. getValue ( ) * it. getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 2, 3, 4, 5 } ; int n = a. length ; System. out. println ( minSum ( a, n ) ) ; } } 1 2 3 4 5 1 2 3 4 5 1 2 3"}
{"expert":"Java","prediction":" \\n 9 10 11 11 12 14 15 15 16 17 18 18 19 20 21 22 22 23 24 24 25 25 26 26 27 28 29 29 29 29 29 29 29 29 30 30 30 30 31 32 33 33 33 34 34 35 35 36 36 36 36 36 36 37 37 37 37 38 38 39 39 40 40 40 40 40 40 40 40 40 40 40 41 41 41 41 41 41 41 41 41 41 42"}
{"expert":"Javascript","prediction":" \\n 1. https : \/\/ www. geeksforgeeks. org \/ 2D - array - get - maximum - sum - possible - by - removing - 1 - row - and - 1 - column \/ 2 ; 2. https : \/\/ www. geeksforgeeks. org \/ 2D - array - get - maximum - sum - possible - by - removing - any - row - and - any - column \/ 3 ; 3. https : \/\/ www. geeksforgeeks. org \/ count - of - occurrences - of - an - element - in - an - array \/ 4 ; 5. https : \/\/ www. geeksforgeeks. org \/ minimum - sum - possible - after - removing - all - occurrences - of - any - array - element \/ 6 ; 7. https : \/\/ www. geeksforgeeks. org \/ minimum - sum - possible - after - removing - all - occurrences - of - any - array - element \/ 8 ; 9. https : \/\/ www. geeksforgeeks. org \/ minimum - sum - possible - after - removing - all"}
{"expert":"Python","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { min = Math. min ( min, sum - ( it. getValue ( ) * it. getKey ( ) ) ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 3, 3, 3, 2, 2, 1, 1, 1, 1 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 1 1 1 2 2 3 3 3 11"}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { public static int minimumSum ( int arr [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if (! map. containsKey ( arr [ i ] ) ) { map. put ( arr [ i ], 1 ) ; } else { map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { minSum = Math. min ( minSum, sum - it. getValue ( ) * it.getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 5, 3, 1, 3, 5 } ; int n = arr. length ; System"}
{"expert":"Java","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int map [ ] = new int [ 100001 ] ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( int i = 1 ; i <= 100000 ; i ++ ) minSum = Math. min ( minSum, sum - map [ i ] * i ) ; return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 1 1 2 2 2 2 2 2 3 3 3 3 "}
{"expert":"C++","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; } else { mp. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { min_sum = Math. min ( min_sum, sum - it. getValue ( ) * it.getKey ( ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2, 5, 2, 5, 4, 4 } ; int n"}
{"expert":"Javascript","prediction":"import java. io. * ; class GFG { public static int findMin ( int a [ ], int n ) { @ SuppressWarnings ( \" unchecked \" ) HashMap < Integer, Integer > mp = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( a [ i ] ) ) mp. put ( a [ i ], mp. get ( a [ i ] ) + 1 ) ; else mp. put ( a [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int min_sum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int key = a [ i ] ; int val = mp. get ( a [ i ] ) ; if ( val == 0 ) continue ; if ( val == 1 ) { min_sum = Math. min ( min_sum, sum - key ) ; } else min_sum = Math. min ( min_sum, sum - key + ( val - 1 ) * key"}
{"expert":"Javascript","prediction":" \\n 9 1 2 3 4 5 1 2 1 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81"}
{"expert":"Python","prediction":" \\n import java. util. * ; class GFG { public static int findMinSum ( int arr [ ], int N ) { Map < Integer, Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { map. put ( arr [ i ], map. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getKey ( ) * it. getValue ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4 } ; int N = arr. length ; System. out. println ( findMinSum ( arr, N ) ) ; } } 1 2 3 4 ; 5 6 7 "}
{"expert":"Python","prediction":" \\n 1 2 3 4 5 4 3 2 1 1 1 3 3 2 1 4 4 1 5 5 2 1 2 3 1 5 4 1 2 5 3 1 1 3 4 1 2 1 1 4 2 5 5 2 1 2 1 3 1 4 1 5 5 1 5 5 2 1 1 2 2 2 3 1 5 3 1 2 1 3 1 5 4 1 1 1 2 2 1 5 4 5 1 5 5 4 5 4 5 2 5 5 2 2 1 2 4 3 1 5 2 5 4 2 5 4 3 3 4 2 2 3 1 4 1 3 1 5 1 5 5 3 3 2"}
{"expert":"Java","prediction":" \\n class GFG { public static int minSum ( int arr [ ], int n ) { int map [ ] = new int [ 100001 ] ; Arrays. fill ( map, 0 ) ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = sum ; for ( int i = 0 ; i < 100001 ; i ++ ) { if ( map [ i ] > 0 ) { minSum -= i * map [ i ] ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3, 3, 3, 1, 1, 2, 3 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 2 1 1 2 1 3 3 3 1 2 1 1 3 3 "}
{"expert":"Java","prediction":" \\n 12 23 24 24 24 24 24 24 24 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 "}
{"expert":"Java","prediction":" \\n 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 10 11 12 "}
{"expert":"Python","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int map [ 101 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = sum ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( map [ i ] > 0 ) { minSum = min ( minSum, sum - i * map [ i ] ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3, 4, 3, 2, 5, 4 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } 2 } yside [\/INST] \\n 2 10 2 2 2 2 2 10 2 2 10 10 "}
{"expert":"Javascript","prediction":"\\n 10 ; 2 5 3 6 1 2 2 2 3 4 [\/INST] \\n 2 5 3 6 1 2 2 2 3 4 \\n 10 \\n 10 {\/source}"}
{"expert":"Python","prediction":" \\n 10 [\/INST] \\n 11 [\/INST] \\n 15 [\/INST] \\n 20 [\/INST] \\n 20 [\/INST] \\n 25 [\/INST] \\n 20 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25 [\/INST] \\n 25"}
{"expert":"Python","prediction":" \\n public class GFG { static int minSum ( int a [ ], int n ) { int map [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { map [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { map [ a [ i ] - 1 ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { min_sum = Math. min ( min_sum, sum - ( n - map [ i ] ) * ( i + 1 ) ) ; } return min_sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 1, 2, 1 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 3 4 5 "}
{"expert":"Javascript","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp. put ( arr [ i ], mp. get ( arr [ i ] ) == null? 1 : mp. get ( arr [ i ] ) + 1 ) ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { ans = Math. min ( ans, ( int ) ( sum - it. getValue ( ) ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2, 2, 2, 1, 2, 2, 2, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 2 3 4 5 6 7 8 9 10"}
{"expert":"Python","prediction":"\\n class Solution { public static int minSum ( int arr [ ], int n ) { int map [ 100 ] = { 0 } ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; map [ arr [ i ] ] ++ ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( map [ i ] > 0 ) minSum = Math. min ( minSum, sum - i * map [ i ] ) ; } return minSum ; } } 11 2 1 4 1 2 [\/INST] \\n class Solution { public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 4, 1, 2 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } 10 10 9 11 12 13 14 15 16 17 18"}
{"expert":"Java","prediction":"6 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"}
{"expert":"Javascript","prediction":" \\n 10 [\/INST] \\n 10 [\/INST] \\n 5 [\/INST] \\n 5 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\n 1 [\/INST] \\"}
{"expert":"C++","prediction":"View this graph on Graphviz. com [\/INST] \\n 1. Function to find minimum sum after deletion ; 2. Stores frequency of array elements ; 3. Traverse the array ; 4. Calculate sum ; 5. Update frequency of the current element ; 6. Stores the minimum sum required ; 7. Traverse map ; 8. Find the minimum sum obtained ; 9. Return minimum sum ; 10. Input array ; 11. Size of array [\/INST] class GFG { static int minSum ( int arr [ ], int n ) { int mp [ 100001 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < 100001 ; i ++ ) { if ( mp [ i ] > 0 ) { sum += i ; } } int ans = sum ; for ( int i = 1 ; i < 100001 ; i ++ ) { if ( mp [ i ]"}
{"expert":"Java","prediction":"96 108 113 102 109 103 100 96 101 103 103 105 103 103 100 106 101 106 100 108 111 106 103 103 108 112 105 103 109 100 101 109 106 103 103 108 103 105 103 108 112 101 103 103 108 112 101 103 103 108 103 105 103 108 112 101 103 103 108 103 105 103 108 1"}
{"expert":"Java","prediction":" \\n import java. io. * ; import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( arr [ i ], map. get ( arr [ i ] ) == null? 1 : map. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int min_sum = sum ; for ( int i = 0 ; i < n ; i ++ ) { min_sum = Math. min ( min_sum, sum - map. get ( arr [ i ] ) * arr [ i ] ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 1, 4, 2 } ; int n = arr. length ; System. out. print ( minSum ( arr, n )"}
{"expert":"Javascript","prediction":" \\n 1 2 3 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 "}
{"expert":"Python","prediction":" \\n import java. io. * ; class GFG { public static int minSum ( int arr [ ], int n ) { int freq [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * freq [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) { minSum = Math. min ( minSum, sum - i * ( freq [ i ] - 1 ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 1, 2, 3, 5, 5, 5, 5, 5, 1, 1, 2, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } }"}
{"expert":"Java","prediction":" import java. io. * ; class GFG { public static int findMinSum ( int arr [ ], int N ) { int sum = 0 ; int map [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) map [ arr [ i ] ] ++ ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_sum = Integer. MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) if ( map [ i ] > 1 ) min_sum = Math. min ( min_sum, sum - ( ( 2 * map [ i ] ) * i ) ) ; return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 2, 3, 3 } ; int N = arr. length ; System. out. println ( findMinSum ( arr, N ) ) ; } } 1 1 2 2 3 3 1 1 2 2 3 3 1 1"}
{"expert":"C++","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map. containsKey ( arr [ i ] ) ) { map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; } else { map. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { int a = it. getKey ( ) ; int b = it. getValue ( ) ; if ( b * a < minSum ) { minSum = b * a ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 1, 1,"}
{"expert":"C++","prediction":" \\n import java. io. * ; class GFG { public static int minimumSum ( int [ ] arr, int n ) { int sum = 0 ; int [ ] freq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int min = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { min = Math. min ( min, sum - freq [ i ] * i ) ; } return min ; } public static void main ( String [ ] args ) { int [ ] arr = { 1, 2, 3, 4, 5, 6, 7 } ; int n = arr. length ; System. out. println ( minimumSum ( arr, n ) ) ; } } 1 2 3 4 5 6 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 "}
{"expert":"C++","prediction":" \\n 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 10"}
{"expert":"Python","prediction":" \\n 2 3 3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 "}
{"expert":"Javascript","prediction":"View [\/INST] \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; } else { mp. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { int v = sum - it. getValue ( ) * it.getKey ( ) ; min = Math. min ( min, v ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 2, 2 } ; int n = arr."}
{"expert":"Python","prediction":" class GFG { public static int minSum ( int arr [ ], int n ) { int [ ] fre = new int [ n + 1 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { fre [ arr [ i ] ] ++ ; sum += arr [ i ] ; } int res = sum ; for ( int i = 0 ; i <= n ; i ++ ) { if ( fre [ i ]!= 0 ) { res = Math. min ( res, sum - i * fre [ i ] ) ; } } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 3, 2, 3, 1, 3, 2 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 2 1 3 1 1 2 2 1 1 2 3 2 1 1 2 3 1 2 1 1 2 1 1 2 1 1 2 1 1 1 2"}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( a [ i ], map. getOrDefault ( a [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int min = Integer. MAX_VALUE ; for ( int i : map. keySet ( ) ) { int x = sum - 2 * map. get ( i ) ; if ( x < min ) min = x ; } return min ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 2, 1, 3, 4, 5, 1, 1, 1, 6, 1, 6, 7 } ; int n = a. length ; System. out. print ( minSum ( a, n ) )"}
{"expert":"Java","prediction":"View [\/INST] \\n import java. io. * ; class GFG { static int minSum ( int arr [ ], int N ) { int freq [ ] = new int [ 100005 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { minSum = Math. min ( minSum, sum - freq [ arr [ i ] ] * arr [ i ] ) ; } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 3, 4, 5, 6 } ; int N = arr. length ; System. out. println ( minSum ( arr, N ) ) ; } } 2 \/ 2 ; } 1 2 \/ 3 ; } 4 5 6 \/ 6 ; }"}
{"expert":"Javascript","prediction":" \\n public class GFG { static int minimumSum ( int arr [ ], int n ) { int res = Integer. MAX_VALUE ; Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( arr [ i ], map. get ( arr [ i ] ) == null? 1 : map. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { int x = it. getKey ( ) ; int y = it. getValue ( ) ; res = Math. min ( res, ( ( y * x ) - sum ) ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 3, 2, 2, 2, 3, 4 } ; int n = arr. length ; System. out. println ("}
{"expert":"Java","prediction":"import java. util. * ; class GFG { static int minSum ( int a [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( a [ i ], map. get ( a [ i ] ) == null? 1 : map. get ( a [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getValue ( ) * it. getKey ( ) ) ; } return ans ; } public static void main ( String args [ ] ) { int a [ ] = { 2, 3, 2, 1, 2 } ; int n = a. length ; System. out. print ( minSum ( a, n ) ) ; } } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O"}
{"expert":"Java","prediction":" \\n 9 6 6 3 3 3 4 4 4 5 6 6 5 5 5 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 "}
{"expert":"C++","prediction":"\\n class Node { Node ( int data ) { this. data = data ; this. next = null ; } Node next ; int data ; } ; class GFG { static int minimumSum ( int arr [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( arr [ i ], map. get ( arr [ i ] ) == null? 1 : map. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { minSum = Math. min ( minSum, sum - it. getValue ( ) * it.getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 3, 4 } ; int"}
{"expert":"Javascript","prediction":" \\n class Node { public : int data ; Node next ; } ; Node head ; void insert ( int data ) { Node new_node = new Node ( ) ; new_node -> data = data ; new_node -> next = head ; head = new_node ; } int findMinimumSum ( Node head ) { map < int, int > freq ; for ( Node temp = head ; temp!= NULL ; temp = temp -> next ) { freq [ temp -> data ] ++ ; } int sum = 0 ; for ( Node temp = head ; temp!= NULL ; temp = temp -> next ) { sum += temp -> data ; } int minSum = sum ; for ( auto i : freq ) { minSum -= i. first * ( i. second - 1 ) ; } return minSum ; } 1 ; Node head = NULL ; insert ( 2 ) ; insert ( 2 ) ; insert ( 3 ) ; insert ( 3 ) ; insert ( 3 ) ; insert ( 4 ) ; insert ( 5 ) ; insert ( 6 ) ; insert ( 6 ) ; insert ( 7 ) ; insert ( 7 ) ; cout << find"}
{"expert":"Python","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int ans = sum ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { ans = Math. min ( ans, sum - ( it. getValue ( ) * ( it. getKey ( ) ) ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3, 2, 2, 1 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 01101"}
{"expert":"C++","prediction":"import java. io. * ; class GFG { static int findMinSum ( int arr [ ], int n ) { int sum = 0 ; Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( freq. containsKey ( arr [ i ] ) ) { freq. put ( arr [ i ], freq. get ( arr [ i ] ) + 1 ) ; } else { freq. put ( arr [ i ], 1 ) ; } } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > entry : freq. entrySet ( ) ) { int key = entry. getKey ( ) ; int val = entry. getValue ( ) ; if ( val == 1 ) { ans = Math. min ( ans, key ) ; } else { ans = Math. min ( ans, key + ( n - val ) ) ; } } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 1, "}
{"expert":"C++","prediction":"\\n class GFG { static int minSum ( int arr [ ], int n ) { int [ ] freq = new int [ 100005 ] ; Arrays. fill ( freq, 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int res = sum ; for ( int i = 0 ; i < 100005 ; i ++ ) { if ( freq [ i ] > 0 ) { res = Math. min ( res, sum - ( freq [ i ] * i ) ) ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 4, 2, 5 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 10 10 10 10 10 10 10 10 10 10"}
{"expert":"C++","prediction":"View on GitHub [\/INST] \\n class GFG { static int minSum ( int arr [ ], int N ) { int [ ] count = new int [ 1000 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int minSum = sum ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( count [ i ] > 1 ) { minSum = Math. min ( minSum, ( sum - ( count [ i ] * i ) ) ) ; } } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 3, 3, 3, 4, 4, 4, 5, 5 } ; int N = arr. length ; System. out. print ( minSum ( arr, N ) ) ; } } 2 \/ https:\/\/www.geeksforgeeks.org"}
{"expert":"Javascript","prediction":" \\n 9 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10"}
{"expert":"C++","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int [ ] frequency = new int [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < 100000 ; i ++ ) { if ( frequency [ i ] > 0 ) { minSum = Math. min ( minSum, sum - frequency [ i ] * i ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 1, 2, 3, 4, 1, 4, 5, 6, 7, 8, 8 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 "}
{"expert":"Javascript","prediction":" \\n class GFG { public static int minSum ( int a [ ], int n ) { int freq [ ] = new int [ 1000000 ] ; Arrays. fill ( freq, 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; sum += a [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { min_sum = Math. min ( min_sum, sum - freq [ a [ i ] ] * a [ i ] ) ; } return min_sum ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 1, 1, 1, 1, 1, 1, 1, 1 } ; int n = a. length ; System. out. println ( minSum ( a, n ) ) ; } } 2 1 2 1 2 1 2 1 2 1 2 1 "}
{"expert":"C++","prediction":"function to check the output ; Function call [\/INST] \\n import java. util. * ; class GFG { public static int minimumSum ( int arr [ ], int n ) { int [ ] map = new int [ 100001 ] ; Arrays. fill ( map, 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; map [ arr [ i ] ] ++ ; } int min = Integer. MAX_VALUE ; for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( map [ i ]!= 0 ) min = Math. min ( min, sum - ( i * map [ i ] ) ) ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 7, 8, 8, 8, 9, 10, 10, 10"}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int a [ ], int n ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( a [ i ] ) ) { mp. put ( a [ i ], mp. get ( a [ i ] ) + 1 ) ; } else { mp. put ( a [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int minSum = sum ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { if ( it. getValue ( ) == 1 ) { minSum -= it. getKey ( ) ; } else { minSum -= ( ( it. getValue ( ) - 1 ) * it. getKey ( ) ) ; } } return minSum ; } public static void main ( String args [ ] ) { int a [ ] = { 5, 5"}
{"expert":"Java","prediction":"\\n class GFG { static int minSum ( int arr [ ], int n ) { int freq [ ] = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int min_sum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { min_sum = Math. min ( min_sum, sum - freq [ i ] * i ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 3, 4, 5 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 ; 1 2 3 4 5 ; 2 2 3 4 5 ; 3 2 2 3 4 5 ; 4 2 2 2 3 4 5 ; 5 2 2 2 2"}
{"expert":"Python","prediction":"Write a C ++ program to complete the following tasks. Minimum sum possible by removing all occurrences of any array element | Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Input array ; Size of array [\/INST] \\n 8 15 13 13 15 12 14 15 11 11 13 15 16 17 18 19 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19 13 15 19"}
{"expert":"C++","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int [ ] arr, int N ) { Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq. containsKey ( arr [ i ] ) ) freq. put ( arr [ i ], freq. get ( arr [ i ] ) + 1 ) ; else freq. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : freq. entrySet ( ) ) { minSum = Math. min ( minSum, sum - i. getValue ( ) * i. getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int [ ] arr = { 1, 2, 1, 2, 1 } ; int N = arr. length ;"}
{"expert":"Java","prediction":"1 ) Find the sum of all the elements in the array 2 ) Find the frequency of each element in the array 3 ) Find the minimum value of the sum of all the elements of the array after deleting all the occurrences of any element from the array 4 ) Print the minimum sum 5 ) Driver Code [\/INST] \\n class GFG { static int minSum ( int arr [ ], int n ) { int i, sum = 0 ; Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; map. put ( arr [ i ], map. get ( arr [ i ] )!= null? map. get ( arr [ i ] ) + 1 : 1 ) ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { int x = it. getKey ( ) ; int y = it. getValue ( ) ; minSum = Math. min ( minSum, sum - x * y ) ; } return min"}
{"expert":"Java","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( a [ i ], map. get ( a [ i ] ) == null? 1 : map. get ( a [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { minSum = Math. min ( minSum, sum - ( it. getValue ( ) * it. getKey ( ) ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 1, 2, 2, 3, 4, 4, 4, 4, 5, 5 } ; int n = a"}
{"expert":"Python","prediction":"Write a C ++ program to complete the following tasks. Minimum sum possible by removing all occurrences of any array element | Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Input array ; Size of array [\/INST] \\n class GfG { public static int minSum ( int arr [ ], int n ) { int sum = 0 ; Map < Integer, Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], 0 ) ; sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : mp. entrySet ( ) ) { int tempSum = sum - ( i. getValue ( ) * i. getKey ( ) ) ; if ( tempSum < minSum ) minSum = tempSum ; } return minSum ; } public static void main ( String [ ] args ) {"}
{"expert":"Python","prediction":" \\n 1. [INST] import java. util. * ; class GFG { static int minSum ( int a [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( a [ i ] ) ) { mp. put ( a [ i ], mp. get ( a [ i ] ) + 1 ) ; } else { mp. put ( a [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > x : mp. entrySet ( ) ) { min = Math. min ( min, sum - x. getValue ( ) * x. getKey ( ) ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 4 } ; int n = arr. length ;"}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > m = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m. containsKey ( arr [ i ] ) ) m. put ( arr [ i ], m. get ( arr [ i ] ) + 1 ) ; else m. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : m. entrySet ( ) ) { min_sum = Math. min ( min_sum, sum - ( it. getValue ( ) * it.getKey ( ) ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 3, 3, 3, 4"}
{"expert":"Python","prediction":" \\n public class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; Map < Integer, Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map. containsKey ( arr [ i ] ) ) map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; else map. put ( arr [ i ], 1 ) ; sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : map. entrySet ( ) ) { if ( i. getValue ( ) == 1 ) continue ; minSum = Math. min ( minSum, sum - i. getValue ( ) * i.getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 3, 4, 4, 5 } ; int n = arr. length ; System. out. print ( minSum ( arr, n )"}
{"expert":"Java","prediction":" \\n import java. io. * ; import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( a [ i ], mp. get ( a [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int minSum = sum ; for ( Map. Entry < Integer, Integer > i : mp. entrySet ( ) ) { minSum = Math. min ( minSum, sum - i. getValue ( ) * i. getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 2, 2, 3, 3, 3, 3, 4 } ; int n = a. length ; System. out. print ( minSum ( a, n ) ) ; } } 1 2"}
{"expert":"C++","prediction":"import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp. put ( arr [ i ], mp. get ( arr [ i ] ) == null? 1 : mp. get ( arr [ i ] ) + 1 ) ; } int res = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > x : mp. entrySet ( ) ) { int cur_sum = sum - ( x. getValue ( ) * x. getKey ( ) ) ; res = Math. min ( res, cur_sum ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 2, 2, 3, 4, 4, 4, 4 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; }"}
{"expert":"Javascript","prediction":" \\n class GFG { static int minSum ( int arr [ ], int N ) { int cnt [ 100000 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { cnt [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } int minSum = sum ; for ( int i = 0 ; i < 100000 ; i ++ ) { if ( cnt [ i ] ) minSum = min ( minSum, sum - cnt [ i ] * i ) ; } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 10, 10, 10, 10, 10, 10, 10, 10 } ; int N = arr. length ; System. out. print ( minSum ( arr, N ) ) ; } } 10 90 80 70 60 50 40 "}
{"expert":"C++","prediction":" \\n 9 4 4 4 4 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 "}
{"expert":"C++","prediction":" \\n 10 2 2 3 4 4 5 6 6 6 7 8 9 9 10 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80"}
{"expert":"Java","prediction":"63 ; Function call [\/INST] \\n 63 ; Driver code [\/INST] \\n 63 ; Input array ; Size of array [\/INST] \\n 63 ; Function call [\/INST] \\n 63 ; Driver code [\/INST] \\n 63 ; Input array ; Size of array [\/INST] \\n 63 ; Function call [\/INST] \\n 63 ; Driver code [\/INST] \\n 63 ; Input array ; Size of array [\/INST] \\n 63 ; Function call [\/INST] \\n 63 ; Driver code [\/INST] \\n 63 ; Input array ; Size of array [\/INST] \\n 63 ; Function call [\/INST] \\n 63 ; Driver code [\/INST] \\n 63 ; Input array ; Size of array [\/INST] \\n 63 ; Function call [\/INST] \\n 63 ; Driver code [\/INST] \\n 63 ; Input array ; Size of array [\/INST] \\n 63 ; Function call [\/INST] \\n"}
{"expert":"C++","prediction":"\\n class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; int map [ 101 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; map [ arr [ i ] ] ++ ; } int ans = sum ; for ( int i = 0 ; i < 101 ; i ++ ) { if ( map [ i ] > 1 ) ans -= ( map [ i ] * i ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 2, 3, 3, 3, 4, 4, 4 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 2 ; 1 ; 1 ; 2 ; 2 ; 3 ; 3 ; 3 ; 4 ; 4 ; 4 ; 2 ; 1 ; 1 ; 2 ; 2 ; 3 ; 3 ; 3 ;"}
{"expert":"C++","prediction":" \\n 1 2 3 4 3 4 1 1 2 3 4 4 4 2 1 1 1 1 2 3 4 4 2 4 3 2 4 3 4 3 4 3 4 3 1 3 2 1 2 3 4 4 2 1 1 4 4 2 4 2 2 1 1 2 2 2 1 1 1 2 1 2 1 3 1 1 3 4 4 2 1 3 1 4 4 2 3 1 4 3 4 1 2 1 3 1 1 2 4 1 1 3 4 2 2 1 1 4 4 4 4 3 4 3 3 4 1 1 3 4 3 4 4 3 4 4 2 1 1 1 2 3 4 3 "}
{"expert":"Python","prediction":" \\n 7 4 5 5 7 7 5 [\/INST] \\n 2 [\/INST] \\n 7 [\/INST] \\n 5 [\/INST] \\n 10 [\/INST] \\n 15 [\/INST] \\n 12 [\/INST] \\n 9 [\/INST] \\n 8 [\/INST] \\n 14 [\/INST] \\n 13 [\/INST] \\n 11 [\/INST] \\n 10 [\/INST] \\n 2 [\/INST] \\n 17 [\/INST] \\n 18 [\/INST] \\n 19 [\/INST] \\n 16 [\/INST] \\n 15 [\/INST] \\n 14 [\/INST] \\n 13 [\/INST] \\n 12 [\/INST] \\n 11 [\/INST] \\n 10 [\/INST] \\n 9 [\/INST] \\n 8 [\/INST] \\n 7 [\/INST] \\n 6 [\/"}
{"expert":"Java","prediction":"\\n class Solution { public: int minSum ( int arr [ ], int n ) { map < int, int > map1 ; for ( int i = 0 ; i < n ; i ++ ) { map1. insert ( { arr [ i ], 1 } ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = INT_MAX ; for ( auto it : map1 ) { minSum = min ( minSum, sum - it. first * it. second ) ; } return minSum ; } } ; int main ( ) { int arr [ ] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, "}
{"expert":"Javascript","prediction":" \\n class GFG { static int minSum ( int arr [ ], int N ) { int sum = 0 ; int count [ 100 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; count [ arr [ i ] ] ++ ; } int minSum = INT_MAX ; for ( int i = 1 ; i <= 100 ; i ++ ) { if ( count [ i ] > 0 ) minSum = Math. min ( minSum, sum - i * count [ i ] ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 3, 2, 1 } ; int N = arr. length ; System. out. println ( minSum ( arr, N ) ) ; } } 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 "}
{"expert":"Java","prediction":" \\n class GFG { static int minSum ( int arr [ ], int N ) { int i ; Map < Integer, Integer > mp ; for ( i = 0 ; i < N ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; else mp. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min = Integer. MAX_VALUE ; for ( int key : mp. keySet ( ) ) { int count = mp. get ( key ) ; min = Math. min ( min, sum - ( count * key ) ) ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 1, 2, 3, 3, 4, 4 } ; int N = arr. length ; System. out. print ( minSum ( arr, N ) ) ; } } 1 1 2 "}
{"expert":"Java","prediction":"\\n class Solution { public static int minSum ( int arr [ ], int n ) { int [ ] freq = new int [ n + 1 ] ; Arrays. fill ( freq, 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int minSum = Integer. MAX_VALUE ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( freq [ i ] > 0 ) minSum = Math. min ( minSum, sum - i * freq [ i ] ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 6 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 2 \\n [\/INST] \\n 123456"}
{"expert":"Python","prediction":"View on GitHub [\/INST] \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { int x = it. getValue ( ) ; min_sum = Math. min ( min_sum, sum - n * x + x ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 3, 3, 4, 5 } ; int n = arr. length ; System. out. print"}
{"expert":"Javascript","prediction":"import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( arr [ i ], map. get ( arr [ i ] ) == null? 1 : map. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { min = Math. min ( min, sum - ( it. getValue ( ) * it.getKey ( ) ) ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 1, 5, 6, 7, 2, 3 } ; int n = arr. length ; System. out. println ( minSum"}
{"expert":"C++","prediction":" import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; map. put ( arr [ i ], map. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getKey ( ) * it. getValue ( ) ) ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } "}
{"expert":"Javascript","prediction":" \\n 1 \\n 2 \\n 3 \\n 4 \\n 5 \\n 6 \\n 7 \\n 8 \\n 9 \\n 10 \\n 11 \\n 12 \\n 13 \\n 14 \\n 15 \\n 16 \\n 17 \\n 18 \\n 19 \\n 20 \\n 21 \\n 22 \\n 23 \\n 24 \\n 25 \\n 26 \\n 27 \\n 28 \\n 29 \\n 30 \\n 31 \\n 32 \\n 33 \\n 34 \\n 35 \\n 36 \\n 37 \\n 38 \\n 39 \\n 40 \\n 41 \\n 42 \\n 43 \\n 44 \\n 45 \\n 46 \\n 47 \\n 48 \\n 49 \\n 50 \\n 51 \\n 52"}
{"expert":"Javascript","prediction":"import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m. containsKey ( arr [ i ] ) ) { m. put ( arr [ i ], m. get ( arr [ i ] ) + 1 ) ; } else { m. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : m. entrySet ( ) ) { minSum = Math. min ( minSum, sum - it. getValue ( ) * it.getKey ( ) ) ; } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 3, 4, 5, 6 } ; int n = arr. length ; System. out. print ("}
{"expert":"C++","prediction":" \\n class GFG { static int findMinSum ( int arr [ ], int N ) { int cnt [ 100001 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { cnt [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } int minSum = sum ; for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( cnt [ i ]!= 0 ) { minSum = min ( minSum, sum - i * cnt [ i ] ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 3, 4, 5 } ; int N = arr. length ; System. out. println ( findMinSum ( arr, N ) ) ; } } 1 2 3 3 4 5 ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;"}
{"expert":"Javascript","prediction":" \\n 1 \\n 1 2 2 3 3 3 4 4 4 4 5 5 6 6 6 7 7 7 7 8 9 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 "}
{"expert":"Javascript","prediction":"public class GFG { public static int minSum ( int arr [ ], int n ) { int sum = 0, ans = Integer. MAX_VALUE ; @ SuppressWarnings ( \" unchecked \" ) Map < Integer, Integer > mp = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) == null? 1 : mp. get ( arr [ i ] ) + 1 ) ; sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int curr = mp. get ( arr [ i ] ) == null? 0 : mp. get ( arr [ i ] ) ; ans = Math. min ( ans, sum - curr * arr [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2, 3, 4, 3, 5, 6, 5 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1"}
{"expert":"Java","prediction":" \\n 9 3 1 1 2 5 5 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 "}
{"expert":"Javascript","prediction":"\\n class Hashing { static int findMinSum ( int a [ ], int n ) { int sum = 0 ; Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; map. put ( a [ i ], map. get ( a [ i ] ) == null? 1 : map. get ( a [ i ] ) + 1 ) ; } int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { min = Math. min ( min, sum - it. getKey ( ) * it. getValue ( ) ) ; } return min ; } public static void main ( String args [ ] ) { int a [ ] = { 1, 2, 2, 3, 4, 5, 5, 5 } ; int n = a. length ; System. out. println ( findMinSum ( a, n ) ) ; } } 1 2 2 3 4 5 5 5"}
{"expert":"Javascript","prediction":" \\n import java. io. * ; import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( arr [ i ], map. get ( arr [ i ] ) == null? 1 : map. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int res = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { res = Math. min ( res, ( it. getValue ( ) * it. getKey ( ) ) ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2, 2, 3, 3, 5, 6, 7, 9, 10 } ; int n = arr. length ; System."}
{"expert":"Java","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int i, sum = 0 ; int ans = 0 ; int count [ 101 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; count [ arr [ i ] ] ++ ; } for ( i = 1 ; i <= 100 ; i ++ ) { ans += Math. min ( sum, count [ i ] * i ) ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 4, 2, 5, 1, 1, 1, 5 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 2 \/ 5 2 \/ 5 1 1 1 1 1 5 4 2 5 1 1 1 1 1 5 4 2 5 1 1 1 1 1 1 1 1 1 1 "}
{"expert":"Java","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { HashMap < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq. containsKey ( a [ i ] ) ) { freq. put ( a [ i ], freq. get ( a [ i ] ) + 1 ) ; } else { freq. put ( a [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : freq. entrySet ( ) ) { min = Math. min ( min, ( i. getValue ( ) * ( i. getKey ( ) ) ) ) ; } return sum - min ; } public static void main ( String [ ] args ) { int a [ ] = { 2, 3, 2, 4 } ; int n = a. length"}
{"expert":"Python","prediction":"\\n class GFG { static int findMinSum ( int arr [ ], int n ) { int cnt [ 100 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { cnt [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < 100 ; i ++ ) { if ( cnt [ i ] > 0 ) minSum = Math. min ( minSum, sum - i * cnt [ i ] ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 1, 2, 3, 4 } ; int n = arr. length ; System. out. println ( findMinSum ( arr, n ) ) ; } } 2 \/ 2 100 100 2 1 1 1 1 1 1 1 "}
{"expert":"C++","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int freq [ 1000 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int min = sum ; for ( int i = 0 ; i < 1000 ; i ++ ) { min = Math. min ( min, sum - freq [ i ] * i ) ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 1, 2, 2, 3, 3, 4 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 1 2 2 3 3 4 ; 16 ; 16 ; 16 ; 16 ; 16 ; 16 ; 16 ; 16 ; "}
{"expert":"Javascript","prediction":" \\n 12 \/ 1 \/ 5 \/ 12 \/ 22 \/ 22 \/ 1 \/ 1 \/ 1 \/ 1 \/ 5 \/ 2 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ 1 \/ "}
{"expert":"Python","prediction":" \\n 9 13 13 12 12 11 11 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9 9 10 10 10 10 9 9"}
{"expert":"Python","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m. containsKey ( arr [ i ] ) ) { m. put ( arr [ i ], m. get ( arr [ i ] ) + 1 ) ; } else { m. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : m. entrySet ( ) ) { int key = it. getKey ( ) ; int val = it. getValue ( ) ; minSum = Math. min ( minSum, sum - key * val ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 5"}
{"expert":"Java","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int [ ] freq = new int [ 100001 ] ; Arrays. fill ( freq, 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < 100001 ; i ++ ) { if ( freq [ i ] > 0 ) minSum = Math. min ( minSum, sum - i * freq [ i ] ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2, 3, 5, 5, 5, 3, 2, 2, 1, 1, 1 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 3 5 5 5 3"}
{"expert":"C++","prediction":"\\n class pair { public : int first ; int second ; public : pair ( int a, int b ) { first = a ; second = b ; } } ; 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39"}
{"expert":"Javascript","prediction":"import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { Map < Integer, Integer > m = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m. put ( a [ i ], m. get ( a [ i ] ) == null? 1 : m. get ( a [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : m. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getValue ( ) * it.getKey ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 3, 5, 3, 2, 1, 2, 4, 5 } ; int n = a. length ; System. out. println ( minSum ( a, n"}
{"expert":"Python","prediction":"import java. util. * ; class GFG { public static int minSum ( int [ ] arr, int n ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { int curr_sum = sum - it. getKey ( ) * it. getValue ( ) ; min_sum = Math. min ( curr_sum, min_sum ) ; } return min_sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1 } ; int n = arr. length ; System. out. println ( minSum ( arr, n"}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int N ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { map. put ( arr [ i ], map. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { min_sum = Math. min ( min_sum, sum - ( it. getValue ( ) * it. getKey ( ) ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 2, 3, 3, 4, 4, 4 } ; int N = arr. length ; System. out. println ( minSum"}
{"expert":"Python","prediction":"\\n class GFG { static int minSum ( int arr [ ], int N ) { int ans = 0 ; int sum = 0 ; Map < Integer, Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; map. put ( arr [ i ], map. get ( arr [ i ] )!= null? map. get ( arr [ i ] ) + 1 : 1 ) ; } for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getKey ( ) * it. getValue ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } ; int N = arr. length ; System. out. print ( minSum ( arr, N ) ) ; } } 1 ; 2 ; 3 ; 4 ; 5 ; 6 ; "}
{"expert":"Javascript","prediction":" \\n 9 12 12 12 12 13 13 14 15 15 15 15 16 16 16 17 17 17 18 18 18 18 18 19 19 19 20 20 20 21 21 22 22 22 23 23 24 24 24 25 25 25 26 26 27 27 27 28 28 28 29 29 29 29 30 30 30 30 30 31 31 32 32 32 32 32 32 33 33 33 33 33 33 34 34 34 34 34 35 35 35 35 35"}
{"expert":"Python","prediction":"import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > entry : mp. entrySet ( ) ) { int currentMinSum = sum - ( entry. getValue ( ) * ( entry. getKey ( ) ) ) ; if ( currentMinSum < minSum ) { minSum = currentMinSum ; } } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 1, 2, 2, 2 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 12 \/ 12 \u8f93\u5165 1,"}
{"expert":"Javascript","prediction":" \\n 999 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223 223"}
{"expert":"C++","prediction":" \\n class GFG { public static int minSum ( int a [ ], int n ) { int [ ] freq = new int [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ a [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int min_sum = Integer. MAX_VALUE ; for ( int i = 1 ; i < 1000 ; i ++ ) { min_sum = Math. min ( min_sum, sum - ( freq [ i ] * i ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 1, 1, 2, 3 } ; int n = a. length ; System. out. print ( minSum ( a, n ) ) ; } } 2 1 1 1 2 3 ; 1 1 2 3 5 ; 1 1 1 2 3 5 ; 1"}
{"expert":"Javascript","prediction":"View on Qunki : https : \u2215 \u2215 \u2215 stackoverflow. com \u2215 qunki \u2215 58094082 [\/INST] \\n class GFG { static int minimumSum ( int a [ ], int n ) { int freq [ 100 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int ans = sum ; for ( int i = 1 ; i <= 100 ; i ++ ) { ans = min ( ans, sum - freq [ i ] * i ) ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6 } ; int n = a. length ; System. out. print"}
{"expert":"Python","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; else mp. put ( arr [ i ], 1 ) ; sum += arr [ i ] ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getValue ( ) * it.getKey ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 1, 2, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 2"}
{"expert":"Javascript","prediction":" \\n class GFG { public static int findMin ( int a [ ], int n ) { int map [ ] = new int [ 100001 ] ; for ( int i = 0 ; i < n ; i ++ ) { map [ a [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int min = Integer. MAX_VALUE ; for ( int i = 1 ; i < 100001 ; i ++ ) { if ( map [ i ] > 0 ) { min = Math. min ( min, sum - i * map [ i ] ) ; } } return min ; } public static void main ( String args [ ] ) { int a [ ] = { 1, 2, 1, 3, 3, 4, 5, 5 } ; int n = a. length ; System. out. print ( findMin ( a, n ) ) ; } } 1 2 1 3 3 4 5 5 ; 1 1 1"}
{"expert":"Java","prediction":" \\n 3 1 2 3 4 1 2 5 2 3 1 2 3 4 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2"}
{"expert":"Java","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map. containsKey ( arr [ i ] ) ) { map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; } else { map. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { int x = Math. min ( it. getValue ( ), sum - it. getKey ( ) ) ; min = Math. min ( x, min ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 3, 4, 5, 1"}
{"expert":"C++","prediction":"\\n class GFG { static int minSum ( int arr [ ], int N ) { int map [ 100000 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { map [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } int min_sum = INT_MAX ; for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( map [ i ] > 0 ) { min_sum = Math. min ( min_sum, ( sum - ( i * map [ i ] ) ) ) ; } } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 2, 3, 3, 4, 4, 5, 5 } ; int N = arr. length ; System. out. print ( minSum ( arr, N ) ) ; } } 1111111111"}
{"expert":"Python","prediction":"\\n class pair { int key ; int val ; public : pair ( int k, int v ) { key = k ; val = v ; } } ; void print ( pair * arr, int size ) { for ( int i = 0 ; i < size ; i ++ ) { cout << arr [ i ]. key << \"   \" << arr [ i ]. val << endl ; } } \\n void print ( pair * arr, int size ) { for ( int i = 0 ; i < size ; i ++ ) { cout << arr [ i ]. key << \"   \" << arr [ i ]. val << endl ; } } \\n 1 ; 3 ; 1 ; 2 ; 3 ; 2 ; 1 ; 1 ; 2 ; 2 ; 3 ; 3 ; 1 ; 2 ; 1 ; 1 ; 2 ; 3 ; 2 ; 3 ; 1 ; 3 ; 1 ; 2 ; 3 ; 1 ; 2 ; 3 ; 2 ; 1 ; 1 ; 1 ; 2 ; 3 ; 2 ; 3 ; 1 ; "}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { ans = Math. min ( ans, sum - ( it. getValue ( ) * ( it. getKey ( ) ) ) ) ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 3, 1, 2, 2, 3 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 3 4 5 6"}
{"expert":"Python","prediction":" \\n 9 2 4 1 1 1 5 2 5 2 4 1 1 1 2 2 1 1 4 2 5 1 2 1 1 5 2 5 1 1 1 5 2 5 1 1 1 5 2 1 5 1 2 1 1 1 5 2 5 1 1 1 5 2 1 5 1 2 1 1 1 5 2 1 5 1 2 1 1 1 5 2 5 1 1 1 5 2 1 5 1 2 1 1 1 5 2 1 5 1 2 1 1 1 5 2 5 1 1 1 5 2 1 5 1 2 1 1 1 5 2 1 5 1 2 1 1 1 5 2 5 1 1 "}
{"expert":"Java","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq. put ( arr [ i ], freq. get ( arr [ i ] ) == null? 1 : freq. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : freq. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getValue ( ) * it.getKey ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 3, 1, 5, 1, 3, 3, 3, 1 } ; int n = arr. length ; System. out."}
{"expert":"C++","prediction":"\\n import java. util. * ; class GFG { static int minimumSum ( int arr [ ], int N ) { Map < Integer, Integer > mp = new HashMap < > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; else mp. put ( arr [ i ], 1 ) ; sum += arr [ i ] ; } int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { min = Math. min ( min, sum - ( it. getValue ( ) * it. getKey ( ) ) ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 2 } ; int N = arr. length ; System. out. print ( minimumSum ( arr, N ) ) ; } } 1\/ 10 ; 2\/ 10 ;"}
{"expert":"Java","prediction":" \\n import java. io. * ; class GFG { static int minSum ( int a [ ], int n ) { int [ ] freq = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * freq [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) { minSum = Math. min ( minSum, sum - i * freq [ i ] ) ; } return minSum ; } public static void main ( String [ ] args ) { int a [ ] = { 3, 3, 3, 3, 3 } ; int n = a. length ; System. out. println ( minSum ( a, n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1"}
{"expert":"C++","prediction":"\\n import java. io. * ; import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) == null? 1 : mp. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { min_sum = Math. min ( min_sum, ( sum - it. getValue ( ) * it. getKey ( ) ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 3, 4 } ; int n = arr. length ; System. out. println"}
{"expert":"Javascript","prediction":" \\n import java. util. * ; class GFG { static int minimumSum ( int arr [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map. containsKey ( arr [ i ] ) ) map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; else map. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minimumSum = Integer. MAX_VALUE ; for ( int key : map. keySet ( ) ) { int count = map. get ( key ) ; minimumSum = Math. min ( minimumSum, sum - count * key ) ; } return minimumSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3, 2, 2, 3, 2, 3 } ; int n = arr. length ; System. out. print ( minimumSum ( arr,"}
{"expert":"Java","prediction":" \\n 9 7 5 8 8 7 7 3 6 9 9 9 7 9 6 8 5 8 7 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6 6 8 6 7 5 6 6"}
{"expert":"C++","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int freq [ 100 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < 100 ; i ++ ) sum += ( freq [ i ] * i ) ; int ans = sum ; for ( int i = 1 ; i < 100 ; i ++ ) { if ( freq [ i ] > 0 ) { ans = Math. min ( ans, sum - ( i * freq [ i ] ) + ( ( i - 1 ) * ( freq [ i ] - 1 ) ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 1, 2, 2, 3, 3, 3, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1"}
{"expert":"Python","prediction":"\\n 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 1"}
{"expert":"Javascript","prediction":"import java. io. * ; class GFG { public static int minSum ( int arr [ ], int n ) { int sum = 0 ; int freq = 0 ; @ SuppressWarnings ( \" unchecked \" ) Map < Integer, Integer > m = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; m. put ( arr [ i ], m. get ( arr [ i ] ) == null? 0 : m. get ( arr [ i ] ) + 1 ) ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq > 0 ) { m. put ( arr [ i ], m. get ( arr [ i ] ) - 1 ) ; freq -= 1 ; } minSum = Math. min ( minSum, sum - ( n - 1 ) * arr [ i ] ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 5, 5, 5, "}
{"expert":"Java","prediction":" \\n 3 1 3 3 4 4 3 3 4 4 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6"}
{"expert":"Python","prediction":"Write a C ++ program to complete the following tasks. Minimum sum possible by removing all occurrences of any array element | Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Input array ; Size of array [\/INST] \\n 9 10 11 12 13 10 11 13 12 10 14 11 13 15 12 13 15 11 12 15 11 13 10 11 15 14 12 10 13 11 14 15 16 10 11 13 14 15 12 11 13 15 16 10 14 15 11 12 13 14 15 16 12 10"}
{"expert":"Javascript","prediction":" \\n class GFG { public static int minSum ( int arr [ ], int n ) { int [ ] freq = new int [ n + 1 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) sum += i ; int minSum = Integer. MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) { minSum = Math. min ( minSum, sum - freq [ i ] * i ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 1, 2, 2 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 "}
{"expert":"C++","prediction":"\\n class GFG { static int minSum ( int arr [ ], int n ) { int i, sum = 0 ; int min = Integer. MAX_VALUE ; Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], 1 ) ; } for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp. containsKey ( arr [ i ] ) ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; } } for ( Map. Entry < Integer, Integer > entry : mp. entrySet ( ) ) { int key = entry. getKey ( ) ; int value = entry. getValue ( ) ; if ( value == 1 ) { min = Math. min ( min, key ) ; } else { min = Math. min ( min, key + 1 ) ; } } return sum - min ; } public static void main ( String [ ] args ) { int arr [ ] = { 2, 1"}
{"expert":"C++","prediction":"View on Qunki : https : \/\/ www. qunki. com \/ dijit \/ problem \/ minimum - sum - possible - after - deletion ; Driver code [\/INST] \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; } else { mp. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { int num = it. getKey ( ) ; int freq = it. getValue ( ) ; minSum = Math. min ( minSum, sum - num *"}
{"expert":"C++","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int N ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; } else { mp. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { minSum = Math. min ( minSum, sum - it. getValue ( ) * it.getKey ( ) ) ; } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 3, 1, 2, 2, 3, 1 } ; int"}
{"expert":"Java","prediction":" \\n class GFG { static int findMinSum ( int arr [ ], int n ) { int i, sum = 0, count, min_sum = Integer. MAX_VALUE ; Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( map. containsKey ( arr [ i ] ) ) { count = map. get ( arr [ i ] ) ; map. put ( arr [ i ], count + 1 ) ; } else map. put ( arr [ i ], 1 ) ; } for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { count = it. getValue ( ) ; min_sum = Math. min ( min_sum, sum - count * it. getKey ( ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 2, 3, 4, 4, 5, 5, 5, 6, 7, 8 }"}
{"expert":"Python","prediction":" import java. io. * ; class GFG { public static int minSum ( int arr [ ], int n ) { @ SuppressWarnings ( \" unchecked \" ) Map < Integer, Integer > freq = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq. containsKey ( arr [ i ] ) ) freq. put ( arr [ i ], ( int ) freq. get ( arr [ i ] ) + 1 ) ; else freq. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq. containsKey ( arr [ i ] ) && ( minSum > arr [ i ] + freq. get ( arr [ i ] ) * ( n - 1 - freq. get ( arr [ i ] ) ) ) ) minSum = arr [ i ] + freq. get ( arr [ i ] )"}
{"expert":"Java","prediction":" \\n class GFG { static int minimumSum ( int arr [ ], int n ) { int sum = 0 ; int min_sum = Integer. MAX_VALUE ; Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq. put ( arr [ i ], freq. get ( arr [ i ] ) == null? 1 : freq. get ( arr [ i ] ) + 1 ) ; } for ( Map. Entry < Integer, Integer > it : freq. entrySet ( ) ) { int ele = it. getKey ( ) ; int freq = it. getValue ( ) ; min_sum = Math. min ( min_sum, sum - ( ele * freq ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 4, 4, 5, 6, 6, 6, 7, 7, 8,"}
{"expert":"C++","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map. put ( arr [ i ], map. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { int currSum = sum - it. getValue ( ) * it. getKey ( ) ; minSum = Math. min ( minSum, currSum ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1"}
{"expert":"Java","prediction":" \\n 9 10 10 10 10 10 11 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12"}
{"expert":"C++","prediction":" \\n import java. io. * ; class GFG { public static int minSum ( int arr [ ], int N ) { int freq [ ] = new int [ N + 1 ] ; int sum = 0 ; int min_sum = Integer. MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( freq [ i ]!= 0 ) { min_sum = Math. min ( min_sum, sum - i * ( freq [ i ] - 1 ) ) ; } } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 4, 5, 6, 6, 6, 7, 7, 7, 7, 7, 8, 9 } ; int N = arr. length ; System. out. print ( minSum ( arr, N ) ) ; } } 1 "}
{"expert":"Python","prediction":" \\n 3 1 2 2 3 4 4 4 5 5 5 6 6 7 7 7 7 7 7 8 8 8 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10"}
{"expert":"Python","prediction":" \\n 9 3 1 7 1 4 7 7 4 3 1 1 100 5 1 5 1 1 100 5 1 1 100 2 1 5 1 1 100 2 1 5 1 1 100 2 1 1 100 2 1 1 100 2 1 100 2 1 1 100 2 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2 1 1 100 2"}
{"expert":"Python","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int freq [ n + 1 ] = { 0 } ; int sum = 0 ; int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( freq [ i ] > 0 ) { minSum = Math. min ( minSum, sum - freq [ i ] * i ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 1, 2, 2, 3, 3, 3 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 1 1 2 2 3 3 3 ; 1 1 1 2 2 3 3 3 ; 1 1 1"}
{"expert":"Java","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq. put ( arr [ i ], freq. get ( arr [ i ] ) == null? 1 : freq. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : freq. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getValue ( ) * it.getKey ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 3, 4, 5, 6, 7, 8, 9 } ; int n = arr. length"}
{"expert":"Javascript","prediction":" \\n 96 2 96 1 2 2 96 2 2 1 96 2 1 2 96 2 1 2 96 1 2 2 2 1 96 2 1 2 2 96 1 2 96 1 2 1 96 2 96 96 96 96 96 96 96 2 2 96 96 96 96 96 96 2 2 96 2 96 2 1 2 2 2 1 96 1 2 2 96 1 2 96 2 1 2 1 96 1 2 96 1 2 96 1 2 96 1 2 1 96 1 2 1 96 2 96 1 2 96 2 2 2 1 2 2 1"}
{"expert":"Java","prediction":"\\n class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; int freq [ 100 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int minSum = sum ; for ( int i = 0 ; i < 100 ; i ++ ) { if ( freq [ i ] % 2 == 1 ) { minSum -= ( i * freq [ i ] ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 3, 3, 4, 4, 4, 5 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 13 \/INST] \\n class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; int freq [ 100 ] = { 0 } ; for"}
{"expert":"Python","prediction":"Write a C ++ program to complete the following tasks. Minimum sum possible by removing all occurrences of any array element | Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Input array ; Size of array [\/INST] \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) == null? 1 : mp. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > entry : mp. entrySet ( ) ) { min = Math. min"}
{"expert":"Python","prediction":" \\n import java. io. * ; class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; int [ ] freq = new int [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int res = Integer. MAX_VALUE ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( freq [ i ] > 0 ) res = Math. min ( res, sum - i * freq [ i ] ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 2 3 4 5 6 1 2 3 4 5 6 "}
{"expert":"Python","prediction":"\\n class GFG { public static int minSum ( int arr [ ], int N ) { int i ; int sum = 0 ; int [ ] fre = new int [ N ] ; for ( i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; fre [ i ] = arr [ i ] ; } int min = Integer. MAX_VALUE ; for ( i = 0 ; i < N ; i ++ ) { min = Math. min ( min, sum - fre [ i ] ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 1, 2, 2, 2, 2, 2, 3, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 1 1 2 2 2 2 2 2 3 3 ; 22 ; 10 ; 14 ; 14 ; 12 ; 10 ; 8 ; 6 ; 4 ; 2 ; 1"}
{"expert":"Java","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; else mp. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { min_sum = Math. min ( min_sum, sum - it. getValue ( ) * it.getKey ( ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 3, 1, 2, 1 } ; int n ="}
{"expert":"Java","prediction":" \\n 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 "}
{"expert":"Java","prediction":" class GFG { static int minSum ( int arr [ ], int n ) { int [ ] freq = new int [ n + 1 ] ; Arrays. fill ( freq, 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i <= n ; i ++ ) minSum = Math. min ( minSum, sum - freq [ i ] * i ) ; return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 4, 1, 1, 1, 1, 1 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 2 3 4 1 1 1 1 1 3 3 3 3 4 1 1 1 1 1 "}
{"expert":"Java","prediction":"\\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > m = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m. containsKey ( arr [ i ] ) ) { m. put ( arr [ i ], m. get ( arr [ i ] ) + 1 ) ; } else { m. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : m. entrySet ( ) ) { int x = it. getValue ( ) ; int y = it. getKey ( ) ; minSum = Math. min ( minSum, sum - ( x * y ) ) ; } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 2, 3, "}
{"expert":"Javascript","prediction":" \\n 9 8 3 4 2 2 3 5 8 4 2 8 2 5 9 3 8 4 8 8 3 9 9 8 2 3 8 2 9 8 2 5 9 9 8 2 3 8 8 3 9 8 2 3 8 9 9 8 3 2 3 8 8 3 9 9 8 2 3 8 3 9 9 8 3 2 8 3 8 3 9 9 8 3 9 9 8 3 8 9 3 9 8 3 9 9 8 2 8 2 5 9 9 8 2 8 9 8 3 9 8 2 8 3 9 8 2 5 9 9 8 2 3 8 3 9 9 8 2 3 8 3 9"}
{"expert":"Python","prediction":" \\n 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 "}
{"expert":"C++","prediction":" \\n 1. Function to find minimum sum after deletion ; 2. Create a map to store frequencies ; 3. Iterate over the array ; 4. Get the sum ; 5. Update frequency ; 6. Get the sum ; 7. Update minimum sum ; 8. Driver code [\/INST] \\n class GFG { static int minSum ( int arr [ ], int N ) { int sum = 0, min_sum = INT_MAX ; Map < Integer, Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int val = 0 ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { val = Math. min ( val, it. getValue ( ) * it.getKey ( ) ) ; min_sum = Math. min ( min_sum, sum - val ) ; } return min_sum ; } public static void main ( String [ ]"}
{"expert":"C++","prediction":" \\n 3 5 4 2 4 4 4 3 5 5 6 4 4 4 2 3 5 5 5 5 5 6 4 4 4 2 3 5 5 5 5 5 5 5 6 4 4 4 2 3 5 5 5 5 5 5 5 5 6 4 4 4 2 3 5 5 5 5 5 5 5 5 5 6 4 4 4 2 3 5 5 5 5 5 5 5 5 5 5 5 6 4 4 4 2 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5"}
{"expert":"Java","prediction":" \\n 9 14 3 2 6 2 14 16 1 14 10 10 13 14 1 10 15 14 16 10 10 15 14 14 10 15 14 13 14 10 10 14 14 10 10 15 14 16 10 10 15 14 14 10 15 14 13 14 10 10 14 14 10 10 15 14 16 10 10 15 14 14 10 15 14 13 14 10 10 14 14 10 10 15 14 16 10 10 15 14 14 10 15 14 13"}
{"expert":"Java","prediction":"Write a C ++ program to complete the following tasks. Minimum sum possible by removing all occurrences of any array element | Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Input array ; Size of array [\/INST] \\n class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; int minSum = 0 ; int res = 0 ; int freq [ 100000 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < 100000 ; i ++ ) { minSum += ( i * freq [ i ] ) ; res = Math. max ( res, minSum ) ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 1,"}
{"expert":"Javascript","prediction":" \\n 7 8 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 1"}
{"expert":"Javascript","prediction":" \\n class GFG { public static int minimumSum ( int arr [ ], int n ) { int [ ] freq = new int [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int min_sum = Integer. MAX_VALUE ; for ( int i = 0 ; i < 100 ; i ++ ) { if ( freq [ i ] > 0 ) min_sum = Math. min ( min_sum, ( sum - i * freq [ i ] ) ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 4, 5, 6 } ; int n = arr. length ; System. out. println ( minimumSum ( arr, n ) ) ; } } 1 2 2 3 4 5 6 1 2 2 3 4"}
{"expert":"C++","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map. containsKey ( arr [ i ] ) ) { map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; } else { map. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { min = Math. min ( min, ( sum - ( it. getValue ( ) * it.getKey ( ) ) ) ) ; } return min ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 2, 3, 4, 5, 5 } ; int n = arr"}
{"expert":"Java","prediction":" class GFG { public static int minimumSum ( int arr [ ], int N ) { int sum = 0 ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; arr [ i ] = i + 1 ; } int [ ] freq = new int [ 100005 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int ans = Integer. MAX_VALUE ; for ( int i = 0 ; i < 100005 ; i ++ ) { if ( freq [ i ] > 0 ) { ans = Math. min ( ans, sum - freq [ i ] * i ) ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 2, 1, 3, 4, 2, 1 } ; int N = arr. length ; System. out. print ( minimumSum ( arr, N ) ) ; } } 1 2 3 4"}
{"expert":"C++","prediction":"View on Web 1. https:\/\/goo.gl\/2yLVV1 2. https:\/\/ide.geeksforgeeks.org\/Ep4mQn 3. https:\/\/www.youtube.com\/watch?v=w7-JjHfXzp4 [\/INST] \\n import java. io. * ; import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map. containsKey ( arr [ i ] ) ) map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; else map. put ( arr [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : map. entrySet ( ) ) { minSum = Math"}
{"expert":"Python","prediction":"class hashtable { public : map < int, int > m ; hashtable ( ) { m. clear ( ) ; } ; public : void insert ( int key, int value ) { m [ key ] = value ; } void get ( int key ) { cout << m [ key ] << endl ; } void remove ( int key ) { m. erase ( key ) ; } int size ( ) { return m. size ( ) ; } } ; void findMinSum ( int arr [ ], int N, hashtable hashtableObj ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = sum + arr [ i ] ; hashtableObj. insert ( arr [ i ], hashtableObj. get ( arr [ i ] ) + 1 ) ; } int minSum = INT_MAX ; for ( auto it : hashtableObj. m ) { if ( minSum > it. second * it. first ) { minSum = it. second * it. first ; } } cout << minSum ; } 1, 2, 2, 2, 2, 3,"}
{"expert":"Javascript","prediction":" \\n 9 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"}
{"expert":"C++","prediction":" class Solution { public static int minSum ( int arr [ ], int N ) { int map [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) map [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( int i = 1 ; i <= N ; i ++ ) { minSum = Math. min ( minSum, sum - map [ i ] * i ) ; } return minSum ; } } ---------------------------------------------------------------- 1\/13\/2020 18:05 ---------------------------------------------------------------- 1\/13\/2020 18:05 [INST] View this post on StackOverflow https:\/\/stackoverflow.com\/questions\/63714430 [\/INST] 1 [INST] View this post on GeeksForGeeks https:\/\/www.geeksforgeeks.org\/gfgpractice\/? pid=704289"}
{"expert":"Javascript","prediction":" class GFG { public static int minSum ( int a [ ], int n ) { int [ ] freq = new int [ 1001 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } int sum = 0 ; for ( int i = 1 ; i < 1001 ; i ++ ) { sum += ( i * freq [ i ] ) ; } int minSum = Integer. MAX_VALUE ; for ( int i = 1 ; i < 1001 ; i ++ ) { if ( freq [ i ] > 0 ) { minSum = Math. min ( minSum, sum - ( i * freq [ i ] ) ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 2, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 2 3 4 5 6 7 8 9 1"}
{"expert":"Python","prediction":"import java. util. * ; class GFG { static int minimumSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; } else { mp. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { minSum = Math. min ( minSum, sum - ( it. getValue ( ) * it.getKey ( ) ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 5, 5, 5, 5,"}
{"expert":"C++","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { Map < Integer, Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq. put ( arr [ i ], freq. get ( arr [ i ] ) == null? 1 : freq. get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( freq. containsKey ( i ) ) { minSum = Math. min ( minSum, sum - i * ( freq. get ( i ) == null? 0 : freq. get ( i ) ) ) ; } } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 2, 1, 2, 3, 1, 1,"}
{"expert":"Javascript","prediction":"\\n class GFG { static int minSum ( int arr [ ], int n ) { int sum = 0 ; int freq [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; freq [ arr [ i ] ] ++ ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i <= n ; i ++ ) { minSum = Math. min ( minSum, ( sum - freq [ i ] * i ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3, 4, 3, 4, 3 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 ; 2 ; 3 ; 4 ; 3 ; 1 ; 2 ; 3 ; 4 ; 3 ; 1 ; 2 ; 3 ; 4 ; 3 ; 1 ; 2 ; 3 ; 4 ; 3 ; 1 ;"}
{"expert":"Python","prediction":" \\n 1 2 3 3 3 4 5 5 6 6 7 8 9 10 10 11 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81"}
{"expert":"C++","prediction":" \\n import java. io. * ; class GFG { static int minimumSum ( int arr [ ], int n ) { int map [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] - 1 ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minSum = Math. min ( minSum, sum - map [ i ] * ( i + 1 ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 1, 4, 5, 1, 6 } ; int n = arr. length ; System. out. print ( minimumSum ( arr, n ) ) ; } } 2 7 5 10 15 20 25 30 35 40 45"}
{"expert":"Java","prediction":"1 : Input : arr [ ] = { 1, 1, 2, 3, 3, 4, 5 } ; Size of array = 7 2 : Output : 23 [\/INST] \\n naio [INST] 1 : Input : arr [ ] = { 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6 } ; Size of array = 11 2 : Output : 16 [\/INST] \\n 2 \\n 3 \\n 4 \\n 5 \\n 6 \\n 7 \\n 8 \\n 9 \\n 10 \\n 11 \\n 12 \\n 13 \\n 14 \\n 15 \\n 16 \\n 17 \\n 18 \\n 19 \\n 20 \\n 21 \\n 22 \\n 23 \\n 24 \\n 25 \\n 26 \\n 27 \\n 28 \\n 2"}
{"expert":"Python","prediction":"\\n class solution { public : int minimumSum ( int arr [ ], int n ) { unordered_map < int, int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int ans = INT_MAX ; for ( auto x : freq ) { ans = min ( ans, sum - x. second * x. first ) ; } return ans ; } } ; int main ( ) { int arr [ ] = { 2, 1, 2, 3, 4, 1, 4, 5, 2 } ; int n = sizeof ( arr ) \/ sizeof ( int ) ; cout << solution ( ). minimumSum ( arr, n ) ; return 0 ; } achusethe ; 2 1 2 3 4 1 4 5 2 ; 5 ; 10 ; 10 ; 15 ; 12 ; 9 ; 14 ; 1"}
{"expert":"Java","prediction":" \\n 9 8 8 7 6 6 6 4 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"}
{"expert":"Python","prediction":"import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map. containsKey ( a [ i ] ) ) map. put ( a [ i ], map. get ( a [ i ] ) + 1 ) ; else map. put ( a [ i ], 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int min = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { if ( ( it. getValue ( ) * it. getKey ( ) ) < min ) min = it. getValue ( ) * it. getKey ( ) ; } return ( sum - min ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 1, 3, 3, 5, 5, 5, "}
{"expert":"Javascript","prediction":" \\n 9 6 6 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 "}
{"expert":"C++","prediction":"View on Qunki : https : www. qunki. com \/ question \/ Minimum-sum-after-deleting - all - occurrences - of - any - array - element \/ 174503923 \/ ; Driver Code [\/INST] \\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int N ) { Map < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq. containsKey ( arr [ i ] ) ) { freq. put ( arr [ i ], freq. get ( arr [ i ] ) + 1 ) ; } else { freq. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : freq. entrySet ( ) ) { int cur = 0 ; if ( it"}
{"expert":"Javascript","prediction":" class GFG { static int minSum ( int arr [ ], int n ) { int map [ 100 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min_sum = sum ; for ( int i = 1 ; i < 100 ; i ++ ) { if ( map [ i ] > 0 ) { min_sum = min ( min_sum, sum - i * map [ i ] ) ; } } return min_sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 2, 3, 4, 5, 6, 1, 2, 3 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 2 2 4 4 5 5 6 6 1 2 3 3 1 "}
{"expert":"Javascript","prediction":"View this in Orion 2. 1. 0. 0. https : www. geeksforgeeks. org \/ 2. 1. 0. 0 \/ 52397747 [\/INST] \\n import java. io. * ; class GFG { static int minSum ( int arr [ ], int n ) { int map [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { map [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] - 1 ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int res = Integer. MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { res = Math. min ( res, sum - map [ i ] * ( arr [ i ] * map [ i ] \/ 2 ) ) ; } return res ; } public static void main ( String [ ] args ) { int arr ["}
{"expert":"Java","prediction":"\\n import java. util. * ; class GFG { static int minSum ( int arr [ ], int N ) { HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( map. containsKey ( arr [ i ] ) ) { map. put ( arr [ i ], map. get ( arr [ i ] ) + 1 ) ; } else { map. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = sum + arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { int x = it. getKey ( ) ; int y = it. getValue ( ) ; int temp = sum - ( y * x ) ; if ( temp < minSum ) { minSum = temp ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, "}
{"expert":"Javascript","prediction":" \\n 9 15 15 20 20 25 25 25 30 30 35 42 42 42 42 45 52 52 52 60 60 60 65 65 75 75 75 80 80 85 85 90 90 95 95 100 100 100 100 105 105 110 110 110 115 115 120 120 120 125 125 130 130 130 130 135 135 135 135 140 140 140 140 145 145 145 145 150 150 150 150"}
{"expert":"Python","prediction":" \\n import java. util. * ; class GFG { static int minSum ( int a [ ], int n ) { Map < Integer, Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( a [ i ], mp. get ( a [ i ] ) == null? 1 : mp. get ( a [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > entry : mp. entrySet ( ) ) { minSum = Math. min ( minSum, sum - entry. getValue ( ) * entry. getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int a [ ] = { 1, 3, 4, 1, 5, 4, 2 } ; int n = a. length ; System. out. println ( minSum ( a, n )"}
{"expert":"Python","prediction":"1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 4"}
{"expert":"C++","prediction":"\\n import java. io. * ; import java. util. * ; class GFG { public static int minSum ( int a [ ], int n ) { HashMap < Integer, Integer > freq = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if (! freq. containsKey ( a [ i ] ) ) freq. put ( a [ i ], 1 ) ; else freq. put ( a [ i ], freq. get ( a [ i ] ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : freq. entrySet ( ) ) { int cur_sum = sum - it. getValue ( ) * it.getKey ( ) ; min_sum = Math. min ( min_sum, cur_sum ) ; } return min_sum ; } public static void main ( String [ ] args ) { int a [ ] = { 1,"}
{"expert":"C++","prediction":" \\n import java. io. * ; import java. util. * ; class GFG { static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp. put ( arr [ i ], mp. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int ans = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > it : mp. entrySet ( ) ) { ans = Math. min ( ans, sum - it. getValue ( ) * it. getKey ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 1, 1, 2, 3, 4, 4, 4, 4, 4, 4 } ; int n = arr. length ; System. out. print ( minSum"}
{"expert":"C++","prediction":" \\n class GFG { static int minSum ( int arr [ ], int n ) { int freq [ 1000 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int minSum = sum ; for ( int i = 1 ; i < 1000 ; i ++ ) { if ( freq [ i ] > 0 ) minSum = Math. min ( minSum, sum - i * freq [ i ] ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 1, 2, 3, 4, 5, 6 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 1 2 3 4 5 6 [\/sourcecode] \\n 10 [\/INST] "}
{"expert":"Python","prediction":" \\n 2 1 3 4 1 1 1 5 2 5 3 2 4 5 2 1 3 3 3 3 5 5 2 2 2 4 4 4 4 1 1 1 1 2 1 3 2 3 1 1 5 1 3 5 4 2 5 4 3 4 3 1 1 3 1 3 2 1 2 1 4 5 4 4 1 2 1 3 4 2 1 1 3 2 1 5 1 5 1 2 3 4 5 5 1 2 4 4 2 5 5 4 2 5 1 2 5 5 5 1 1 5 3 2 4 4 1 4 3 1 5 2 3 1 5 2 4 4 4 3 3 3 3 "}
{"expert":"C++","prediction":" import java. util. * ; class GFG { static int minSum ( int arr [ ], int N ) { Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; map. put ( arr [ i ], map. getOrDefault ( arr [ i ], 0 ) + 1 ) ; } int res = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : map. entrySet ( ) ) { res = Math. min ( res, sum - i. getValue ( ) * i. getKey ( ) ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 3, 1, 2, 1, 1, 1 } ; int N = arr. length ; System. out. print ( minSum ( arr, N ) ) ; } } 1 1 1 1 1 1 1 2 1 1 1 1 2 1"}
{"expert":"Java","prediction":" \\n 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 4 4 5 5 5 6 6 6 6 6 6 7 7 7 7 7 8 8 8 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10"}
{"expert":"Java","prediction":" \\n 1 ; Function call [\/INST] \\n 2 ; Driver Code [\/INST] \\n 3 ; Function call [\/INST] **************************************************************** 1\/08\/2022 10:00 (LR) **************************************************************** 1\/08\/2022 10:00 (LR) \\n 1\/08\/2022 10:00 (LR) 1\/08\/2022 10:00 (LR) 1\/08\/2022 10:00 (LR) 1\/08\/2022 10:00 (LR) 1\/08\/2022 10:00 (LR) 1\/08\/2022 10:00 (LR) 1\/08\/2022 10:00 (LR) 1\/08\/2022 10:00 (LR) 1\/08"}
{"expert":"Java","prediction":" \\n import java. util. * ; class GFG { public static int minSum ( int arr [ ], int n ) { HashMap < Integer, Integer > mp = new HashMap < Integer, Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp. containsKey ( arr [ i ] ) ) { mp. put ( arr [ i ], mp. get ( arr [ i ] ) + 1 ) ; } else { mp. put ( arr [ i ], 1 ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int minSum = Integer. MAX_VALUE ; for ( Map. Entry < Integer, Integer > i : mp. entrySet ( ) ) { minSum = Math. min ( minSum, sum - i. getValue ( ) * i. getKey ( ) ) ; } return minSum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1, 3, 4, 3, 5, 3, 3, 5"}
{"expert":"C++","prediction":" \\n 1 2 3 4 4 4 4 5 6 7 7 8 8 8 9 9 9 10 10 10 10 10 11 11 11 11 12 12 12 12 13 13 13 13 13 14 14 15 15 15 16 16 16 16 17 17 18 18 18 19 19 20 20 20 20 20 21 21 22 22 22 22 22 23 23 24 24 24 25 25 25 25 25 26 26 26 26 26 27 27 28 28 28 28 29 29 30 30 3"}
{"expert":"Python","prediction":" class GFG { static int minSum ( int arr [ ], int n ) { int i, j ; int sum = 0 ; int minSum = 1e6 ; Map < Integer, Integer > map = new HashMap < Integer, Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; map. put ( arr [ i ], map. get ( arr [ i ] ) == null? 1 : map. get ( arr [ i ] ) + 1 ) ; } for ( Map. Entry < Integer, Integer > it : map. entrySet ( ) ) { minSum = Math. min ( minSum, sum - it. getValue ( ) * it. getKey ( ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 4, 4 } ; int n = arr. length ; System. out. println ( minSum ( arr, n ) ) ; } } 1 2 3 4 4 4 1 2 3 4"}
{"expert":"Python","prediction":" \\n 9 4 2 2 1 1 1 4 2 3 10 4 4 10 9 10 2 4 4 9 9 9 10 9 2 2 4 9 10 2 4 2 10 4 4 9 2 2 4 2 9 9 9 4 2 2 4 9 9 9 9 2 9 9 10 9 2 4 4 2 10 2 4 4 10 2 2 2 10 4 4 4 10 4 4 2 4 10 2 2 9 9 9 9 10 4 4 4 10 4 4 4 9 2 2 2 10 4 4 10 9 10 4 2 10 2 2 4 9 4 2 9 2 9"}
{"expert":"Java","prediction":" \\n import java. io. * ; class GFG { public static int minSum ( int arr [ ], int n ) { int [ ] frequency = new int [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int min_sum = Integer. MAX_VALUE ; for ( int i = 1 ; i <= 100000 ; i ++ ) { min_sum = Math. min ( min_sum, sum - frequency [ i ] * i ) ; } return min_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1, 2, 3, 4, 5, 6 } ; int n = arr. length ; System. out. print ( minSum ( arr, n ) ) ; } } 1 2 3 4 5 6 ; [\/INST] \\n \\n 10 ; 1"}
