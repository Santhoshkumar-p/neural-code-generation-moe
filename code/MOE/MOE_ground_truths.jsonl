{"expert":"Python","ground_truth":"import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num \/ a ) + ( num \/ b ) + ( num \/ c ) - ( num \/ ( ( a * b ) \/ gcd ( a , b ) ) ) - ( num \/ ( ( c * b ) \/ gcd ( c , b ) ) ) - ( num \/ ( ( a * c ) \/ gcd ( a , c ) ) ) + ( num \/ ( ( a * b * c ) \/ gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) \/ 2 ; NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE"}
{"expert":"Python","ground_truth":"MAX = 10 NEW_LINE def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N \/\/ 10 NEW_LINE DEDENT if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE return digit NEW_LINE DEDENT def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( B < len ( digit ) ) : NEW_LINE INDENT if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE DEDENT return dp [ B ] NEW_LINE DEDENT DEDENT A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; } let n = 4 ; document . write ( \" \" + calculateSum ( n ) ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used ) return 1 ; return 0 ; } if ( dp [ wt ] [ used ] != -1 ) return dp [ wt ] [ used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt ] [ used ] = ans ; } int main ( ) { int W = 3 , K = 3 , M = 2 ; int dp [ W + 1 ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << solve ( dp , W , K , M , 0 ) << endl ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; int func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ 100005 ] = { 0 } ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] ) { i = ( double ) i ; double j ; ll value = 0 ; double cur = ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = min ( maxx , ( int ) ( ceil ( i * j ) - 1.0 ) ) ; int times = ( freq [ i ] - freq [ i - 1 ] ) , con = j - 0.5 ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( ll ) ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; cout << func ( arr , n ) << endl ; return 0 ; }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int NthSmallest ( int K ) { Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . peek ( ) ; Q . remove ( ) ; if ( x % 10 != 0 ) { Q . add ( x * 10 + x % 10 - 1 ) ; } Q . add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . add ( x * 10 + x % 10 + 1 ) ; } } return x ; } public static void main ( String [ ] args ) { int N = 16 ; System . out . print ( NthSmallest ( N ) ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) \/ n ; double ang2 = ( 180 * y ) \/ n ; double ans = 180 - ang1 - ang2 ; return ans ; } int main ( ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; cout << calculate_angle ( n , a1 , a2 , a3 ) ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int l [ 1001 ] [ 1001 ] = { 0 } ; void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } int nCr ( int n , int r ) { return l [ n ] [ r ] ; } int main ( ) { initialize ( ) ; int n = 8 ; int r = 3 ; cout << nCr ( n , r ) ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int NthSmallest ( int K ) { queue < int > Q ; int x ; for ( int i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . front ( ) ; Q . pop ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; } int main ( ) { int N = 16 ; cout << NthSmallest ( N ) << \" STRNEWLINE \" ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include \" bits \/ stdc + + . h \" NEW_LINE using namespace std ; bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { cout << \" Yes STRNEWLINE \" ; } else { cout << \" No STRNEWLINE \" ; } } int main ( ) { int N = 8 ; checkSunnyNumber ( N ) ; return 0 ; }"}
{"expert":"Python","ground_truth":"def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N \/\/ 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N \/\/ 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N \/\/ 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N \/\/ 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( CountOnes ( N , L , R ) ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"let M = 100 ; function minAdjustmentCost ( A , n , target ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Number . MAX_VALUE ; let k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } let res = Number . MAX_VALUE ; for ( let j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } let arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] ; let n = arr . length ; let target = 10 ; document . write ( \" \" + minAdjustmentCost ( arr , n , target ) ) ;"}
{"expert":"Python","ground_truth":"def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"expert":"Java","ground_truth":"class GFG { static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) \/ n ; double ang2 = ( 180 * y ) \/ n ; double ans = 180 - ang1 - ang2 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }"}
{"expert":"Javascript","ground_truth":"var first , second ; function pair ( first , second ) { this . first = first ; this . second = second ; } function countSum ( arr , n ) { var result = 0 ; var count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { var temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; } var arr = [ 1 , 2 , 2 , 3 ] ; var n = arr . length ; var ans = countSum ( arr , n ) ; document . write ( \" \" + ans . first ) ; document . write ( \" \" + ans . second ) ;"}
{"expert":"Python","ground_truth":"from math import acos NEW_LINE def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 43 ; NEW_LINE printValueOfPi ( N ) ; NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"function printLines ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( k * ( 6 * i + 1 ) + \" \" + k * ( 6 * i + 2 ) + \" \" + k * ( 6 * i + 3 ) + \" \" + k * ( 6 * i + 5 ) + \" \" ) ; } } var n = 2 , k = 2 ; printLines ( n , k ) ;"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static void maxAdjacent ( int [ ] arr , int N ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = Integer . MIN_VALUE ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . add ( maxi ) ; } for ( int x : res ) { System . out . print ( x + \" \u2581 \" ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int arr [ ] , int n ) { int dp [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; cout << ways ( arr , n ) % mod << endl ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function convertToHex ( num ) { let temp = \" \" ; while ( num != 0 ) { let rem = num % 16 ; let c = 0 ; if ( rem < 10 ) { c = rem + 48 ; } else { c = rem + 87 ; } temp += String . fromCharCode ( c ) ; num = Math . floor ( num \/ 16 ) ; } return temp ; } function encryptString ( S , N ) { let ans = \" \" ; for ( let i = 0 ; i < N ; i ++ ) { let ch = S [ i ] ; let count = 0 ; let hex ; while ( i < N && S [ i ] == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans += ch ; ans += hex ; } ans = ans . split ( ' ' ) . reverse ( ) . join ( \" \" ) ; return ans ; } let S = \" \" ; let N = S . length ; document . write ( encryptString ( S , N ) ) ;"}
{"expert":"Javascript","ground_truth":"function maxAdjacent ( arr , N ) { var res = [ ] ; for ( var i = 1 ; i < N - 1 ; i ++ ) { var prev = arr [ 0 ] ; var maxi = Number . MIN_VALUE ; for ( var j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . push ( maxi ) ; } for ( var j = 0 ; j < res . length ; j ++ ) document . write ( res [ j ] + \" \" ) ; document . write ( \" \" ) ; } var arr = [ 1 , 3 , 4 , 7 , 8 ] ; var N = arr . length ; maxAdjacent ( arr , N ) ;"}
{"expert":"Python","ground_truth":"mod = 1000000007 NEW_LINE def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE DEDENT"}
{"expert":"Python","ground_truth":"def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) \/\/ 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) \/ 2 ; return count ; } public static void main ( String [ ] args ) { int L = 2 , R = 6 ; System . out . print ( totalCombination ( L , R ) ) ; } }"}
{"expert":"Java","ground_truth":"class GFG { static void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { System . out . println ( \"0\" ) ; return ; } if ( Xor == 0 ) { System . out . println ( \"1\" ) ; System . out . println ( Sum ) ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; System . out . print ( \"2\" ) ; System . out . println ( num1 + \" \u2581 \" + num2 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; insert_element ( a , n ) ; } }"}
{"expert":"Java","ground_truth":"class GFG { static boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void minDivisior ( int n ) { if ( prime ( n ) ) { System . out . print ( 1 + \" \u2581 \" + ( n - 1 ) ) ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { System . out . print ( n \/ i + \" \u2581 \" + ( n \/ i * ( i - 1 ) ) ) ; break ; } } } } public static void main ( String [ ] args ) { int N = 4 ; minDivisior ( N ) ; } }"}
{"expert":"Python","ground_truth":"def convertToHex ( num ) : NEW_LINE INDENT temp = \" \" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num \/\/ 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT def encryptString ( S , N ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE while ( i < N and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE hex = convertToHex ( count ) NEW_LINE ans += ch NEW_LINE ans += hex NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abc \" NEW_LINE N = len ( S ) NEW_LINE print ( encryptString ( S , N ) ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"let MAXN = 1000001 ; let spf = new Array ( MAXN ) ; let hash1 = new Array ( MAXN ) ; function sieve ( ) { spf [ 1 ] = 1 ; for ( let i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( let i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( let i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( let j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } function getFactorization ( x ) { let temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x \/ spf [ x ] ; } while ( x % temp == 0 ) x = x \/ temp ; } } function check ( x ) { let temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x \/ temp ; } return true ; } function hasValidNum ( arr , n ) { sieve ( ) ; for ( let i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } let arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] ; let n = arr . length ; if ( hasValidNum ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"expert":"Python","ground_truth":"import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT"}
{"expert":"Python","ground_truth":"def check ( s , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT str = \" aanncddc \" ; NEW_LINE n = len ( str ) NEW_LINE if ( check ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"function findSize ( N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; let Size = 2 * findSize ( parseInt ( N \/ 2 , 10 ) ) + 1 ; return Size ; } function CountOnes ( N , L , R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } let ret = 0 ; let M = parseInt ( N \/ 2 , 10 ) ; let Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( parseInt ( N \/ 2 , 10 ) , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( parseInt ( N \/ 2 , 10 ) , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } let N = 7 , L = 2 , R = 5 ; document . write ( CountOnes ( N , L , R ) ) ;"}
{"expert":"Python","ground_truth":"def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s \/\/ 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } }"}
{"expert":"Javascript","ground_truth":"function minAbsDiff ( n ) { let mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; } let n = 5 ; document . write ( minAbsDiff ( n ) ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int k = 4 ; if ( checkArray ( n , k , arr ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"expert":"Java","ground_truth":"class GFG { static void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; } }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static boolean check ( String s , int n ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . isEmpty ( ) && st . peek ( ) == s . charAt ( i ) ) st . pop ( ) ; else st . add ( s . charAt ( i ) ) ; } if ( st . isEmpty ( ) ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { String str = \" aanncddc \" ; int n = str . length ( ) ; if ( check ( str , n ) ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } } }"}
{"expert":"Javascript","ground_truth":"let MAX = 1000000 ; let MOD = 10000007 ; let result = new Array ( MAX + 1 ) ; result . fill ( 0 ) ; let fact = new Array ( MAX + 1 ) ; fact . fill ( 0 ) ; function preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( let i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } function performQueries ( q , n ) { preCompute ( ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( result [ q [ i ] ] + \" \" ) ; } let q = [ 4 , 5 ] ; let n = q . length ; performQueries ( q , n ) ;"}
{"expert":"Python","ground_truth":"def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) \/ 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) \/\/ 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair countSum ( int arr [ ] , int n ) { int result = 0 ; int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; pair ans = countSum ( arr , n ) ; System . out . print ( \" EvenSum \u2581 = \u2581 \" + ans . first ) ; System . out . print ( \" \u2581 OddSum \u2581 = \u2581 \" + ans . second ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) ) && ( B & ( 1 << i ) ) ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << \" \u2581 \" << B ; } int main ( ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; #define M  100 NEW_LINE int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } int main ( ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int target = 10 ; cout << \" Minimum \u2581 adjustment \u2581 cost \u2581 is \u2581 \" << minAdjustmentCost ( arr , n , target ) << endl ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } int main ( ) { int n = 3 , m = 2 ; cout << \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" << countPaths ( n , m ) ; return 0 ; }"}
{"expert":"Python","ground_truth":"def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n \/\/ i , n \/\/ i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 4 NEW_LINE minDivisior ( N ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) \/ 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; } let N = 4 ; document . write ( countWays ( N ) ) ;"}
{"expert":"Python","ground_truth":"def insert_element ( a , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE print ( 2 ) NEW_LINE print ( num1 , num2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"function calculate_angle ( n , i , j , k ) { var x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; var ang1 = ( 180 * x ) \/ n ; var ang2 = ( 180 * y ) \/ n ; var ans = 180 - ang1 - ang2 ; return ans ; } var n = 5 ; var a1 = 1 ; var a2 = 2 ; var a3 = 5 ; document . write ( parseInt ( calculate_angle ( n , a1 , a2 , a3 ) ) ) ;"}
{"expert":"Java","ground_truth":"class GFG { static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) \/ 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) \/ 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( partitions ( N ) ) ; } }"}
{"expert":"Javascript","ground_truth":"function NthSmallest ( K ) { var Q = [ ] ; var x ; for ( var i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( var i = 1 ; i <= K ; i ++ ) { x = Q [ 0 ] ; Q . shift ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; } var N = 16 ; document . write ( NthSmallest ( N ) ) ;"}
{"expert":"Java","ground_truth":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + \" \u2581 \" + k * ( 6 * i + 2 ) + \" \u2581 \" + k * ( 6 * i + 3 ) + \" \u2581 \" + k * ( 6 * i + 5 ) ) ; } } public static void main ( String args [ ] ) { int n = 2 , k = 2 ; printLines ( n , k ) ; } }"}
{"expert":"Java","ground_truth":"class GfG { static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) \/ 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } int main ( ) { int gold [ MAX ] [ MAX ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; cout << getMaxGold ( gold , m , n ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"let mod = 1000000000 ; function ways ( i , arr , n ) { if ( i == n - 1 ) return 1 ; let sum = 0 ; for ( let j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } let arr = [ 5 , 3 , 1 , 4 , 3 ] ; let n = arr . length ; document . write ( ways ( 0 , arr , n ) ) ;"}
{"expert":"Python","ground_truth":"def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; bool check ( string s , int n ) { stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . empty ( ) && st . top ( ) == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . empty ( ) ) { return true ; } else { return false ; } } int main ( ) { string str = \" aanncddc \" ; int n = str . length ( ) ; if ( check ( str , n ) ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } void minDivisior ( int n ) { if ( prime ( n ) ) { cout << 1 << \" \u2581 \" << n - 1 ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { cout << n \/ i << \" \u2581 \" << n \/ i * ( i - 1 ) ; break ; } } } } int main ( ) { int N = 4 ; minDivisior ( N ) ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; cout << ways ( 0 , arr , n ) << endl ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function decBinary ( arr , n ) { let k = parseInt ( Math . log2 ( n ) , 10 ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n = parseInt ( n \/ 2 , 10 ) ; } } function binaryDec ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } function getNum ( n , k ) { let l = parseInt ( Math . log2 ( n ) , 10 ) + 1 ; let a = new Array ( l ) ; a . fill ( 0 ) ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } let n = 56 , k = 2 ; document . write ( getNum ( n , k ) ) ;"}
{"expert":"C++","ground_truth":"#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int countSubstrings ( string & str ) { int freq [ 3 ] = { 0 } ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; } int main ( ) { string str = \"00021\" ; int count = countSubstrings ( str ) ; cout << count ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"let MAX = 100 ; function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { goldTable [ i ] [ j ] = 0 ; } } for ( let col = n - 1 ; col >= 0 ; col -- ) { for ( let row = 0 ; row < m ; row ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } let gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] ; let m = 4 , n = 4 ; document . write ( getMaxGold ( gold , m , n ) ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; #define MAX  10 NEW_LINE vector < int > numToVec ( int N ) { vector < int > digit ; while ( N != 0 ) { digit . push_back ( N % 10 ) ; N = N \/ 10 ; } if ( digit . size ( ) == 0 ) digit . push_back ( 0 ) ; reverse ( digit . begin ( ) , digit . end ( ) ) ; return digit ; } int solve ( vector < int > & A , int B , int C ) { vector < int > digit ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A [ 0 ] == 0 && B != 1 ) return ( d - 1 ) * pow ( d , B - 1 ) ; else return pow ( d , B ) ; } else { int dp [ B + 1 ] = { 0 } ; int lower [ MAX + 1 ] = { 0 } ; for ( int i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; bool flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } } int main ( ) { vector < int > A = { 0 , 1 , 2 , 5 } ; int N = 2 ; int k = 21 ; cout << solve ( A , N , k ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function insert_element ( a , n ) { let Xor = 0 ; let Sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { document . write ( \" \" + \" \" ) ; return ; } if ( Xor == 0 ) { document . write ( \" \" + \" \" ) ; document . write ( Sum + \" \" ) ; return ; } let num1 = Sum + Xor ; let num2 = Xor ; document . write ( \" \" + \" \" ) ; document . write ( num1 + \" \" + num2 + \" \" ) ; } let a = [ 1 , 2 , 3 ] ; let n = a . length ; insert_element ( a , n ) ;"}
{"expert":"Java","ground_truth":"class GFG { static void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + \" \u2581 \" ) ; System . out . print ( N - K + 1 ) ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; } }"}
{"expert":"Python","ground_truth":"def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE DEDENT if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = \" : \" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( \"0\" , hh , end = \" : \" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( \"0\" , mm ) NEW_LINE DEDENT DEDENT def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i \/\/ 10 NEW_LINE if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j \/\/ 10 NEW_LINE if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT timeValue = \" ? ? : ? ? \" NEW_LINE L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int minSum ( int A [ ] , int N ) { map < int , int > mp ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; } int minSum = INT_MAX ; for ( auto it : mp ) { minSum = min ( minSum , sum - ( it . first * it . second ) ) ; } return minSum ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , N ) << \" STRNEWLINE \" ; }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } System . out . print ( A + \" \u2581 \" + B ) ; } public static void main ( String [ ] args ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; } }"}
{"expert":"Java","ground_truth":"class GFG { static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n \/= 2 ; } } static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int getNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } public static void main ( String [ ] args ) { int n = 56 ; int k = 2 ; System . out . println ( getNum ( n , k ) ) ; } }"}
{"expert":"Python","ground_truth":"def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT"}
{"expert":"Python","ground_truth":"def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT DEDENT return ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum \u2581 = \u2581 \" , count_even , \" \u2581 OddSum \u2581 = \u2581 \" , count_odd ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"let mod = ( 1e9 + 7 ) ; function ways ( arr , n ) { let dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( let j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } let arr = [ 5 , 3 , 1 , 4 , 3 ] ; let n = arr . length ; document . write ( ways ( arr , n ) % mod ) ;"}
{"expert":"Python","ground_truth":"M = 100 NEW_LINE def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( \" Minimum \u2581 adjustment \u2581 cost \u2581 is \" , minAdjustmentCost ( arr , n , target ) , sep = ' \u2581 ' ) NEW_LINE"}
{"expert":"Java","ground_truth":"class GFG { static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s \/ 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; } public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( \"YesNEW_LINE\"); else System . out . println ( \"NoNEW_LINE\"); } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) return 0 ; return 1 ; } int main ( ) { int n = 5 ; cout << minAbsDiff ( n ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function minSum ( A , N ) { let mp = new Map ( ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; if ( mp . has ( A [ i ] ) ) { mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) } else { mp . set ( A [ i ] , 1 ) } } let minSum = Number . MAX_SAFE_INTEGER ; for ( let it of mp ) { minSum = Math . min ( minSum , sum - ( it [ 0 ] * it [ 1 ] ) ) ; } return minSum ; } let arr = [ 4 , 5 , 6 , 6 ] ; let N = arr . length document . write ( minSum ( arr , N ) + \" \" ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } int main ( ) { int n = 14 ; cout << nearest ( n ) << endl ; n = 16 ; cout << nearest ( n ) << endl ; n = 18 ; cout << nearest ( n ) << endl ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; long long partitions ( int n ) { vector < long long > p ( n + 1 , 0 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) \/ 2 <= i ) { p [ i ] += ( k % 2 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) \/ 2 ] ; if ( k > 0 ) k *= -1 ; else k = 1 - k ; } } return p [ n ] ; } int main ( ) { int N = 20 ; cout << partitions ( N ) ; return 0 ; }"}
{"expert":"Java","ground_truth":"class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ; static int ways ( int arr [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( arr , n ) % mod ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int minFlips ( string str ) { int count = 0 ; if ( str . size ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . size ( ) - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } int main ( ) { string S = \"0011101\" ; cout << minFlips ( S ) ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE #define MAX  10 NEW_LINE using namespace std ; int LIP ( int dp [ ] [ MAX ] , int mat [ ] [ MAX ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } int wrapper ( int mat [ ] [ MAX ] , int n , int m ) { int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; cout << wrapper ( mat , n , m ) << endl ; return 0 ; }"}
{"expert":"Python","ground_truth":"def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) \/\/ n NEW_LINE ang2 = ( 180 * y ) \/\/ n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int calculateSum ( int n ) { return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( \" Sum \u2581 = \u2581 \" + calculateSum ( n ) ) ; } }"}
{"expert":"Javascript","ground_truth":"function minFlips ( str ) { let count = 0 ; if ( str . length <= 2 ) { return 0 ; } for ( let i = 0 ; i < str . length - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } let S = \" \" ; document . write ( minFlips ( S ) ) ;"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { public static int countSubstrings ( String str ) { int [ ] freq = new int [ 3 ] ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str . charAt ( j ) - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charAt ( i ++ ) - '0' ] -- ; } count += i ; } return count ; } public static void main ( String [ ] args ) { String str = \"00021\" ; System . out . println ( countSubstrings ( str ) ) ; } }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int LIP ( int dp [ ] [ ] , int mat [ ] [ ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } static int wrapper ( int mat [ ] [ ] , int n , int m ) { int dp [ ] [ ] = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; System . out . println ( wrapper ( mat , n , m ) ) ; } }"}
{"expert":"Python","ground_truth":"def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"let l = new Array ( 1001 ) . fill ( 0 ) . map ( ( ) => new Array ( 1001 ) . fill ( 0 ) ) ; function initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( let j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } function nCr ( n , r ) { return l [ n ] [ r ] ; } initialize ( ) ; let n = 8 ; let r = 3 ; document . write ( nCr ( n , r ) ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) \/ 2 ; return count ; } int main ( ) { int L = 2 , R = 6 ; cout << totalCombination ( L , R ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function printKNumbers ( N , K ) { for ( let i = 0 ; i < K - 1 ; i ++ ) document . write ( 1 + \" \" ) ; document . write ( N - K + 1 ) ; } let N = 10 , K = 3 ; printKNumbers ( N , K ) ;"}
{"expert":"Javascript","ground_truth":"function countValues ( n ) { let answer = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { let k = n ; while ( k >= i ) { if ( k % i == 0 ) k \/= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } let N = 6 ; document . write ( countValues ( N ) ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function partitions ( n ) { var p = Array ( n + 1 ) . fill ( 0 ) ; p [ 0 ] = 1 ; for ( i = 1 ; i <= n ; ++ i ) { var k = 1 ; while ( ( k * ( 3 * k - 1 ) ) \/ 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) \/ 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } var N = 20 ; document . write ( partitions ( N ) ) ;"}
{"expert":"Javascript","ground_truth":"function countPaths ( n , m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } let n = 3 , m = 2 ; document . write ( \" \" + countPaths ( n , m ) ) ;"}
{"expert":"Java","ground_truth":"class GFG { static boolean checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = arr . length ; int k = 4 ; if ( checkArray ( n , k , arr ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"expert":"Javascript","ground_truth":"function isPrime ( n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function checkExpression ( n ) { if ( isPrime ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let N = 3 ; checkExpression ( N ) ;"}
{"expert":"Javascript","ground_truth":"function isPerfectSquare ( x ) { var sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } function checkSunnyNumber ( N ) { if ( isPerfectSquare ( N + 1 ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var N = 8 ; checkSunnyNumber ( N ) ;"}
{"expert":"Java","ground_truth":"import java . io . * ; class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ; static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } static void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; } public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }"}
{"expert":"Java","ground_truth":"class GFG { static String removeCharRecursive ( String str , char X ) { if ( str . length ( ) == 0 ) { return \" \" ; } if ( str . charAt ( 0 ) == X ) { return removeCharRecursive ( str . substring ( 1 ) , X ) ; } return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; } public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; System . out . println ( str ) ; } }"}
{"expert":"Python","ground_truth":"l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; string convertToHex ( int num ) { string temp = \" \" ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = rem + 48 ; } else { c = rem + 87 ; } temp += c ; num = num \/ 16 ; } return temp ; } string encryptString ( string S , int N ) { string ans = \" \" ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S [ i ] ; int count = 0 ; string hex ; while ( i < N && S [ i ] == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans += ch ; ans += hex ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; return ans ; } int main ( ) { string S = \" abc \" ; int N = S . size ( ) ; cout << encryptString ( S , N ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; } function countOfString ( N ) { let Stotal = Math . pow ( 2 , N ) ; let Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N \/ 2 ) ; let S1 = ( Stotal - Sequal ) \/ 2 ; return S1 ; } let N = 3 ; document . write ( countOfString ( N ) ) ;"}
{"expert":"Python","ground_truth":"mod = 10 ** 9 + 7 NEW_LINE def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE"}
{"expert":"Python","ground_truth":"def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( ' inf ' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE"}
{"expert":"Java","ground_truth":"class GFG { static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) \/ ( 100 * 100 - P * P ) ; System . out . println ( \" Loss \u2581 = \u2581 \" + loss ) ; } public static void main ( String [ ] args ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } void checkExpression ( int n ) { if ( isPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int N = 3 ; checkExpression ( N ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function LIP ( dp , mat , n , m , x , y ) { if ( dp [ x ] [ y ] < 0 ) { let result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } function wrapper ( mat , n , m ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( 10 ) ; for ( let j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return LIP ( dp , mat , n , m , 0 , 0 ) ; } let mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] , ] ; let n = 4 , m = 4 ; document . write ( wrapper ( mat , n , m ) ) ;"}
{"expert":"Python","ground_truth":"def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE"}
{"expert":"Javascript","ground_truth":"function totalCombination ( L , R ) { let count = 0 ; let K = R - L ; if ( K < L ) return 0 ; let ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) \/ 2 ; return count ; } let L = 2 , R = 6 ; document . write ( totalCombination ( L , R ) ) ;"}
{"expert":"Python","ground_truth":"def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"var Landau = - 1000000000 ; function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function lcm ( a , b ) { return ( a * b ) \/ gcd ( a , b ) ; } function findLCM ( arr ) { var nth_lcm = arr [ 0 ] ; for ( var i = 1 ; i < arr . length ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = Math . max ( Landau , nth_lcm ) ; } function findWays ( arr , i , n ) { if ( n == 0 ) findLCM ( arr ) ; for ( var j = i ; j <= n ; j ++ ) { arr . push ( j ) ; findWays ( arr , j , n - j ) ; arr . pop ( ) ; } } function Landau_function ( n ) { arr = [ ] ; findWays ( arr , 1 , n ) ; document . write ( Landau ) ; } var N = 4 ; Landau_function ( N ) ;"}
{"expert":"Python","ground_truth":"def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE maxi = - 1 * float ( ' inf ' ) NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE prev = arr [ j ] NEW_LINE DEDENT res . append ( maxi ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"let MAX = 10 ; function numToVec ( N ) { let digit = [ ] ; while ( N != 0 ) { digit . push ( N % 10 ) ; N = Math . floor ( N \/ 10 ) ; } if ( digit . length == 0 ) digit . push ( 0 ) ; digit . reverse ( ) ; return digit ; } function solve ( A , B , C ) { let digit = [ ] ; let d , d2 ; digit = numToVec ( C ) ; d = A . length ; if ( B > digit . length d == 0 ) return 0 ; else if ( B < digit . length ) { if ( A [ 0 ] == 0 && B != 1 ) return Math . floor ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return Math . floor ( Math . pow ( d , B ) ) ; } else { let dp = new Array ( B + 1 ) ; let lower = new Array ( MAX + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < lower . length ; i ++ ) { lower [ i ] = 0 ; } for ( let i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( let i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; let flag = true ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } } let arr = [ 0 , 1 , 2 , 5 ] ; let N = 2 ; let k = 21 ; document . write ( solve ( arr , N , k ) ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n \/= 2 ; } } int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int getNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } int main ( ) { int n = 56 , k = 2 ; cout << getNum ( n , k ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function Loss ( SP , P ) { var loss = 0 ; loss = ( 2 * P * P * SP ) \/ ( 100 * 100 - P * P ) ; document . write ( \" \" + loss . toFixed ( 3 ) ) ; } var SP = 2400 , P = 30 ; Loss ( SP , P ) ;"}
{"expert":"Python","ground_truth":"MAX = 100 NEW_LINE def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"var mod = 1000000007 ; function count_special ( n ) { var fib = [ ... Array ( n + 1 ) ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( var i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( ( fib [ i - 1 ] % mod ) + ( fib [ i - 2 ] % mod ) ) % mod ; } return fib [ n ] ; } var n = 3 ; document . write ( count_special ( n ) + \" \" ) ;"}
{"expert":"Java","ground_truth":"class GFG { static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } static int nCr ( int n , int r ) { return l [ n ] [ r ] ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 8 ; int r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static final int mod = 1000000007 ; static int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( count_special ( n ) + \"NEW_LINE\"); } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << \" \u2581 \" ; cout << ( N - K + 1 ) ; } int main ( ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; return 0 ; }"}
{"expert":"Python","ground_truth":"def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k \/\/= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"function func ( arr , n ) { let ans = 0 ; let maxx = 0 ; let freq = Array . from ( { length : 100005 } , ( _ , i ) => 0 ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( let i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( let i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { let j ; let cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { let val = Math . min ( maxx , ( Math . ceil ( i * j ) - 1.0 ) ) ; let times = ( freq [ i ] - freq [ i - 1 ] ) , con = ( j - 0.5 ) ; ans += times * con * ( freq [ val ] - freq [ cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ans ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; document . write ( func ( arr , n ) ) ;"}
{"expert":"Python","ground_truth":"def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"class GFG { static int MAXN = 1000001 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] hash1 = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x \/ spf [ x ] ; } while ( x % temp == 0 ) x = x \/ temp ; } } static boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x \/ temp ; } return true ; } static boolean hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int countWays ( int N ) { int E = ( N * ( N - 1 ) ) \/ 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; } int main ( ) { int N = 4 ; cout << countWays ( N ) ; return 0 ; }"}
{"expert":"Java","ground_truth":"import java . io . * ; class GFG { static int minFlips ( String str ) { int count = 0 ; if ( str . length ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . length ( ) - 2 { if ( str . charAt ( i ) == str . charAt ( i + 1 ) && str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { String S = \"0011101\" ; System . out . println ( minFlips ( S ) ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k \/= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function checkSolution ( a , b , c ) { if ( a == c ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ;"}
{"expert":"Java","ground_truth":"import java . util . Arrays ; class GFG { static final int MAX = 100 ; static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } public static void main ( String arg [ ] ) { int gold [ ] [ ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; System . out . print ( getMaxGold ( gold , m , n ) ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; pair < int , int > countSum ( int arr [ ] , int n ) { int result = 0 ; int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return { count_even , count_odd } ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; pair < int , int > ans = countSum ( arr , n ) ; cout << \" EvenSum \u2581 = \u2581 \" << ans . first ; cout << \" \u2581 OddSum \u2581 = \u2581 \" << ans . second ; return 0 ; }"}
{"expert":"Python","ground_truth":"MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"function countSubstrings ( str ) { let freq = new Array ( 3 ) . fill ( 0 ) let count = 0 ; let i = 0 ; for ( let j = 0 ; j < str . length ; j ++ ) { freq [ str . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charCodeAt ( i ++ ) - ' ' . charCodeAt ( 0 ) ] -- ; } count += i ; } return count ; } let str = \" \" ; let count = countSubstrings ( str ) ; document . write ( count ) ;"}
{"expert":"Java","ground_truth":"class GFG { static long func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ ] = new double [ 100005 ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ; double cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . min ( maxx , ( int ) ( Math . ceil ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( long ) ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( func ( arr , n ) + \"NEW_LINE\"); } }"}
{"expert":"Python","ground_truth":"def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countOfString ( N ) : NEW_LINE INDENT Stotal = pow ( 2 , N ) NEW_LINE Sequal = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N \/\/ 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) \/\/ 2 NEW_LINE return S1 NEW_LINE DEDENT N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"function removeCharRecursive ( str , X ) { if ( str . length == 0 ) { return \" \" ; } if ( str . charAt ( 0 ) == X ) { return removeCharRecursive ( str . substring ( 1 ) , X ) ; } return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; } var str = \" \" ; var X = ' ' ; str = removeCharRecursive ( str , X ) ; document . write ( str ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void printArrays ( int n ) { vector < int > A , B ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . push_back ( i ) ; else B . push_back ( i ) ; } cout << \" { \u2581 \" ; for ( int i = 0 ; i < n ; i ++ ) { cout << A [ i ] ; if ( i != n - 1 ) cout << \" , \u2581 \" ; } cout << \" \u2581 } STRNEWLINE \" ; cout << \" { \u2581 \" ; for ( int i = 0 ; i < n ; i ++ ) { cout << B [ i ] ; if ( i != n - 1 ) cout << \" , \u2581 \" ; } cout << \" \u2581 } \" ; } int main ( ) { int N = 5 ; printArrays ( N ) ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAX  1000000 NEW_LINE const ll MOD = 1e9 + 7 ; ll result [ MAX + 1 ] ; ll fact [ MAX + 1 ] ; void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) cout << result [ q [ i ] ] << \" STRNEWLINE \" ; } int main ( ) { int q [ ] = { 4 , 5 } ; int n = sizeof ( q ) \/ sizeof ( q [ 0 ] ) ; performQueries ( q , n ) ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { cout << k * ( 6 * i + 1 ) << \" \u2581 \" << k * ( 6 * i + 2 ) << \" \u2581 \" << k * ( 6 * i + 3 ) << \" \u2581 \" << k * ( 6 * i + 5 ) << endl ; } } int main ( ) { int n = 2 , k = 2 ; printLines ( n , k ) ; return 0 ; }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static boolean isValid ( char a1 , char a2 , String str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str . charAt ( 4 ) ; v2 = str . charAt ( 3 ) ; } else { v1 = str . charAt ( 1 ) ; v2 = str . charAt ( 0 ) ; } if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; } static boolean inRange ( int hh , int mm , int L , int R ) { int a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } static void displayTime ( int hh , int mm ) { if ( hh > 10 ) System . out . print ( hh + \" : \" ) ; else if ( hh < 10 ) System . out . print ( \"0\" + hh + \" : \" ) ; if ( mm > 10 ) System . out . println ( mm ) ; else if ( mm < 10 ) System . out . println ( \"0\" + mm ) ; } static void maximumTimeWithDifferenceInRange ( String str , int L , int R ) { int i = 0 , j = 0 ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i \/ 10 ; if ( ! isValid ( ( char ) h1 , ( char ) h2 , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j \/ 10 ; if ( ! isValid ( ( char ) m1 , ( char ) m2 , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else System . out . println ( \" - 1\" ) ; } public static void main ( String [ ] args ) { String timeValue = \" ? ? : ? ? \" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; } }"}
{"expert":"Python","ground_truth":"def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT count += i NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"00021\" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE"}
{"expert":"Java","ground_truth":"import java . io . * ; import java . util . * ; class GFG { static int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k \/= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } public static void main ( String args [ ] ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } long divTermCount ( long a , long b , long c , long num ) { return ( ( num \/ a ) + ( num \/ b ) + ( num \/ c ) - ( num \/ ( ( a * b ) \/ gcd ( a , b ) ) ) - ( num \/ ( ( c * b ) \/ gcd ( c , b ) ) ) - ( num \/ ( ( a * c ) \/ gcd ( a , c ) ) ) + ( num \/ ( ( ( ( a * b ) \/ gcd ( a , b ) ) * c ) \/ gcd ( ( ( a * b ) \/ gcd ( a , b ) ) , c ) ) ) ) ; } int findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = LONG_MAX , mid ; while ( low < high ) { mid = low + ( high - low ) \/ 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { long a = 2 , b = 3 , c = 5 , n = 100 ; cout << findNthTerm ( a , b , c , n ) ; return 0 ; }"}
{"expert":"Java","ground_truth":"import java . io . * ; import java . util . * ; class GFG { public static int M = 100 ; static int minAdjustmentCost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = arr . length ; int target = 10 ; System . out . println ( \" Minimum \u2581 adjustment \u2581 cost \u2581 is \u2581 \" + minAdjustmentCost ( arr , n , target ) ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned long int n , unsigned long int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; } unsigned long int countOfString ( int N ) { unsigned long int Stotal = pow ( 2 , N ) ; unsigned long int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N \/ 2 ) ; unsigned long int S1 = ( Stotal - Sequal ) \/ 2 ; return S1 ; } int main ( ) { int N = 3 ; cout << countOfString ( N ) ; return 0 ; }"}
{"expert":"Python","ground_truth":"def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) \/ ( 100 * 100 - P * P ) ) NEW_LINE print ( \" Loss \u2581 = \" , round ( loss , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT"}
{"expert":"Python","ground_truth":"mod = 1e9 + 7 ; NEW_LINE def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT"}
{"expert":"Python","ground_truth":"def minFlips ( st ) : NEW_LINE INDENT count = 0 NEW_LINE if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( st ) - 2 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"0011101\" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; } static int countOfString ( int N ) { int Stotal = ( int ) Math . pow ( 2 , N ) ; int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N \/ 2 ) ; int S1 = ( Stotal - Sequal ) \/ 2 ; return S1 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( countOfString ( N ) ) ; } }"}
{"expert":"Javascript","ground_truth":"function flipBitsOfAandB ( A , B ) { for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } document . write ( A + \" \" + B ) ; } var A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ;"}
{"expert":"Java","ground_truth":"import java . io . * ; class GFG { static int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" + countPaths ( n , m ) ) ; } }"}
{"expert":"Python","ground_truth":"MAX = 20 NEW_LINE def LIP ( dp , mat , n , m , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE DEDENT return dp [ x ] [ y ] NEW_LINE DEDENT def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE"}
{"expert":"Python","ground_truth":"def removeCharRecursive ( str , X ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT if ( str [ 0 ] == X ) : NEW_LINE INDENT return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE X = ' e ' NEW_LINE str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE"}
{"expert":"Python","ground_truth":"from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE checkSunnyNumber ( N ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } public static void main ( String [ ] args ) { int N = 8 ; checkSunnyNumber ( N ) ; } }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int Landau = Integer . MIN_VALUE ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) \/ gcd ( a , b ) ; } static void findLCM ( Vector < Integer > arr ) { int nth_lcm = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr . get ( i ) ) ; Landau = Math . max ( Landau , nth_lcm ) ; } static void findWays ( Vector < Integer > arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } } static void Landau_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ; findWays ( arr , 1 , n ) ; System . out . print ( Landau ) ; } public static void main ( String [ ] args ) { int N = 4 ; Landau_function ( N ) ; } }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int MAX = 10 ; static Vector < Integer > numToVec ( int N ) { Vector < Integer > digit = new Vector < Integer > ( ) ; while ( N != 0 ) { digit . add ( N % 10 ) ; N = N \/ 10 ; } if ( digit . size ( ) == 0 ) digit . add ( 0 ) ; Collections . reverse ( digit ) ; return digit ; } static int solve ( Vector < Integer > A , int B , int C ) { Vector < Integer > digit = new Vector < Integer > ( ) ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A . get ( 0 ) == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return ( int ) Math . pow ( d , B ) ; } else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) lower [ A . get ( i ) + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit . get ( i - 1 ) ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A . get ( 0 ) == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit . get ( i - 1 ) + 1 ] == lower [ digit . get ( i - 1 ) ] + 1 ) ) ; } return dp [ B ] ; } } public static void main ( String [ ] args ) { Integer arr [ ] = { 0 , 1 , 2 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int N = 2 ; int k = 21 ; System . out . println ( solve ( A , N , k ) ) ; } }"}
{"expert":"Java","ground_truth":"class GFG { public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; } public static void main ( String [ ] args ) { int W = 3 , K = 3 , M = 2 ; int [ ] [ ] dp = new int [ W + 1 ] [ 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( solve ( dp , W , K , M , 0 ) + \"NEW_LINE\"); } }"}
{"expert":"Javascript","ground_truth":"function printValueOfPi ( N ) { let pi = 2 * Math . acos ( 0.0 ) ; document . write ( pi . toFixed ( 4 ) ) ; } let N = 4 ; printValueOfPi ( N ) ;"}
{"expert":"Python","ground_truth":"from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; bool check ( int s ) { int freq [ 10 ] = { 0 } , r ; while ( s != 0 ) { r = s % 10 ; s = int ( s \/ 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } } int main ( ) { int s = 122233 ; if ( check ( s ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; }"}
{"expert":"C++","ground_truth":"#include <iostream> NEW_LINE using namespace std ; void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }"}
{"expert":"Java","ground_truth":"class GFG { static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } }"}
{"expert":"Java","ground_truth":"class GFG { static int nearest ( int n ) { int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( nearest ( n ) ) ; n = 16 ; System . out . println ( nearest ( n ) ) ; n = 18 ; System . out . println ( nearest ( n ) ) ; } }"}
{"expert":"Javascript","ground_truth":"function prime ( n ) { if ( n == 1 ) return false ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function minDivisior ( n ) { if ( prime ( n ) ) { document . write ( 1 + \" \" + ( n - 1 ) ) ; } else { for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { document . write ( n \/ i + \" \" + ( n \/ i * ( i - 1 ) ) ) ; break ; } } } } var N = 4 ; minDivisior ( N ) ;"}
{"expert":"Javascript","ground_truth":"function solve ( dp , wt , K , M , used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } let ans = 0 ; for ( let i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; } let W = 3 , K = 3 , M = 2 ; let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( solve ( dp , W , K , M , 0 ) + \" \" ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE long count_special ( long n ) { long fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } int main ( ) { long n = 3 ; cout << count_special ( n ) << endl ; return 0 ; }"}
{"expert":"Java","ground_truth":"import java . awt . * ; import java . util . * ; class GFG { static String convertToHex ( int num ) { StringBuilder temp = new StringBuilder ( ) ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp . append ( c ) ; num = num \/ 16 ; } return temp . toString ( ) ; } static String encryptString ( String S , int N ) { StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S . charAt ( i ) ; int count = 0 ; String hex ; while ( i < N && S . charAt ( i ) == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans . append ( ch ) ; ans . append ( hex ) ; } ans . reverse ( ) ; return ans . toString ( ) ; } public static void main ( String [ ] args ) { String S = \" abc \" ; int N = S . length ( ) ; System . out . println ( encryptString ( S , N ) ) ; } }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) \/ float ( 100 * 100 - P * P ) ; cout << \" Loss \u2581 = \u2581 \" << loss ; } int main ( ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; return 0 ; }"}
{"expert":"Python","ground_truth":"import sys NEW_LINE Landau = - sys . maxsize - 1 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/\/ gcd ( a , b ) NEW_LINE DEDENT def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT N = 4 NEW_LINE Landau_function ( N ) NEW_LINE"}
{"expert":"Javascript","ground_truth":"function check ( s , n ) { var st = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( st . length != 0 && st [ st . length - 1 ] == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . length == 0 ) { return true ; } else { return false ; } } var str = \" \" ; var n = str . length ; if ( check ( str , n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { cout << \"0\" << endl ; return ; } if ( Xor == 0 ) { cout << \"1\" << endl ; cout << Sum << endl ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; cout << \"2\" ; cout << num1 << \" \u2581 \" << num2 << endl ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) \/ sizeof ( a [ 0 ] ) ; insert_element ( a , n ) ; }"}
{"expert":"Javascript","ground_truth":"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function divTermCount ( a , b , c , num ) { return parseInt ( ( ( num \/ a ) + ( num \/ b ) + ( num \/ c ) - ( num \/ ( ( a * b ) \/ gcd ( a , b ) ) ) - ( num \/ ( ( c * b ) \/ gcd ( c , b ) ) ) - ( num \/ ( ( a * c ) \/ gcd ( a , c ) ) ) + ( num \/ ( ( ( ( a * b ) \/ gcd ( a , b ) ) * c ) \/ gcd ( ( ( a * b ) \/ gcd ( a , b ) ) , c ) ) ) ) ) ; } function findNthTerm ( a , b , c , n ) { var low = 1 , high = Number . MAX_SAFE_INTEGER , mid ; while ( low < high ) { mid = low + ( high - low ) \/ 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; } var a = 2 , b = 3 , c = 5 , n = 100 ; document . write ( parseInt ( findNthTerm ( a , b , c , n ) ) ) ;"}
{"expert":"Python","ground_truth":"def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE DEDENT def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; bool isValid ( char a1 , char a2 , string str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; } bool inRange ( int hh , int mm , int L , int R ) { int a = abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } void displayTime ( int hh , int mm ) { if ( hh > 10 ) cout << hh << \" : \" ; else if ( hh < 10 ) cout << \"0\" << hh << \" : \" ; if ( mm > 10 ) cout << mm << endl ; else if ( mm < 10 ) cout << \"0\" << mm << endl ; } void maximumTimeWithDifferenceInRange ( string str , int L , int R ) { int i , j ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i \/ 10 ; if ( ! isValid ( h1 + '0' , h2 + '0' , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j \/ 10 ; if ( ! isValid ( m1 + '0' , m2 + '0' , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else cout << \" - 1\" << endl ; } int main ( ) { string timeValue = \" ? ? : ? ? \" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function isValid ( a1 , a2 , str , flag ) { let v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != ' ' ) return false ; if ( v2 != a2 && v2 != ' ' ) return false ; return true ; } function inRange ( hh , mm , L , R ) { let a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } function displayTime ( hh , mm ) { if ( hh > 10 ) document . write ( hh + \" \" ) ; else if ( hh < 10 ) document . write ( \" \" + hh + \" \" ) ; if ( mm > 10 ) document . write ( mm + \" \" ) ; else if ( mm < 10 ) document . write ( \" \" + mm + \" \" ) ; } function maximumTimeWithDifferenceInRange ( str , L , R ) { let i = 0 , j = 0 ; let h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = Math . floor ( i \/ 10 ) ; if ( ! isValid ( String . fromCharCode ( h1 ) , String . fromCharCode ( h2 ) , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = Math . floor ( j \/ 10 ) ; if ( ! isValid ( String . fromCharCode ( m1 ) , String . fromCharCode ( m2 ) , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else document . write ( \" \" ) ; } let timeValue = \" \" ; let L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ;"}
{"expert":"Python","ground_truth":"def printArrays ( n ) : NEW_LINE INDENT A , B = [ ] , [ ] ; NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT DEDENT print ( \" { \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \u2581 \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT print ( \" } \" ) ; NEW_LINE print ( \" { \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \" , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT print ( \" \u2581 } \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE printArrays ( N ) ; NEW_LINE DEDENT"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; string removeCharRecursive ( string str , char X ) { if ( str . length ( ) == 0 ) { return \" \" ; } if ( str [ 0 ] == X ) { return removeCharRecursive ( str . substr ( 1 ) , X ) ; } return str [ 0 ] + removeCharRecursive ( str . substr ( 1 ) , X ) ; } int main ( ) { string str = \" geeksforgeeks \" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; cout << str ; return 0 ; }"}
{"expert":"Java","ground_truth":"import java . io . * ; import java . util . * ; class GFG { static void printArrays ( int n ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; ArrayList < Integer > B = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . add ( i ) ; else B . add ( i ) ; } System . out . print ( \" { \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( A . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , \u2581 \" ) ; } System . out . print ( \" }NEW_LINE\"); System . out . print ( \" { \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( B . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , \u2581 \" ) ; } System . out . print ( \" \u2581 } \" ) ; } public static void main ( String [ ] args ) { int N = 5 ; printArrays ( N ) ; } }"}
{"expert":"Python","ground_truth":"from math import * NEW_LINE def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int minSum ( int A [ ] , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( mp . containsKey ( A [ i ] ) ) { mp . put ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; } else { mp . put ( A [ i ] , 1 ) ; } } int minSum = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { minSum = Math . min ( minSum , sum - ( it . getKey ( ) * it . getValue ( ) ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = arr . length ; System . out . print ( minSum ( arr , N ) + \"NEW_LINE\"); } }"}
{"expert":"Python","ground_truth":"def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) \/ 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT"}
{"expert":"Javascript","ground_truth":"function checkArray ( n , k , arr ) { var cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } var arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] ; var n = arr . length ; var k = 4 ; if ( checkArray ( n , k , arr ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int Landau = INT_MIN ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return ( a * b ) \/ gcd ( a , b ) ; } void findLCM ( vector < int > & arr ) { int nth_lcm = arr [ 0 ] ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = max ( Landau , nth_lcm ) ; } void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } } void Landau_function ( int n ) { vector < int > arr ; findWays ( arr , 1 , n ) ; cout << Landau ; } int main ( ) { int N = 4 ; Landau_function ( N ) ; return 0 ; }"}
{"expert":"Javascript","ground_truth":"function nearest ( n ) { var prevSquare = parseInt ( Math . sqrt ( n ) ) ; var nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = parseInt ( ( prevSquare - n ) ) ; } else ans = parseInt ( ( nextSquare - n ) ) ; return ans ; } var n = 14 ; document . write ( nearest ( n ) + \" \" ) ; n = 16 ; document . write ( nearest ( n ) + \" \" ) ; n = 18 ; document . write ( nearest ( n ) + \" \" ) ;"}
{"expert":"Javascript","ground_truth":"function printArrays ( n ) { let A = [ ] ; let B = [ ] ; for ( let i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . push ( i ) ; else B . push ( i ) ; } document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( A [ i ] ) ; if ( i != n - 1 ) document . write ( \" \" ) ; } document . write ( \" \" + \" \" ) ; document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( B [ i ] ) ; if ( i != n - 1 ) document . write ( \" \" ) ; } document . write ( \" \" ) ; } let N = 5 ; printArrays ( N ) ;"}
{"expert":"Java","ground_truth":"class GFG { static boolean isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static void checkExpression ( int n ) { if ( isPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void main ( String [ ] args ) { int N = 3 ; checkExpression ( N ) ; } }"}
{"expert":"Javascript","ground_truth":"function findDistinctSums ( N ) { return ( 2 * N - 1 ) ; } let N = 3 ; document . write ( findDistinctSums ( N ) ) ;"}
{"expert":"Python","ground_truth":"def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( \" Sum \u2581 = \" , calculateSum ( n ) ) NEW_LINE"}
{"expert":"Python","ground_truth":"MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return ( pow ( 2 , n + 1 ) + n - 2 ) ; } int main ( ) { int n = 4 ; cout << \" Sum \u2581 = \u2581 \" << calculateSum ( n ) ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1000001 NEW_LINE int spf [ MAXN ] ; int hash1 [ MAXN ] = { 0 } ; void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x \/ spf [ x ] ; } while ( x % temp == 0 ) x = x \/ temp ; } } bool check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x \/ temp ; } return true ; } bool hasValidNum ( int arr [ ] , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } int main ( ) { int arr [ ] = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; if ( hasValidNum ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N \/ 2 ) + 1 ; return Size ; } int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N \/ 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N \/ 2 , L , min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N \/ 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } int main ( ) { int N = 7 , L = 2 , R = 5 ; cout << CountOnes ( N , L , R ) << endl ; return 0 ; }"}
{"expert":"Python","ground_truth":"def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" , countPaths ( n , m ) ) NEW_LINE"}
{"expert":"C++","ground_truth":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = INT_MIN ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = max ( maxi , abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . push_back ( maxi ) ; } for ( auto x : res ) cout << x << \" \u2581 \" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }"}
{"expert":"Java","ground_truth":"import java . io . * ; class GFG { static int mod = 1000000000 ; static int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( 0 , arr , n ) ) ; } }"}
{"expert":"Java","ground_truth":"import java . util . * ; class GFG { static int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N \/ 2 ) + 1 ; return Size ; } static int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N \/ 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N \/ 2 , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N \/ 2 , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } public static void main ( String [ ] args ) { int N = 7 , L = 2 , R = 5 ; System . out . println ( CountOnes ( N , L , R ) ) ; } }"}
{"expert":"Java","ground_truth":"class GFG { static void printValueOfPi ( int N ) { double pi = 2 * Math . acos ( 0.0 ) ; System . out . println ( pi ) ; } public static void main ( String [ ] args ) { int N = 4 ; printValueOfPi ( N ) ; } }"}
{"expert":"C++","ground_truth":"#include \" bits \/ stdc + + . h \" NEW_LINE using namespace std ; void printValueOfPi ( int N ) { double pi = 2 * acos ( 0.0 ) ; printf ( \" % . * lf STRNEWLINE \" , N , pi ) ; } int main ( ) { int N = 45 ; printValueOfPi ( N ) ; return 0 ; }"}
{"expert":"Python","ground_truth":"import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE"}
{"expert":"Python","ground_truth":"def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' \u2581 ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT"}
{"expert":"Java","ground_truth":"class GFG { static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static long divTermCount ( long a , long b , long c , long num ) { return ( ( num \/ a ) + ( num \/ b ) + ( num \/ c ) - ( num \/ ( ( a * b ) \/ gcd ( a , b ) ) ) - ( num \/ ( ( c * b ) \/ gcd ( c , b ) ) ) - ( num \/ ( ( a * c ) \/ gcd ( a , c ) ) ) + ( num \/ ( ( a * b * c ) \/ gcd ( gcd ( a , b ) , c ) ) ) ) ; } static long findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = Long . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) \/ 2 ; if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; } else { high = mid ; } } return low ; } public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 5 , n = 100 ; System . out . println ( findNthTerm ( a , b , c , n ) ) ; } }"}
