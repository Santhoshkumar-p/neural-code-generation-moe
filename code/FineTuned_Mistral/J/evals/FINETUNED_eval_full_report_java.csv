,value,value,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
0,"import java . util . * ; class GFG { static int minSum ( int A [ ] , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( mp . containsKey ( A [ i ] ) ) { mp . put ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; } else { mp . put ( A [ i ] , 1 ) ; } } int minSum = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { minSum = Math . min ( minSum , sum - ( it . getKey ( ) * it . getValue ( ) ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = arr . length ; System . out . print ( minSum ( arr , N ) + ""NEW_LINE""); } }","] \n class GFG { static int minSum ( int arr [ ] , int N ) { int [ ] freq = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += ( i + 1 ) * freq [ i ] ; } int minSum = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 1 ) { minSum -= ( freq [ i ] - 1 ) * ( i + 1 ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 4 } ; int N = arr . length ; System . out . println ( minSum ( arr , N ) ) ; } } aupt ; 1 ; 2 ; 2 ; 3 ; 4 ; 4 ; 1 ; 2 ; 2 ; ",0.3781006585256141,0.4296931654466882,0.44012266595706806,0.3883495145631068,0.2542372881355932
1,"import java . util . * ; class GFG { static void maxAdjacent ( int [ ] arr , int N ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = Integer . MIN_VALUE ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . add ( maxi ) ; } for ( int x : res ) { System . out . print ( x + "" ▁ "" ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }","] = { 1 , 2 , 3 , 4 , 5 , 6 } ; Function call [/ INPUT ] 1 2 3 4 5 6 [/ INPUT ] ------------------------------------------------- 4 [/ INPUT ] 1 2 3 4 5 6 [/ INPUT ] --------------------------------- - 2 [/ INPUT ] 1 2 3 4 5 6 [/ INPUT ] --------------------------------- - 3 [/ INPUT ] 1 2 3 4 5 6 [/ INPUT ] --------------------------------- - 4 [/ INPUT ] 1 2 3 4 5 6 [/ INPUT ] --------------------------------- - 5 [/ INPUT ] 1 2 3 4 5 6 [/ INPUT ] --------------------------------- - 6 [/ INPUT ] 1 2 3 4 5 6 [/ INPUT ] --------------------------------- - 1 [/ INPUT ] 1 2 3 ",0.032445985577119425,0.03258963453995847,0.033702244276455746,0.0,0.06349206349206349
2,"import java . util . * ; class GFG { static int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; } static int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } public static void main ( String [ ] args ) { int N = 7 , L = 2 , R = 5 ; System . out . println ( CountOnes ( N , L , R ) ) ; } }","] \n class GFG { static int findSize ( int N ) { if ( N == 1 ) return 1 ; int Siz_M = findSize ( N / 2 ) ; if ( N % 2 == 0 ) return 2 * Siz_M ; else return 2 * Siz_M + 1 ; } static int countOnes ( int arr [ ] , int L , int R , int N ) { if ( L > R ) return 0 ; if ( L == R ) return arr [ L ] ; if ( L == R - 1 ) return ( arr [ L ] + arr [ R ] ) / 2 ; int Siz_M = findSize ( N ) ; int R_ = Math . min ( R , Siz_M ) ; int L_ = Math . max ( L , Siz_M + 1 ) ; return findSize ( N / 2 ) * ( ( R_ - L_ + 1 ) + arr [ L_ ] + arr [ R_ ] - arr [ L_ - 1 ] ; } public static void main ( String [ ]",0.38607919791374345,0.34783873632516754,0.36936537927346835,0.475,0.352112676056338
3,"class GFG { static boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void minDivisior ( int n ) { if ( prime ( n ) ) { System . out . print ( 1 + "" ▁ "" + ( n - 1 ) ) ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { System . out . print ( n / i + "" ▁ "" + ( n / i * ( i - 1 ) ) ) ; break ; } } } } public static void main ( String [ ] args ) { int N = 4 ; minDivisior ( N ) ; } }","] \n import java . io . * ; import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void find_pair ( int n ) { if ( isPrime ( n ) ) { System . out . println ( "" - 1"" ) ; } else { int i = 0 ; for ( i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { System . out . println ( n / i + ""   "" + n / i ) ; } else { System . out . println ( n / i + ""   "" + ( n / i ) * ( n - 1 ) / i ) ; } break ; } } } } public static void main ( String [ ] args ) { int N = 20 ; find_pair ( N )",0.637926339699317,0.5580930514378695,0.715314624649951,0.6704545454545454,0.6078431372549019
4,"import java . util . * ; class GFG { static int Landau = Integer . MIN_VALUE ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } static void findLCM ( Vector < Integer > arr ) { int nth_lcm = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr . get ( i ) ) ; Landau = Math . max ( Landau , nth_lcm ) ; } static void findWays ( Vector < Integer > arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } } static void Landau_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ; findWays ( arr , 1 , n ) ; System . out . print ( Landau ) ; } public static void main ( String [ ] args ) { int N = 4 ; Landau_function ( N ) ; } }","] \n class GFG { static int landau ( int n ) { int l = 0 ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == j ) dp [ i ] [ j ] = 1 ; else if ( j % i == 0 ) dp [ i ] [ j ] = dp [ i ] [ j / i ] + 1 ; else dp [ i ] [ j ] = dp [ i ] [ j - i ] ; l = Math . max ( l , dp [ i ] [ j ] ) ; } } return l ; } static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int lcm ( int a , int b ) { return ( a / gcd ( a , b ) * b ) ; } static int maxLCM ( int n ) { int l = 0 ; for ( int i = ",0.32828330350535595,0.3246489932825327,0.3416346272429561,0.3541666666666667,0.2926829268292683
5,"class GFG { static boolean isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static void checkExpression ( int n ) { if ( isPrime ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } public static void main ( String [ ] args ) { int N = 3 ; checkExpression ( N ) ; } }","T ] \n import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean check ( int n ) { if ( n % 2 == 0 ) return false ; if ( n % 3 == 0 ) return false ; return isPrime ( n - 1 ) ; } public static void main ( String [ ] args ) { int N = 5 ; if ( check ( N ) ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } } -------------------------------------------------------------------------------- -------------------- [/INST] \n import java . util . * ; class GFG { static boolean isPrime ( int n ) { if (",0.6624998475977166,0.6148430575006932,0.8573341550679957,0.8701298701298701,0.3076923076923077
6,"class GFG { static boolean checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = arr . length ; int k = 4 ; if ( checkArray ( n , k , arr ) ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } }","] \n import java . io . * ; class GFG { static boolean check ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) count ++ ; } if ( count % k == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; int k = 3 ; if ( check ( arr , n , k ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ------------------------------------------------ 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / ",0.638255016699806,0.5234732148620409,0.6729402453305767,0.6621621621621622,0.6944444444444444
7,"class GFG { static long func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ ] = new double [ 100005 ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ; double cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . min ( maxx , ( int ) ( Math . ceil ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( long ) ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( func ( arr , n ) + ""NEW_LINE""); } }","] \n class GFG { static int findSum ( int n ) { int max_ele = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] ++ ; max_ele = Math . max ( max_ele , arr [ i ] ) ; } int [ ] c = new int [ max_ele + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) c [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= max_ele ; i ++ ) c [ i ] += c [ i - 1 ] ; int ans = 0 ; for ( int i = 0 ; i <= max_ele ; i ++ ) { int x = ( i * ( i + 1 ) ) / 2 ; ans += ( c [ i ] - c [ i - 1 ] ) * x ; } ans += ( ( n - c [ max_ele ] + 1 ) * ( max_ele * ( max_ele + 1 ) / 2",0.2845378603101505,0.2396079029436632,0.2630734528268534,0.391025641025641,0.24444444444444444
8,"class GFG { static void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { System . out . println ( ""0"" ) ; return ; } if ( Xor == 0 ) { System . out . println ( ""1"" ) ; System . out . println ( Sum ) ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; System . out . print ( ""2"" ) ; System . out . println ( num1 + "" ▁ "" + num2 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; insert_element ( a , n ) ; } }","] \n class GFG { static void findElements ( int [ ] arr , int n ) { int Xor = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= arr [ i ] ; sum += arr [ i ] ; } if ( sum == 2 * Xor ) System . out . println ( 0 ) ; else { System . out . println ( 1 ) ; System . out . println ( sum ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 5 , 3 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } } đź¤ť đź¤ť [/INST] \n đź‘‰ [/INST] \n đź‘‰ [/INST] \n đź‘‰ [/INST] \n đź‘‰ [/INST] \n đź‘‰ [/INST] \n đź‘‰ [/INST] \n đź‘‰ [",0.48025212209351437,0.47231741168935254,0.47883292065633615,0.5531914893617021,0.4166666666666667
9,"class GFG { static void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; } }","T] \n import java . io . * ; class GFG { static void checkReciprocal ( int a , int b , int c ) { if ( a != 0 ) { float d = ( float ) ( b * b - 4 * a * c ) ; if ( d > 0 ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } else System . out . println ( "" Not   a   quadratic   equation "" ) ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 ; checkReciprocal ( a , b , c ) ; } } 1 / 2 ; } } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1 / 2 ; } 1",0.662765232492867,0.31959908259668185,0.7688602213585259,0.8292682926829268,0.7333333333333333
10,"import java . util . * ; class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { System . out . println ( "" Yes "" ) ; } else { System . out . println ( "" No "" ) ; } } public static void main ( String [ ] args ) { int N = 8 ; checkSunnyNumber ( N ) ; } }","] \n import java . util . * ; class GFG { static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) return false ; return true ; } public static void main ( String [ ] args ) { int N = 15 ; if ( isSunnyNumber ( N ) ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } }                                                     ",0.7467375392236989,0.5030946790085499,0.7671888112195788,0.7166666666666667,1.0
11,import java . io . * ; import java . util . * ; class GFG { static int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } public static void main ( String args [ ] ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } },] \n import java . util . * ; class GFG { static int count ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( i * i == N ) count ++ ; else if ( ( N / i ) * i == N ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( count ( N ) ) ; } } 1 | Java program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Iterate through all the integers ; Check if N can be converted to 1 ; Incrementing the count if it can be converted ; Driver code [/INST] \n class GFG { public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( count ( N ) ) ; } static int count ( int N ) { int count = 0 ; for,0.39089742651344445,0.2442071417149808,0.46569592839409657,0.532258064516129,0.32142857142857145
12,"class GFG { static void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + "" ▁ "" ) ; System . out . print ( N - K + 1 ) ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; } }","] \n import java . io . * ; class GFG { static void printNumbers ( int N , int K ) { for ( int i = 1 ; i < K ; i ++ ) System . out . print ( i + ""   "" ) ; System . out . println ( N - K + 1 ) ; } public static void main ( String [ ] args ) { int N = 5 , K = 3 ; printNumbers ( N , K ) ; } } цацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацацаца",0.6709902771219491,0.6962698834687747,0.7604184977462948,0.7272727272727273,0.5
13,import java . util . * ; class GFG { static int NthSmallest ( int K ) { Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . peek ( ) ; Q . remove ( ) ; if ( x % 10 != 0 ) { Q . add ( x * 10 + x % 10 - 1 ) ; } Q . add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . add ( x * 10 + x % 10 + 1 ) ; } } return x ; } public static void main ( String [ ] args ) { int N = 16 ; System . out . print ( NthSmallest ( N ) ) ; } },] \n import java . util . * ; class GFG { static int findNthSteppingNumber ( int N ) { Queue < Integer > q = new LinkedList < Integer > ( ) ; for ( int i = 1 ; i <= 9 ; i ++ ) q . add ( i ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = q . peek ( ) ; q . remove ( ) ; if ( x % 10 != 0 ) q . add ( 10 * x + ( x % 10 ) - 1 ) ; q . add ( 10 * x + ( x % 10 ) ) ; if ( x % 10 != 9 ) q . add ( 10 * x + ( x % 10 ) + 1 ) ; } return q . peek ( ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( findNthSteppingNumber ( N ) ) ; } } 1 2 3 4 5 6 7 8 ,0.5307879914112597,0.5746399995855653,0.6219668799399191,0.6170212765957447,0.30952380952380953
14,class GFG { static int nearest ( int n ) { int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( nearest ( n ) ) ; n = 16 ; System . out . println ( nearest ( n ) ) ; n = 18 ; System . out . println ( nearest ( n ) ) ; } },] \n class GFG { static int leastNumber ( int n ) { int i = ( int ) Math . sqrt ( n ) ; int j = ( int ) Math . sqrt ( n + 1 ) ; if ( ( i * i - n ) < ( j * j - n ) ) return i * i - n ; return j * j - n ; } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( leastNumber ( n ) ) ; } } 1 / 12 / 13 / 14 / 15 / 16 / 17 / 18 / 19 / 20 / 21 / 22 / 23 / 24 / 25 / 26 / 27 / 28 / 29 / 30 / 31 / 32 / 33 / 34 / 35 / 36 / 37 / 38 / 39 / 40 / 41 / 42 / 43 / 44,0.46229249895115165,0.31500852736088564,0.4120649824401474,0.6438356164383562,0.4782608695652174
15,class GFG { static void printValueOfPi ( int N ) { double pi = 2 * Math . acos ( 0.0 ) ; System . out . println ( pi ) ; } public static void main ( String [ ] args ) { int N = 4 ; printValueOfPi ( N ) ; } },"] \n class GFG { static void printPi ( int N ) { double pi = Math . acos ( - 1 ) ; System . out . printf ( "" % .50f "" , pi ) ; } public static void main ( String [ ] args ) { int N = 50 ; printPi ( N ) ; } }                                                                                        ",0.5014457097943726,0.25447630509627306,0.703011079535763,0.59375,0.45454545454545453
16,"class GFG { static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int getNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } public static void main ( String [ ] args ) { int n = 56 ; int k = 2 ; System . out . println ( getNum ( n , k ) ) ; } }","] \n class GFG { static int [ ] toBinary ( int n ) { int [ ] arr = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { arr [ i ] = n % 2 ; n = n / 2 ; i ++ ; } return arr ; } static int toDecimal ( int [ ] arr ) { int decimal = 0 ; int i = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { decimal = decimal + arr [ i ] * ( int ) Math . pow ( 2 , i ) ; } return decimal ; } static int flipKthBit ( int n , int k ) { int [ ] arr = toBinary ( n ) ; int i = 0 ; int size = arr . length ; if ( k > size ) return - 1 ; if ( k <= size ) { arr [ k - 1 ] = 1 - arr [ k - 1 ] ; } return toDecimal ( arr ) ; } public static void main ( String [ ] args ) { int n = 5 ; int k = 3 ; System . out . print",0.3984379067489774,0.39790661191097343,0.41188139081965935,0.4881889763779528,0.29577464788732394
17,"import java . io . * ; class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ; static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } static void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; } public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }","{ 0 , 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 , 3628800 , 39916800 , 479001600 , 6227020800 , 87178291200 , 1307674368000 , 20024188160000 , 3003072016160000 } ; Function call to precompute the factorial of n ; Function call to perform queries [/ INPUT ] 10 4 12 5 [/ INPUT ] 2 1 3 4 5 6 7 8 9 10 [/ INPUT ] 3 1 2 3 [/ INPUT ] 5 1 2",0.005201737507605897,0.0019484483495580943,0.0032335016808654935,0.0,0.015625
18,"class GFG { static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; } static long findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = Long . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; } else { high = mid ; } } return low ; } public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 5 , n = 100 ; System . out . println ( findNthTerm ( a , b , c , n ) ) ; } }","] \n import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int count ( int num , int a , int b , int c ) { int count_a = ( num / a ) ; int count_b = ( num / b ) ; int count_c = ( num / c ) ; int count_ab = ( count_a + count_b - ( count_a / gcd ( a , b ) * gcd ( a , b ) ) ) ; int count_bc = ( count_b + count_c - ( count_b / gcd ( b , c ) * gcd ( b , c ) ) ) ; int count_ca = ( count_a + count_c - ( count_a / gcd ( a , c ) * gcd ( a , c ) ) ) ; int count = count_a + count_b + count_c - count_ab - count_bc - count_ca ; return count ; } static int binarySearch ( int num , int a",0.3521384110541319,0.22531426013312778,0.2413049140590423,0.44755244755244755,0.4943820224719101
19,"class GFG { static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }","] \n import java . io . * ; class GFG { static boolean checkAngle ( int n , int i , int j , int k ) { int x = Math . abs ( i - j ) ; int y = Math . abs ( j - k ) ; if ( ( x + y ) % n == 0 ) { int z = x + y ; if ( ( z % 360 ) == 0 ) return true ; else return false ; } return false ; } public static void main ( String [ ] args ) { int n = 6 ; int i = 1 , j = 3 , k = 4 ; if ( checkAngle ( n , i , j , k ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } đź¤” [/INST] \n class GFG { public static void main ( String [ ] args ) { int n = 6 ; int i = 1 , j = 3 , k = 4 ; if ( checkAngle ( n , i , j , k ) ) System . out . println ( "" Yes """,0.430545051754527,0.25790754564993446,0.3662334456818991,0.47058823529411764,0.6274509803921569
20,"class GFG { static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( "" Loss ▁ = ▁ "" + loss ) ; } public static void main ( String [ ] args ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; } }",] \n import java . io . * _ * ; class GFG { static int findLoss ( int n ) { return ( n * 100 ) / 100 ; } public static void main ( String args [ ] ) { int n = 100 ; System . out . println ( findLoss ( n ) ) ; } } 1 / 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 10,0.2567713495889997,0.1768011806992613,0.2578989992916759,0.2765957446808511,0.3157894736842105
21,"class GFG { static int MAXN = 1000001 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] hash1 = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } static boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } static boolean hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }",[/INST] \n import java . io . * ; import java . util . * ; import java . util . Arrays ; import java . util . Collections ; class GFG { static final int MAXN = 1000005 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] count = new int [ MAXN ] ; static void SieveOfEratosthenes ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) spf [ i ] = i ; for ( int j = i * 2 ; j < MAXN ; j += i ) { if ( spf [ j ] == j ) spf [ j ] = i ; } } static void primeFactors ( ) { for ( int i = 1 ; i < MAXN ; i ++ ) { int x = spf [ i ] ; while ( i > 1 ) { count [ x ] ++ ; i,0.26269395311955085,0.19574850229411886,0.3050273101840845,0.5,0.05
22,"class GfG { static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }","] \n class GFG { static int countWays ( int n ) { int ans = 0 ; ans = ( int ) Math . pow ( 2 , ( n * ( n - 1 ) / 2 ) ) ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } ~\n import java . io . * ; class GFG { static int countWays ( int n ) { int ans = 0 ; ans = ( int ) Math . pow ( 2 , ( n * ( n - 1 ) / 2 ) ) ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } ~\n ----------------------auptika ---------------------- \n class GFG { static int countWays ( int n ) { int ans = 0 ; ans = ( int ) Math . pow ( 2 , ( n * ( n - 1 ) / 2 ) ) ; return ans ; } public static",0.5652069836738761,0.2150814504677899,0.5632290017102319,0.6363636363636364,0.8461538461538461
23,"class GFG { static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } static int nCr ( int n , int r ) { return l [ n ] [ r ] ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 8 ; int r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }","] import java . util . * ; class GFG { static int MAX = 1000 ; static int [ ] [ ] pascal = new int [ MAX ] [ MAX ] ; static void buildPascal ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) pascal [ i ] [ j ] = 1 ; else pascal [ i ] [ j ] = pascal [ i - 1 ] [ j - 1 ] + pascal [ i - 1 ] [ j ] ; } } } static int nCr ( int n , int r ) { return pascal [ n ] [ r ] ; } public static void main ( String [ ] args ) { int n = 3 , r = 2 ; buildPascal ( ) ; System . out . println ( nCr ( n , r ) ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- ----------------",0.5965106352411061,0.5459038479020215,0.6221772878174749,0.686046511627907,0.5319148936170213
24,class GFG { static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } },ass GFG { static int minAbsDiff ( int n ) { int sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) sum += i ; return ( sum - 1 ) ; } 10 10 ; Driver code [/ INPUT ] 10 ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ INPUT ] ; Function call [/ IN,0.21715323750003596,0.07413750821896961,0.20595869536969102,0.3157894736842105,0.2727272727272727
25,"class GFG { static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; } public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( ""YesNEW_LINE""); else System . out . println ( ""NoNEW_LINE""); } }","0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; Driver code [/DRIVER_CODE] \n class GFG { static int isZeroXor ( int N ) { int [ ] freq = new int [ 10 ] ; int last_digit = N % 10 ; freq [ last_digit ] ++ ; while ( N > 9 ) { N = N / 10 ; int temp = N % 10 ; freq [ temp ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { ans = ans ^ freq [ i ] ; } return ans ; } public static void main ( String [ ] args ) { int N = 12345 ; if ( isZeroXor ( N ) == 0 ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------------------------",0.4894252547701655,0.41696661808913366,0.4363282707233291,0.632183908045977,0.4722222222222222
26,"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + "" ▁ "" + k * ( 6 * i + 2 ) + "" ▁ "" + k * ( 6 * i + 3 ) + "" ▁ "" + k * ( 6 * i + 5 ) ) ; } } public static void main ( String args [ ] ) { int n = 2 , k = 2 ; printLines ( n , k ) ; } }","] \n import java . util . * ; class GFG { static void print ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( i * K + ""   "" + ( i + 1 ) * K + ""   "" + ( i + 2 ) * K + ""   "" + ( i + 3 ) * K + ""NEW_LINE""); } } public static void main ( String [ ] args ) { int N = 3 , K = 5 ; print ( N , K ) ; } } -------------------------------- 1 / 2 -------------------------------- - 2 / 2 -------------------------------- - 3 / 2 -------------------------------- - 4 / 2 -------------------------------- - 5 / 2 -------------------------------- - 6 / 2 -------------------------------- - 7 / 2 -------------------------------- - 8 / 2 -------------------------------- - 9 / 2 -------------------------------- - 10 / 2 -------------------------------- - 11 / 2 -------------------------------- - 12 / 2 -------------------------------- - 13 / 2 ----------------",0.3601918110563711,0.29734934371737476,0.3848726448340597,0.36231884057971014,0.39622641509433965
27,"import java . util . * ; class GFG { static int calculateSum ( int n ) { return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( "" Sum ▁ = ▁ "" + calculateSum ( n ) ) ; } }",] class GFG { static int Sn ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( Sn ( n ) ) ; } } orszag 10.10K 0.0 0 onlinegooglegroups.com 10.10K 0.0 0 onlinegooglegroups.com,0.48025595639635854,0.4764855119169111,0.4855639546941639,0.358974358974359,0.6
28,"import java . util . * ; class GFG { static final int mod = 1000000007 ; static int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( count_special ( n ) + ""NEW_LINE""); } }",] \n import java . util . * ; class GFG { static int countSpecialStrings ( int n ) { int fib [ ] = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countSpecialStrings ( n ) ) ; } } ~~~~ \n import java . util . * ; class GFG { static int countSpecialStrings ( int n ) { int fib [ ] = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n =,0.6586366296509858,0.4451065056334142,0.7552347815821988,0.6056338028169014,0.8285714285714286
29,"import java . io . * ; class GFG { static int mod = 1000000000 ; static int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( 0 , arr , n ) ) ; } }","] \n import java . util . * ; class GFG { static int countPaths ( int [ ] arr , int i , int j , int n ) { if ( i == n - 1 ) return 1 ; if ( j == - 1 ) return 0 ; int ans = countPaths ( arr , i + 1 , j , n ) + countPaths ( arr , i , j - arr [ i ] , n ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 1 } ; int n = arr . length ; System . out . println ( countPaths ( arr , 0 , 0 , n ) ) ; } } ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- --------------------------------------------------------------------------------",0.45026427533735347,0.4745543338557054,0.4790124200033611,0.4189189189189189,0.42857142857142855
30,"class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ; static int ways ( int arr [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( arr , n ) % mod ) ; } }","] \n import java . util . * ; class GFG { static int countPaths ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = i + 1 ; j <= i + k && j < n ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ 0 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 } ; int k = 2 ; int n = arr . length ; System . out . println ( countPaths ( arr , n , k ) ) ; } } đź¤Ż1 [/INST] \n import java . util . * ; class GFG { static int countPaths ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ n - 1 ] = ",0.5468914347597247,0.5589311258695031,0.6609796266464847,0.5714285714285714,0.39622641509433965
31,"class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair countSum ( int arr [ ] , int n ) { int result = 0 ; int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; pair ans = countSum ( arr , n ) ; System . out . print ( "" EvenSum ▁ = ▁ "" + ans . first ) ; System . out . print ( "" ▁ OddSum ▁ = ▁ "" + ans . second ) ; } }","] \n import java . io . * ; class GFG { static int countSubsequences ( int arr [ ] , int n ) { int count_even = 0 , count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return count_even + count_odd ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( countSubsequences ( arr , n ) ) ; } 1 / 06/java/count_subsequences_with_even_and_odd_sum_1/count_subsequences_with_even_and_odd_sum_1.java } ; 1 / 06/java/count_subsequences_with_even_and_odd_sum_1/count_subsequ",0.3416399922197274,0.3075873763926583,0.3664947163800566,0.4424778761061947,0.25
32,"import java . util . * ; class GFG { static int MAX = 10 ; static Vector < Integer > numToVec ( int N ) { Vector < Integer > digit = new Vector < Integer > ( ) ; while ( N != 0 ) { digit . add ( N % 10 ) ; N = N / 10 ; } if ( digit . size ( ) == 0 ) digit . add ( 0 ) ; Collections . reverse ( digit ) ; return digit ; } static int solve ( Vector < Integer > A , int B , int C ) { Vector < Integer > digit = new Vector < Integer > ( ) ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A . get ( 0 ) == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return ( int ) Math . pow ( d , B ) ; } else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) lower [ A . get ( i ) + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit . get ( i - 1 ) ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A . get ( 0 ) == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit . get ( i - 1 ) + 1 ] == lower [ digit . get ( i - 1 ) ] + 1 ) ) ; } return dp [ B ] ; } } public static void main ( String [ ] args ) { Integer arr [ ] = { 0 , 1 , 2 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int N = 2 ; int k = 21 ; System . out . println ( solve ( A , N , k ) ) ; } }","Function call to find the count of integers [/INST] \n import java . util . * ; class GFG { static int [ ] digitToInt ( int N ) { int [ ] digits = new int [ 30 ] ; int i = 0 ; while ( N > 0 ) { digits [ i ] = N % 10 ; N /= 10 ; i ++ ; } if ( N == 0 ) { digits [ i ] = 0 ; } for ( int j = 0 ; j < i ; j ++ ) { digits [ i - 1 ] = digits [ j ] ; } return digits ; } static int countIntegers ( int B , int C , int [ ] A , int N ) { int [ ] digit = digitToInt ( N ) ; if ( digit [ B - 1 ] > C ) { return 0 ; } else if ( digit [ B - 1 ] < C ) { return 1 << B ; } int [ ] lower = new int [ 30 ] ; for ( int i = 0 ; i < B",0.18737496511953117,0.08910451999760322,0.17564680565702404,0.33992094861660077,0.14482758620689656
33,"class GFG { public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; } public static void main ( String [ ] args ) { int W = 3 , K = 3 , M = 2 ; int [ ] [ ] dp = new int [ W + 1 ] [ 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( solve ( dp , W , K , M , 0 ) + ""NEW_LINE""); } }","] class GFG { static int countPaths ( int wt , int k , int M , int used [ ] ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) return 1 ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( used [ i ] == 0 ) { count += countPaths ( wt - i , k , M , used ) ; used [ i ] = 1 ; } } return count ; } public static void main ( String [ ] args ) { int wt = 4 , k = 3 , M = 2 ; int used [ ] = new int [ k ] ; System . out . println ( countPaths ( wt , k , M , used ) ) ; } } ๐จโ๐ 3.6K ๐จโ๐ 105 ๐จโ๐ 215 ๐จโ๐ 417 ๐จโ",0.3566279139940634,0.2711863024739273,0.3248596000776688,0.488,0.3424657534246575
34,class GFG { static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( partitions ( N ) ) ; } },] \n import java . io . * ; class GFG { static int countPartitions ( int N ) { if ( N == 1 ) return 1 ; return countPartitions ( N - 1 ) + countPartitions ( N - 2 ) + countPartitions ( N - 3 ) ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( countPartitions ( N ) ) ; } } đźŹ« [/INST] \n 10 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 100 ; 100 / 10,0.2427966815577106,0.20819823023131948,0.21662834274281795,0.39080459770114945,0.15555555555555556
35,"import java . util . * ; class GFG { static int LIP ( int dp [ ] [ ] , int mat [ ] [ ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } static int wrapper ( int mat [ ] [ ] , int n , int m ) { int dp [ ] [ ] = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; System . out . println ( wrapper ( mat , n , m ) ) ; } }","[ 0 ] = 0 ; [/INST] \n import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] [ ] dp = new int [ 1000 ] [ 1000 ] [ 1000 ] ; static int longestIncreasingPath ( int [ ] [ ] mat , int i , int j , int n , int m ) { if ( dp [ i ] [ j ] [ mat [ i ] [ j ] ] != - 1 ) return dp [ i ] [ j ] [ mat [ i ] [ j ] ] ; if ( i == n - 1 && j == m - 1 ) { dp [ i ] [ j ] [ mat [ i ] [ j ] ] = 1 ; return 1 ; } if ( i == 0 && j == 0 ) { dp [ i ] [ j ] [ mat [ i ] [ j ] ] = 1 ; return 1 ; } if ( mat [ i ] [ j ] > mat [ i + 1 ] [ j ] ) { int temp = longestIncreasing",0.2457874328358915,0.1448872364013463,0.18945199899796578,0.45222929936305734,0.19658119658119658
36,"import java . io . * ; class GFG { static int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( "" ▁ Number ▁ of ▁ Paths ▁ "" + countPaths ( n , m ) ) ; } }","] \n import java . util . * ; class GFG { static int countPaths ( int x , int y , int n ) { if ( x == 0 && y == 0 ) return 1 ; if ( x == 0 y == 0 ) return 1 ; return countPaths ( x - 1 , y , n ) + countPaths ( x , y - 1 , n ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countPaths ( n , n , n ) ) ; } } ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ",0.547545439068471,0.39530096413814575,0.5607871546807562,0.46938775510204084,0.7647058823529411
37,"import java . util . Arrays ; class GFG { static final int MAX = 100 ; static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } public static void main ( String arg [ ] ) { int gold [ ] [ ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; System . out . print ( getMaxGold ( gold , m , n ) ) ; } }",ass GFG ; Returns maximum amount of gold that can be collected from goldMine [ ] [ ] [ ] ; Create a table to store intermediate results ; Fill the first row of the table ; Fill the rest of the rows ; Driver code [/ INPUT : First row of the array ; Function call [/ INPUT : First row of the array ; Print the maximum amount of gold collected [/ ] 1 2 3 4 8 5 9 10 15 5 7 6 8 4 5 9 10 15 ; Driver code [/ ] 1 2 3 4 8 5 9 10 15 5 7 6 8 4 5 9 10 15 ; Print the maximum amount of gold collected [/ ] 1 2 3 4 8 5 9 10 15 5 7 6 8 4 5 9 10 15 ; Driver code [/ ] 1 2,0.04271684800620819,0.012356585687961462,0.01828261347709947,0.03496503496503497,0.10526315789473684
38,"import java . io . * ; import java . util . * ; class GFG { public static int M = 100 ; static int minAdjustmentCost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = arr . length ; int target = 10 ; System . out . println ( "" Minimum ▁ adjustment ▁ cost ▁ is ▁ "" + minAdjustmentCost ( arr , n , target ) ) ; } }","] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",0.25130777046445185,1.9834651205472894e-07,0.005230883511295408,0.0,0.0
39,"import java . util . * ; class GFG { static int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } public static void main ( String [ ] args ) { int L = 2 , R = 6 ; System . out . print ( totalCombination ( L , R ) ) ; } }","] \n import java . util . * ; class GFG { static int countTriplets ( int L , int R ) { int count = 0 ; int diff = R - L ; if ( diff < 3 ) return 0 ; count = ( diff * ( diff - 1 ) ) / 2 ; return count ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . print ( countTriplets ( L , R ) ) ; } } ~~~~ \n class GFG { static int countTriplets ( int L , int R ) { int count = 0 ; int diff = R - L ; if ( diff < 3 ) return 0 ; count = ( diff * ( diff - 1 ) ) / 2 ; return count ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . print ( countTriplets ( L , R ) ) ; } } ~~~~ \n class GFG { static int countTriplets ( int L , int R ) { int count = 0 ; int diff =",0.6208783065471293,0.344428498155174,0.6985389190664817,0.7368421052631579,0.7037037037037037
40,"import java . io . * ; import java . util . * ; class GFG { static void printArrays ( int n ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; ArrayList < Integer > B = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . add ( i ) ; else B . add ( i ) ; } System . out . print ( "" { ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( A . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( "" , ▁ "" ) ; } System . out . print ( "" }NEW_LINE""); System . out . print ( "" { ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( B . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( "" , ▁ "" ) ; } System . out . print ( "" ▁ } "" ) ; } public static void main ( String [ ] args ) { int N = 5 ; printArrays ( N ) ; } }","] \n import java . util . * ; class GFG { static void constructArrays ( int n ) { int [ ] A = new int [ 2 * n ] ; int [ ] B = new int [ 2 * n ] ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { A [ i - 1 ] = i ; B [ i - 1 ] = i ; } System . out . print ( "" Array   A :   "" ) ; for ( int i = 0 ; i < A . length ; i ++ ) { System . out . print ( A [ i ] + ""   "" ) ; } System . out . println ( ) ; System . out . print ( "" Array   B :   "" ) ; for ( int i = 0 ; i < B . length ; i ++ ) { System . out . print ( B [ i ] + ""   "" ) ; } } public static void main ( String [ ] args ) { int n = 3 ; constructArrays ( n ) ; } } 1 2 3 4 5 6 7 8 9 10 11",0.42668785674934756,0.4443659962604324,0.45863362698515425,0.5714285714285714,0.23232323232323232
41,"import java . util . * ; class GFG { static void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } System . out . print ( A + "" ▁ "" + B ) ; } public static void main ( String [ ] args ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; } }","T] \n import java . util . * ; class GFG { static void flipBits ( int A , int B ) { int i ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) > 0 ) { if ( ( B & ( 1 << i ) > 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } } System . out . println ( A ) ; System . out . println ( B ) ; } public static void main ( String [ ] args ) { int A = 10 , B = 5 ; flipBits ( A , B ) ; } } 1010 101 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010",0.6124452666988653,0.6335605222800332,0.7677356960305798,0.6818181818181818,0.36666666666666664
42,import java . util . * ; class GFG { static int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } },] \n class GFG { static int countDistinctSum ( int N ) { return ( N * ( N + 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( countDistinctSum ( N ) ) ; } } ~~~~,0.7233324235506212,0.640081030577937,0.6471880575639419,0.6060606060606061,1.0
43,"import java . util . * ; class GFG { public static int countSubstrings ( String str ) { int [ ] freq = new int [ 3 ] ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str . charAt ( j ) - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charAt ( i ++ ) - '0' ] -- ; } count += i ; } return count ; } public static void main ( String [ ] args ) { String str = ""00021"" ; System . out . println ( countSubstrings ( str ) ) ; } }","] \n import java . util . * ; class GFG { static int countSubstrings ( String str , int n ) { int freq [ ] = new int [ 3 ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - '0' ] ++ ; if ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) ans += n - i ; } return ans ; } public static void main ( String [ ] args ) { String str = ""01210"" ; int n = str . length ( ) ; System . out . println ( countSubstrings ( str , n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ",0.5929855315640546,0.5796611301041024,0.6603051288821312,0.6025641025641025,0.5294117647058824
44,"import java . io . * ; class GFG { static int minFlips ( String str ) { int count = 0 ; if ( str . length ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . length ( ) - 2 { if ( str . charAt ( i ) == str . charAt ( i + 1 ) && str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { String S = ""0011101"" ; System . out . println ( minFlips ( S ) ) ; } }","] \n import java . util . * ; class GFG { static int minimumFlips ( String s ) { int count = 0 ; if ( s . length ( ) < 4 ) return 0 ; int counter = 0 ; for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) && s . charAt ( i + 1 ) == s . charAt ( i + 2 ) ) { count += counter ; counter = 0 ; } else { counter ++ ; } } return count ; } public static void main ( String [ ] args ) { String s = ""101011"" ; System . out . println ( minimumFlips ( s ) ) ; } } ~\n class GFG { static int minimumFlips ( String s ) { int count = 0 ; if ( s . length ( ) < 4 ) return 0 ; int counter = 0 ; for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . char",0.5058271523255966,0.4193589281568086,0.6299913478122445,0.640625,0.3333333333333333
45,"import java . awt . * ; import java . util . * ; class GFG { static String convertToHex ( int num ) { StringBuilder temp = new StringBuilder ( ) ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp . append ( c ) ; num = num / 16 ; } return temp . toString ( ) ; } static String encryptString ( String S , int N ) { StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S . charAt ( i ) ; int count = 0 ; String hex ; while ( i < N && S . charAt ( i ) == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans . append ( ch ) ; ans . append ( hex ) ; } ans . reverse ( ) ; return ans . toString ( ) ; } public static void main ( String [ ] args ) { String S = "" abc "" ; int N = S . length ( ) ; System . out . println ( encryptString ( S , N ) ) ; } }","] \n import java . util . * ; class GFG { static String convertToHex ( int num ) { String hex = ""0123456789ABCDEF "" ; String ans = "" "" ; while ( num > 0 ) { ans = hex . charAt ( num % 16 ) + ans ; num = num / 16 ; } return ans ; } static String encrypt ( String S , int ch ) { int count = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == ch ) { count ++ ; } else { break ; } } int i = i - 1 ; String ans = "" "" ; while ( count > 0 ) { ans = ans + ch ; ans = ans + convertToHex ( count ) ; count = count - 1 ; i = i - 1 ; } ans = new StringBuilder ( ans ) . reverse ( ) . toString ( ) ; return ans ; } public static void main ( String [ ] args ) { String S = "" aaabbccddee "" ; int ch = ' a",0.3998208312957698,0.42236475913699695,0.43826441894123097,0.5555555555555556,0.18309859154929578
46,"import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int countOfString ( int N ) { int Stotal = ( int ) Math . pow ( 2 , N ) ; int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( countOfString ( N ) ) ; } }","] \n import java . util . * ; class GFG { static int C ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int countBinaryStrings ( int n ) { int count = ( 1 << n ) ; int count1 = count / 2 ; int ans = count - count1 ; if ( n % 2 == 0 ) ans += count1 ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( countBinaryStrings ( N ) ) ; } } ---------------- LDAP ---------------- 2 / 3 2 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ",0.5760601204656726,0.5931004811784344,0.6891541850814192,0.7666666666666667,0.2553191489361702
47,"class GFG { static String removeCharRecursive ( String str , char X ) { if ( str . length ( ) == 0 ) { return "" "" ; } if ( str . charAt ( 0 ) == X ) { return removeCharRecursive ( str . substring ( 1 ) , X ) ; } return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; } public static void main ( String [ ] args ) { String str = "" geeksforgeeks "" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; System . out . println ( str ) ; } }","2 ] public class GFG { public static String removeRecursive ( String str , char ch ) { if ( str . length ( ) == 0 ) return "" "" ; if ( str . charAt ( 0 ) == ch ) return removeRecursive ( str . substring ( 1 ) , ch ) ; return str . charAt ( 0 ) + removeRecursive ( str . substring ( 1 ) , ch ) ; } public static void main ( String [ ] args ) { String str = "" geeksforgeeks "" ; char ch = ' e ' ; System . out . println ( removeRecursive ( str , ch ) ) ; } } Độ dà gia cư 1.8.0.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt",0.7291373239624539,0.6080379596651564,0.6612964820732535,0.7241379310344828,0.9230769230769231
48,"import java . util . * ; class GFG { static boolean isValid ( char a1 , char a2 , String str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str . charAt ( 4 ) ; v2 = str . charAt ( 3 ) ; } else { v1 = str . charAt ( 1 ) ; v2 = str . charAt ( 0 ) ; } if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; } static boolean inRange ( int hh , int mm , int L , int R ) { int a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } static void displayTime ( int hh , int mm ) { if ( hh > 10 ) System . out . print ( hh + "" : "" ) ; else if ( hh < 10 ) System . out . print ( ""0"" + hh + "" : "" ) ; if ( mm > 10 ) System . out . println ( mm ) ; else if ( mm < 10 ) System . out . println ( ""0"" + mm ) ; } static void maximumTimeWithDifferenceInRange ( String str , int L , int R ) { int i = 0 , j = 0 ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ; if ( ! isValid ( ( char ) h1 , ( char ) h2 , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ; if ( ! isValid ( ( char ) m1 , ( char ) m2 , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else System . out . println ( "" - 1"" ) ; } public static void main ( String [ ] args ) { String timeValue = "" ? ? : ? ? "" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; } }","] \n import java . util . * ; class GFG { static boolean isCorrect ( String time ) { int hour = 0 , minute = 0 ; for ( int i = 0 ; i < time . length ( ) ; i ++ ) { if ( time . charAt ( i ) == ' : ' ) continue ; if ( time . charAt ( i ) >= '0' && time . charAt ( i ) <= '9' ) { hour = hour * 10 + time . charAt ( i ) - '0' ; } else if ( time . charAt ( i ) >= '65' && time . charAt ( i ) <= '90' ) { minute = minute * 10 + time . charAt ( i ) - '65' ; } else { return false ; } } if ( hour > 23 hour < 0 minute > 59 minute < 0 ) return false ; if ( hour != 0 && minute != 0 ) { return false ; } return true ; } static boolean isDifferenceCorrect ( String time , int L , int R ) { int hour = 0 , minute =",0.1687943689549979,0.08190497060792042,0.13622689595407253,0.3185840707964602,0.13846153846153847
49,"import java . util . * ; class GFG { static boolean check ( String s , int n ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . isEmpty ( ) && st . peek ( ) == s . charAt ( i ) ) st . pop ( ) ; else st . add ( s . charAt ( i ) ) ; } if ( st . isEmpty ( ) ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { String str = "" aanncddc "" ; int n = str . length ( ) ; if ( check ( str , n ) ) { System . out . print ( "" Yes "" + ""NEW_LINE""); } else { System . out . print ( "" No "" + ""NEW_LINE""); } } }","] \n class GFG { static void checkString ( String str ) { int n = str . length ( ) ; int i ; int top = - 1 ; for ( i = 0 ; i < n ; i ++ ) { while ( top >= 0 && str . charAt ( top ) == str . charAt ( i ) ) top -- ; if ( top < 0 ) top = i ; else top -- ; } if ( top < 0 ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } public static void main ( String [ ] args ) { String str = "" geeksforgeeks "" ; checkString ( str ) ; } } औहे पर क्लिक करें 5 ; औहे पर क्लिक करें 6 ; औहे पर क्लिक करें 7 ; औहे पर क्लिक करें 8 ; ��",0.4366905024929483,0.36058364908845303,0.3639561386611179,0.4222222222222222,0.6
50,"import java . util . * ; class GFG { static void findNumOfValidWords ( Vector < String > w , Vector < String > p ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; Vector < Integer > res = new Vector < > ( ) ; for ( String s : w ) { int val = 0 ; for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } if ( m . containsKey ( val ) ) m . put ( val , m . get ( val ) + 1 ) ; else m . put ( val , 1 ) ; } for ( String s : p ) { int val = 0 ; for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s . charAt ( 0 ) - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . containsKey ( temp ) ) { count += m . get ( temp ) ; } } temp = ( temp - 1 ) & val ; } res . add ( count ) ; } for ( int it : res ) { System . out . println ( it ) ; } } public static void main ( String [ ] args ) { Vector < String > arr1 = new Vector < > ( ) ; arr1 . add ( "" aaaa "" ) ; arr1 . add ( "" asas "" ) ; arr1 . add ( "" able "" ) ; arr1 . add ( "" ability "" ) ; arr1 . add ( "" actt "" ) ; arr1 . add ( "" actor "" ) ; arr1 . add ( "" access "" ) ; Vector < String > arr2 = new Vector < > ( ) ; arr2 . add ( "" aboveyz "" ) ; arr2 . add ( "" abrodyz "" ) ; arr2 . add ( "" absolute "" ) ; arr2 . add ( "" absoryz "" ) ; arr2 . add ( "" actresz "" ) ; arr2 . add ( "" gaswxyz "" ) ; findNumOfValidWords ( arr1 , arr2 ) ; } }","] \n import java . util . * ; class GFG { static void countStrings ( String arr1 [ ] , String arr2 [ ] , int N , int M ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < arr1 [ i ] . length ( ) ; j ++ ) { if ( arr1 [ i ] . charAt ( j ) == '1' ) temp |= ( 1 << j ) ; } freq . put ( temp , freq . getOrDefault ( temp , 0 ) + 1 ) ; } ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < arr2 [ i ] . length ( ) ; j ++ ) { if ( arr2 [ i ] . charAt ( j ) == '1' ) temp |= ( 1 << j ) ; } if ( freq",0.17565865333263933,0.11632082467628929,0.16797593860910087,0.2146341463414634,0.2037037037037037
51,"import java . util . * ; class GFG { static void flip ( String s ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == '0' ) { while ( sb . charAt ( i ) == '0' ) { sb . setCharAt ( i , '1' ) ; i ++ ; } break ; } } System . out . println ( sb . toString ( ) ) ; } public static void main ( String [ ] args ) { String s = ""100010001"" ; flip ( s ) ; } }","0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 ] ; Function call [/INST] \n class GFG { static void maxDecimal ( int [ ] arr , int n ) { int i = 0 ; int count = 0 ; int max = 0 ; while ( i < n ) { if ( arr [ i ] == 0 ) count ++ ; else { if ( count != 0 ) { max = Math . max ( max , count ) ; count = 0 ; } } i ++ ; } max = Math . max ( max , count ) ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = 1 ; j ++ ; } else { if ( j > 0 ) { arr [ i - j ] = 1 ; j = 0 ; } } } } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 1 ,",0.3257183446743763,0.17913535271871125,0.31163209911876877,0.19672131147540983,0.6153846153846154
52,"class GFG { static void getOrgString ( String s ) { System . out . print ( s . charAt ( 0 ) ) ; int i = 1 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) System . out . print ( "" ▁ "" + Character . toLowerCase ( s . charAt ( i ) ) ) ; else System . out . print ( s . charAt ( i ) ) ; i ++ ; } } public static void main ( String [ ] args ) { String s = "" ILoveGeeksForGeeks "" ; getOrgString ( s ) ; } }","] \n import java . io . * ; class GFG { static String convert ( String s ) { String ans = "" "" ; ans += s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Character . isUpperCase ( s . charAt ( i ) ) ) ans += ""   "" ; ans += Character . toLowerCase ( s . charAt ( i ) ) ; } return ans ; } public static void main ( String [ ] args ) { String str = "" GeeksForGeeks "" ; System . out . println ( convert ( str ) ) ; } } Â  1 | Java implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code [/INST] \n import java . io . * ; class GFG { static String convert ( String s ) { String ans = "" "" ; ans += s",0.43535860899514356,0.2945819490517576,0.4785985186748485,0.5873015873015873,0.38095238095238093
53,"import java . util . * ; import java . lang . * ; class GFG { static int countChar ( String str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) count ++ ; int repetitions = n / str . length ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = "" abcac "" ; System . out . println ( countChar ( str , ' a ' ) ) ; } }","] \n import java . io . * ; class GFG { static int countChar ( String s , int n , int k ) { int count = 0 ; int len = s . length ( ) ; while ( n > 0 ) { if ( n >= len ) count += ( n / len ) ; n %= len ; } return count ; } public static void main ( String [ ] args ) { String s = "" ab "" ; int n = 12 , k = 2 ; System . out . println ( countChar ( s , n , k ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------------------------",0.3272889271152323,0.32293217842789357,0.33622353003303546,0.4,0.25
54,"class GFG { static void countFreq ( int arr [ ] , int n , int limit ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( i + "" ▁ "" + count [ i ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = arr . length ; int limit = 10 ; countFreq ( arr , n , limit ) ; } }","] \n import java . io . * ; import java . util . * ; class GFG { static int countFrequencies ( int arr [ ] , int n , int limit ) { int freq [ ] = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int count = 0 ; for ( int i = 0 ; i <= limit ; i ++ ) if ( freq [ i ] > 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 } ; int n = arr . length ; int limit = 5 ; System . out . println ( countFrequencies ( arr , n , limit ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------------------------------------------",0.5441129908038886,0.611427251731996,0.7051042519166121,0.6986301369863014,0.16129032258064516
55,"import java . io . * ; class GFG { static boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } public static void main ( String [ ] args ) { String s = ""001001"" ; int m = 2 ; if ( check ( s , m ) ) System . out . println ( "" YES "" ) ; else System . out . println ( "" NO "" ) ; } }",] \n import java . io . * / * ; function that checks if the binary string contains m consecutive 1 ' s   or   0' s ; length of binary string ; count of 0 ' s ; count of 1 ' s ; count of consecutive 0 ' s ; count of consecutive 1 ' s ; if both 1 ' s   and   0' s   are   present ; if 1 ' s   are   present   but   not   consecutive ; if 0 ' s   are   present   but   not   consecutive ; Driver code [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [/ Driver code ] 1 ; function call [,0.08648361199867036,0.041597212062031555,0.04719437878979274,0.0,0.2571428571428571
56,"class GFG { static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; } public static void main ( String [ ] args ) { String tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" ; int k = 2 ; System . out . println ( productAtKthLevel ( tree , k ) ) ; } }","T] \n class GFG { static int product ( int n , int k ) { int res = 1 ; int level = 1 ; int i = 0 ; while ( true ) { if ( level == k ) { res = res * i ; level ++ ; } else { level -- ; i ++ ; } if ( level == 1 ) break ; } return res ; } public static void main ( String [ ] args ) { int n = 100 ; int k = 3 ; System . out . println ( product ( n , k ) ) ; } } 1 | Java program to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program [/INST] \n class GFG { static int product ( int n , int k ) { int res = 1 ; int level = 1 ; int i = 0 ; while ( true ) { if ( level == k ) { res = res * i ; level ++",0.35451159540678134,0.266894386330257,0.3360737591660006,0.47297297297297297,0.34210526315789475
57,"class GFG { static void findDuplciates ( String [ ] a , int n , int m ) { boolean [ ] [ ] isPresent = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { isPresent [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ k ] . charAt ( j ) && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ i ] . charAt ( k ) && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( isPresent [ i ] [ j ] == false ) System . out . print ( a [ i ] . charAt ( j ) ) ; } public static void main ( String [ ] args ) { int n = 2 , m = 2 ; String [ ] a = new String [ ] { "" zx "" , "" xz "" } ; findDuplciates ( a , n , m ) ; } }","] = { ' a ' , ' a ' , ' a ' , ' b ' , ' a ' , ' b ' , ' c ' , ' b ' , ' a ' , ' a ' } ; Function call [/INST] \n import java . util . * , * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * .",0.25111337755577257,0.0022141427952743387,0.0022393674278160117,0.0,0.0
58,"class GFG { static boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } public static void main ( String [ ] args ) { String isbn = ""007462542X "" ; if ( isValidISBN ( isbn ) ) System . out . print ( "" Valid "" ) ; else System . out . print ( "" Invalid "" ) ; } }","] \n import java . io . * ; class GFG { static boolean isValid ( String str ) { if ( str . length ( ) != 10 ) return false ; int sum = 0 , i ; for ( i = 0 ; i < 9 ; i ++ ) sum = sum + ( ( str . charAt ( i ) - '0' ) * ( 2 * i + 1 ) ) ; if ( str . charAt ( i ) == ' X ' ) sum = sum + 10 ; else sum = sum + ( str . charAt ( i ) - '0' ) ; return ( sum % 11 == 0 ) ; } public static void main ( String [ ] args ) { String str = ""9780131423954"" ; if ( isValid ( str ) ) System . out . println ( "" Valid "" ) ; else System . out . println ( "" Invalid "" ) ; } } -------------------------------- -------------------------------- [/INST] \n import java . io . * ; class GFG { static boolean isValid ( String str ) { if ( str . length ( ) != 1",0.47514755670967046,0.4543589318800639,0.47036479945155757,0.5368421052631579,0.43902439024390244
59,"class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } static String reverseVowel ( String str1 ) { int j = 0 ; char [ ] str = str1 . toCharArray ( ) ; String vowel = "" "" ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { j ++ ; vowel += str [ i ] ; } } for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { str [ i ] = vowel . charAt ( -- j ) ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = "" hello ▁ world "" ; System . out . println ( reverseVowel ( str ) ) ; } }","] import java . io . * ; import java . util . * ; class GFG { static boolean isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } static String reverseVowels ( String str ) { String vowels = "" "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) vowels += str . charAt ( i ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) str = str . substring ( 0 , i ) + vowels + str . substring ( i + 1 ) ; } return str ; } public static void main ( String [ ] args ) { String str = "" geeksforgeeks "" ; System . out . println ( reverseVowels ( str ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------",0.4810032771277818,0.48091507813884427,0.49026784169303766,0.5754716981132075,0.37735849056603776
60,"class GFG { static String firstLetterWord ( String str ) { String result = "" "" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) { v = true ; } else if ( str . charAt ( i ) != ' ▁ ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; } public static void main ( String [ ] args ) { String str = "" geeks ▁ for ▁ geeks "" ; System . out . println ( firstLetterWord ( str ) ) ; } }","] \n import java . io . * ; class GFG { static void findString ( String s ) { int n = s . length ( ) ; char [ ] output = new char [ n ] ; int i = 0 ; boolean v = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) == '   ' ) v = true ; else { if ( v == true ) { output [ i ++ ] = s . charAt ( j ) ; v = false ; } } } output [ i ] = ' \0' ; System . out . print ( String . valueOf ( output ) ) ; } public static void main ( String [ ] args ) { String s = "" geeks   for   geeks "" ; findString ( s ) ; } } ๐จ๐ปโ๐ฉ๐ปโ๐ง 2 ๐จ๐ปโ๐ฉ๐ปโ๐ง 1 ๐จ๐ปโ๐ฉ",0.42472638423390846,0.3567810947780036,0.43979469305368746,0.5967741935483871,0.3055555555555556
61,"import java . util . Arrays ; class GFG { static int ans = 0 ; static void dfs ( int i , int j , int [ ] [ ] grid , boolean [ ] [ ] vis , int z , int z_count ) { int n = grid . length , m = grid [ 0 ] . length ; vis [ i ] [ j ] = true ; if ( grid [ i ] [ j ] == 0 ) z ++ ; if ( grid [ i ] [ j ] == 2 ) { if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = false ; return ; } if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != - 1 ) dfs ( i - 1 , j , grid , vis , z , z_count ) ; if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != - 1 ) dfs ( i + 1 , j , grid , vis , z , z_count ) ; if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != - 1 ) dfs ( i , j - 1 , grid , vis , z , z_count ) ; if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != - 1 ) dfs ( i , j + 1 , grid , vis , z , z_count ) ; vis [ i ] [ j ] = false ; } static int uniquePaths ( int [ ] [ ] grid ) { int n = grid . length , m = grid [ 0 ] . length ; boolean [ ] [ ] vis = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( vis [ i ] , false ) ; } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] [ ] grid = { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , - 1 } } ; System . out . println ( uniquePaths ( grid ) ) ; } }","] \n import java . io . * ; class GFG { static int n , m ; static int dfs ( int i , int j , int [ ] [ ] vis , int [ ] [ ] ans , int z , int z_count , int z_count_total ) { vis [ i ] [ j ] = 1 ; z ++ ; if ( i == n - 1 && j == m - 1 ) { if ( z_count == z_count_total ) ans [ i ] [ j ] = 1 ; return 0 ; } if ( i > 0 && vis [ i - 1 ] [ j ] == 0 && ans [ i - 1 ] [ j ] == 0 ) { z_count ++ ; z = dfs ( i - 1 , j , vis , ans , z , z_count , z_count_total ) ; } if ( j > 0 && vis [ i ] [ j - 1 ] == 0 && ans [ i ] [ j - 1 ] == 0 ) { z_count ++ ; z = dfs ( i , j - 1 , vis , ans , z",0.23221554426058283,0.10379708271319694,0.2171068972184517,0.4092827004219409,0.1986754966887417
62,"import java . util . Arrays ; class GFG { static int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 3 , 6 } ; int n = a . length ; System . out . println ( numPairs ( a , n ) ) ; } }","] \n import java . util . * ; class GFG { static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { int left = 0 , right = i - 1 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] == arr [ i ] ) { ans += right - left ; left ++ ; right = i - 1 ; } else if ( arr [ left ] + arr [ right ] < arr [ i ] ) left ++ ; else right -- ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , 3 , - 3 , - 5 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } } 1 | Java program for the above approach ;",0.5332420960079016,0.4251275372028762,0.6527038605273605,0.6301369863013698,0.425
63,class GFG { static int areaOfSquare ( int S ) { int area = S * S ; return area ; } public static void main ( String [ ] args ) { int S = 5 ; System . out . println ( areaOfSquare ( S ) ) ; } },] \n import java . util . * ; class GFG { static double area ( int a ) { double area = a * a ; return area ; } public static void main ( String [ ] args ) { int a = 4 ; System . out . print ( area ( a ) ) ; } } ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣ ⁣,0.48029120123794666,0.17755727261323037,0.5371559194353305,0.8064516129032258,0.4
64,"class GFG { static int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } public static void main ( String [ ] args ) { int x = 3 ; int y = 4 ; System . out . print ( maxPointOfIntersection ( x , y ) ) ; } }","] \n import java . util . * ; class GFG { static void maxIntersections ( int x , int y ) { System . out . println ( ( x * y ) ) ; } public static void main ( String [ ] args ) { int x = 5 , y = 10 ; maxIntersections ( x , y ) ; } } đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2 / 4 đź¤Ż Â  Â  2",0.4391842526910645,0.2824884800677752,0.4400209636289526,0.425531914893617,0.6086956521739131
65,"class GFG { static int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Icosihenagonal_num ( n ) + ""NEW_LINE""); n = 10 ; System . out . print ( Icosihenagonal_num ( n ) + ""NEW_LINE""); } }","] \n import java . io . * ; class GFG { static int icosihenagonalNum ( int n ) { return ( 24 * n * n - 23 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( ""5th   Icosihenagonal   Number   is   :   "" + icosihenagonalNum ( n ) ) ; } } ~~~~ 1 2 6 14 26 42 62 86 114 146 182 222 266 314 366 422 482 546 614 686 762 842 926 1014 1106 1202 1302 1406 1514 1626 1742 1862 1986 2114 2246 2382 ",0.509840909905505,0.3511938985971859,0.5478188638318515,0.6666666666666666,0.47368421052631576
66,"class GFG { static double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; } public static void main ( String [ ] args ) { double vp [ ] [ ] = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; double [ ] ans = find_Centroid ( vp ) ; System . out . println ( ans [ 0 ] + "" ▁ "" + ans [ 1 ] ) ; } }","] \n class GFG { static double A , x , y ; static void findCentroid ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double A = ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ; x = A * ( ( x1 + x2 + x3 ) ) / 6.0 ; y = A * ( ( y1 + y2 + y3 ) ) / 6.0 ; System . out . println ( "" Centroid   of   the   triangle   is   ( "" + x + "" ,   "" + y + "" ) "" ) ; } public static void main ( String [ ] args ) { double x1 = 0 , y1 = 0 ; double x2 = 1 , y2 = 1 ; double x3 = 1 , y3 = 0 ; findCentroid ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } }    ",0.2176337524856205,0.1469063398411392,0.1653138570759297,0.26717557251908397,0.2911392405063291
67,"import java . io . * ; class GFG { public static void main ( String [ ] args ) { int d = 10 ; double a ; a = ( double ) ( 360 - ( 6 * d ) ) / 4 ; System . out . print ( a + "" , ▁ "" + ( a + d ) + "" , ▁ "" + ( a + ( 2 * d ) ) + "" , ▁ "" + ( a + ( 3 * d ) ) ) ; } }","T] \n import java . io . * ; class GFG { public static void main ( String [ ] args ) { double a = 20 , b = 10 , c = 30 , d = 50 ; System . out . println ( "" a   =   "" + ( 180 - ( a + b + c + d ) ) ; System . out . println ( "" b   =   "" + ( 180 - ( a + b + c + d ) ) ; System . out . println ( "" c   =   "" + ( 180 - ( a + b + c + d ) ) ; System . out . println ( "" d   =   "" + ( 180 - ( a + b + c + d ) ) ; } } 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1 / 0 ; 1",0.4289577108836953,0.23613578110753894,0.45070955518086536,0.3333333333333333,0.6956521739130435
68,"import java . io . * ; import java . lang . Math ; class GFG { static void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( "" Perpendicular ▁ distance ▁ is ▁ "" + d ) ; } else System . out . println ( "" Planes ▁ are ▁ not ▁ parallel "" ) ; } public static void main ( String [ ] args ) { float a1 = 1 ; float b1 = 2 ; float c1 = - 1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = - 3 ; float d2 = - 4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; } }","] \n class GFG { static double distance ( double a , double b , double c , double d1 , double d2 ) { return ( Math . abs ( a * d1 + b * d2 + c ) / Math . sqrt ( a * a + b * b ) ) ; } public static void main ( String [ ] args ) { double a = 1 , b = 1 , c = 1 , d1 = 2 , d2 = 3 ; System . out . println ( distance ( a , b , c , d1 , d2 ) ) ; } } ๐ View the Code [/INST] \n class GFG { static double distance ( double a , double b , double c , double d1 , double d2 ) { return ( Math . abs ( a * d1 + b * d2 + c ) / Math . sqrt ( a * a + b * b ) ) ; } public static void main ( String [ ] args ) { double a = 1 , b = 1 , c = 1 , d1 = 2 , d2 = 3 ; System . out . println ( distance (",0.3085506866277909,0.20988935840423936,0.20048908636426488,0.4576271186440678,0.36619718309859156
69,import java . io . * ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static long numOfNecklace ( int N ) { long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( numOfNecklace ( N ) ) ; } },] \n import java . io . * ; class GFG { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countWays ( int N ) { int ans = fact ( N ) ; ans = ans / fact ( N / 2 ) ; ans = ans / 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( countWays ( N ) ) ; } } ---------------- LRUN ---------------- import java . io . * ; class GFG { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countWays ( int N ) { int ans = fact ( N ) ; ans = ans / fact ( N / 2 ) ; ans = ans / 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( countW,0.4306361935071873,0.3118191473527616,0.527684691003473,0.6052631578947368,0.2777777777777778
70,"import java . lang . * ; import java . util . * ; class GFG { static String isDivisibleByDivisor ( int S , int D ) { S %= D ; Set < Integer > hashMap = new HashSet < > ( ) ; hashMap . add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . contains ( S ) ) { if ( S == 0 ) { return "" Yes "" ; } return "" No "" ; } else hashMap . add ( S ) ; } return "" Yes "" ; } public static void main ( String [ ] args ) { int S = 3 , D = 6 ; System . out . println ( isDivisibleByDivisor ( S , D ) ) ; } }","] \n import java . util . * ; class GFG { static void check ( int S , int D ) { int v [ ] = new int [ 100000 ] ; int i = 0 ; v [ i ] = S % D ; HashSet < Integer > s = new HashSet < > ( ) ; s . add ( S % D ) ; while ( true ) { i ++ ; v [ i ] = ( v [ i - 1 ] + v [ i - 1 ] % D ) % D ; if ( s . contains ( v [ i ] ) ) { System . out . print ( "" No "" ) ; return ; } s . add ( v [ i ] ) ; } } public static void main ( String [ ] args ) { int S = 2 , D = 3 ; check ( S , D ) ; } } 1 | Java program for the above approach ; Function to check if S is divisible by D while changing S to ( S + S % D ) ; Stores the encountered values ; Stores the encountered values ; Check if the value has already been encountered ; Edge Case ; Otherwise , insert it into the hash",0.419191818808272,0.3091383651274987,0.4489475914242708,0.46153846153846156,0.45714285714285713
71,"import java . util . * ; class GFG { static void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; System . out . println ( cnt ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; } }","] \n import java . io . * ; class GFG { static void countSteps ( int x , int y ) { int count = 0 ; while ( x != 1 y != 1 ) { if ( x > y ) { count += x - y ; x -= y ; } else { count += y - x ; y -= x ; } } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 5 ; countSteps ( x , y ) ; } } ३० २० १९ १८ १७ १६ १५ १४ १३ १२ ११ १० ९ ८ ७ ६ ५ ४ ३ २ १ ० १",0.6503280200827449,0.5191670630420009,0.5584707748647364,0.7424242424242424,0.78125
72,"import java . util . Stack ; class GFG { static boolean check ( int A [ ] , int N ) { Stack < Integer > S = new Stack < Integer > ( ) ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . peek ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . peek ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . peek ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = A . length ; if ( check ( A , N ) ) { System . out . println ( "" YES "" ) ; } else { System . out . println ( "" NO "" ) ; } } }","] \n import java . util . * ; class GFG { static void isStackSortable ( int [ ] A , int N ) { Stack < Integer > S = new Stack < > ( ) ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . isEmpty ( ) ) { int top = S . peek ( ) ; if ( top == B_end + 1 ) { S . pop ( ) ; B_end ++ ; } else if ( top == A [ i ] ) { S . pop ( ) ; B_end ++ ; } else { S . push ( A [ i ] ) ; break ; } } else { if ( A [ i ] == B_end + 1 ) { B_end ++ ; } else { S . push ( A [ i ] ) ; break ; } } } if ( S . isEmpty ( ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 3 ,",0.5182350889720473,0.5700782204009812,0.5838393180268905,0.6015625,0.31746031746031744
73,"import java . util . Stack ; public class GFG { static int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == ' } ' && ! s . empty ( ) ) { if ( s . peek ( ) == ' { ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } public static void main ( String [ ] args ) { String expr = "" } } { { "" ; System . out . println ( countMinReversals ( expr ) ) ; } }","] \n public class Test { static int countMinimumReversals ( String str ) { int n = str . length ( ) ; if ( n % 2 == 1 ) return - 1 ; int m = 0 , n = 0 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' { ' ) s . add ( ' { ' ) ; else if ( str . charAt ( i ) == ' } ' ) s . add ( ' } ' ) ; else if ( str . charAt ( i ) == ' { ' ) m ++ ; else n ++ ; } int red_len = m + n ; int open = 0 ; while ( ! s . isEmpty ( ) ) { char c = s . peek ( ) ; if ( c == ' { ' ) open ++ ; else if ( c == ' } ' ) open -- ; s . pop ( ) ; } return ( m + n ) / 2 + open % 2 ; } public static void main (",0.49570919778028955,0.48217347388830245,0.4915724081419464,0.6090909090909091,0.4
74,"import java . util . * ; public class GFG { static int countMinReversals ( String expr ) { int len = expr . length ( ) ; int ans ; if ( len % 2 != 0 ) { return - 1 ; } int left_brace = 0 , right_brace = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = expr . charAt ( i ) ; if ( ch == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ( int ) ( Math . ceil ( ( 0.0 + left_brace ) / 2 ) + Math . ceil ( ( 0.0 + right_brace ) / 2 ) ) ; return ans ; } public static void main ( String [ ] args ) { String expr = "" } } { { "" ; System . out . println ( countMinReversals ( expr ) ) ; } }","] \n import java . util . * ; class GFG { static int countMinimumReversal ( String s ) { int n = s . length ( ) ; if ( n % 2 != 0 ) return - 1 ; int left = 0 , right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) left ++ ; else if ( left > 0 ) { left -- ; right ++ ; } else if ( left == 0 && right > 0 ) right -- ; } if ( left == 0 && right == 0 ) return 0 ; return - 1 ; } public static void main ( String [ ] args ) { String s = "" ( ( ) ) ( ) "" ; System . out . println ( countMinimumReversal ( s ) ) ; } } फ़िंद इंदीयांक के लिए गेस्ट फॉर्ड ग्रुप में शामिल है",0.5282687195215754,0.41276831145179077,0.41966140534418833,0.5806451612903226,0.7
75,"class GFG { static void PrintMinNumberForPattern ( String arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case ' I ' : j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; System . out . print ( "" ▁ "" + ++ last_entry ) ; System . out . print ( "" ▁ "" + curr_max ) ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; System . out . print ( "" ▁ "" + last_entry ) ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( "" ▁ "" + -- last_entry ) ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; System . out . print ( "" ▁ "" + curr_max + "" ▁ "" + ( curr_max - 1 ) ) ; last_entry = curr_max - 1 ; } else { System . out . print ( "" ▁ "" + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } System . out . println ( ) ; } public static void main ( String [ ] args ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; } }",= 1 ; 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. ,0.25026638913321186,4.625363537699054e-05,0.0010193028974705574,0.0,0.0
76,"import java . io . * ; import java . util . * ; public class GFG { static void printLeast ( String arr ) { int min_avail = 1 , pos_of_I = 0 ; ArrayList < Integer > al = new ArrayList < > ( ) ; if ( arr . charAt ( 0 ) == ' I ' ) { al . add ( 1 ) ; al . add ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { al . add ( 2 ) ; al . add ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr . charAt ( i ) == ' I ' ) { al . add ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { al . add ( al . get ( i ) ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) al . set ( j , al . get ( j ) + 1 ) ; min_avail ++ ; } } for ( int i = 0 ; i < al . size ( ) ; i ++ ) System . out . print ( al . get ( i ) + "" ▁ "" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { printLeast ( "" IDID "" ) ; printLeast ( "" I "" ) ; printLeast ( "" DD "" ) ; printLeast ( "" II "" ) ; printLeast ( "" DIDI "" ) ; printLeast ( "" IIDDD "" ) ; printLeast ( "" DDIDDIID "" ) ; } }","T ] \n import java . io . * ; import java . util . * ; class GFG { static void minNum ( String s ) { int n = s . length ( ) ; int min_avail = 0 ; int pos_of_I = - 1 ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' D ' ) { if ( min_avail > 0 ) { ans . add ( min_avail ) ; min_avail -- ; } else { ans . add ( pos_of_I + 1 ) ; pos_of_I = i ; } } ans . add ( min_avail ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) ) ; } public static void main ( String [ ] args ) { String s = "" IDDID "" ; minNum ( s ) ; } } 1234567891011121",0.3192467153111581,0.268442598939372,0.3255029344487761,0.41721854304635764,0.26582278481012656
77,"import java . util . Stack ; class GFG { static void PrintMinNumberForPattern ( String seq ) { String result = "" "" ; Stack < Integer > stk = new Stack < Integer > ( ) ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) { while ( ! stk . empty ( ) ) { result += String . valueOf ( stk . peek ( ) ) ; result += "" ▁ "" ; stk . pop ( ) ; } } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; } }","T ] \n class GFG { static void decode ( String input ) { String result = "" "" ; Stack < Integer > stack = new Stack < Integer > ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { stack . push ( i + 1 ) ; if ( input . charAt ( i ) == ' D ' || stack . empty ( ) ) { while ( ! stack . empty ( ) ) { result += stack . peek ( ) + "" "" ; stack . pop ( ) ; } } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { String input = "" IDIDD "" ; decode ( input ) ; } } 1",0.49338124829317165,0.47191187575994853,0.503765197757071,0.5588235294117647,0.43902439024390244
78,"import java . io . IOException ; public class Test { static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return "" - 1"" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; } public static void main ( String [ ] args ) throws IOException { String inputs [ ] = { "" IDID "" , "" I "" , "" DD "" , "" II "" , "" DIDI "" , "" IIDDD "" , "" DDIDDIID "" } ; for ( String input : inputs ) { System . out . println ( getMinNumberForPattern ( input ) ) ; } } }","] \n import java . io . * ; class GFG { static int minimumNumber ( String str ) { int rank = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str . charAt ( i ) == str . charAt ( j ) && i != j ) { rank ++ ; } } } return rank ; } public static void main ( String [ ] args ) { String str = ""123456789"" ; System . out . println ( minimumNumber ( str ) ) ; } } đź¤ť 1 / 1 ( 1 ) 1 / 1 ( 2 ) 1 / 1 ( 3 ) 1 / 1 ( 4 ) 1 / 1 ( 5 ) 1 / 1 ( 6 ) 1 / 1 ( 7 ) 1 / 1 ( 8 ) 1 / 1 ( 9 ) 1 / 1 ( 10 ) 1 / 1 ( 11 ) ",0.3019005515298776,0.2870193619150923,0.2916520265943552,0.46226415094339623,0.16666666666666666
79,"import java . io . * ; class SmallPrime { static boolean isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) { return true ; } else { return false ; } } static void findMinNum ( int arr [ ] , int n ) { int first = 0 , last = 0 , num , rev , i ; int hash [ ] = new int [ 10 ] ; for ( i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } System . out . print ( "" Minimum ▁ number : ▁ "" ) ; for ( i = 0 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } System . out . println ( ) ; System . out . println ( ) ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } } for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ; System . out . print ( "" Prime ▁ combinations : ▁ "" ) ; if ( isPrime ( num ) && isPrime ( rev ) ) { System . out . println ( num + "" ▁ "" + rev ) ; } else if ( isPrime ( num ) ) { System . out . println ( num ) ; } else if ( isPrime ( rev ) ) { System . out . println ( rev ) ; } else { System . out . println ( "" No ▁ combinations ▁ exist "" ) ; } } public static void main ( String [ ] args ) { SmallPrime smallprime = new SmallPrime ( ) ; int arr [ ] = { 1 , 2 , 4 , 7 , 8 } ; smallprime . findMinNum ( arr , 5 ) ; } }","public class GFG { static boolean isPrime ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void smallestPossible ( int [ ] arr ) { int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) hash [ arr [ i ] ] ++ ; String str = "" "" ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { str += Integer . toString ( i ) ; } } int first = Integer . parseInt ( str . substring ( 0 , 1 ) ) ; int last = Integer . parseInt ( str . substring ( str . length ( ) - 1 , str . length ( ) ) ) ; if ( isPrime ( first ) && isPrime ( last ) ) System . out . print ( str + ""NEW_LINE""); } public static void",0.2424821841558274,0.18619627936027097,0.2606111825737246,0.44041450777202074,0.08270676691729323
80,"class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static boolean coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; } static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) { if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } } if ( flag == true ) { System . out . println ( "" ( "" + possibleA + "" , ▁ "" + possibleB + "" , ▁ "" + possibleC + "" ) "" + "" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ "" + "" between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } else { System . out . println ( "" No ▁ Such ▁ Triplet ▁ exists "" + "" between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }","] \n import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static boolean coprime ( int a , int b ) { return gcd ( a , b ) == 1 ; } static boolean check ( int L , int R ) { for ( int a = L ; a <= R ; a ++ ) for ( int b = a + 1 ; b <= R ; b ++ ) for ( int c = b + 1 ; c <= R ; c ++ ) if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { return true ; } return false ; } public static void main ( String [ ] args ) { int L = 2 , R = 10 ; if ( check ( L , R ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; L = 23 ; R = 46 ; if (",0.48358267253242004,0.4333976181667874,0.4986011636846186,0.5806451612903226,0.42168674698795183
81,"class GFG { static boolean possibleToReach ( int a , int b ) { int c = ( int ) Math . cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) System . out . println ( "" yes "" ) ; else System . out . println ( "" no "" ) ; } }","] \n import java . io . * ; class GFG { static boolean isPossible ( int A , int B , int K ) { int cuberoot = ( int ) Math . cbrt ( A * B ) ; if ( A % cuberoot == 0 && B % cuberoot == 0 ) { if ( A / cuberoot == B / cuberoot ) return true ; } return false ; } public static void main ( String [ ] args ) { int A = 10 , B = 25 , K = 2 ; if ( isPossible ( A , B , K ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” đź¤” ",0.536891924175213,0.40284200747885746,0.48955327542889104,0.6,0.6551724137931034
82,"import java . util . * ; class GFG { public static boolean isUndulating ( String n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) return false ; return true ; } public static void main ( String [ ] args ) { String n = ""1212121"" ; if ( isUndulating ( n ) == true ) System . out . println ( "" yes "" ) ; else System . out . println ( "" no "" ) ; } }","] class GFG { static boolean isUndulating ( int n ) { int x = n % 10 ; n /= 10 ; int y = n % 10 ; n /= 10 ; int z = n % 10 ; return ( x == y && y == z ) ; } public static void main ( String [ ] args ) { int n = 123456 ; if ( isUndulating ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ३ ",0.44038644332191756,0.34541307395067566,0.36613269933699455,0.4,0.65
83,import java . io . * ; class GFG { static int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } public static void main ( String [ ] args ) { int n = 3 ; int res = Series ( n ) ; System . out . println ( res ) ; } },] \n import java . io . * ; class GFG { static int sum ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( sum ( n ) ) ; } } **** * Note : * This program gives the sum of the series 1 * 1 + 2 * 2 + 3 * 3 + ... + n * n ; Driver Code [/INST] \n import java . io . * ; class GFG { static int sum ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( sum ( n ) ) ; } } **** * Note : * This program gives the sum of the series 1 * 1 + 2 * 2 + 3 * 3 + ... + n * n ; Driver Code [/INST] \n import java,0.4449143880846038,0.1963682882692139,0.5037819852338149,0.5531914893617021,0.5263157894736842
84,"import java . util . * ; import java . lang . * ; public class GfG { public static int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * ( int ) Math . ceil ( low / 10.0 ) ; int mhigh = 10 * ( int ) Math . floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; } public static void main ( String argc [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }","] \n import java . io . * ; class GFG { static int countNumbers ( int n , int k ) { return ( n / 10 + 1 ) * k ; } public static void main ( String [ ] args ) { int n = 100 , k = 5 ; System . out . println ( countNumbers ( n , k ) ) ; } } ~~~~ \n import java . io . * ; class GFG { static int countNumbers ( int n , int k ) { return ( n / 10 + 1 ) * k ; } public static void main ( String [ ] args ) { int n = 100 , k = 5 ; System . out . println ( countNumbers ( n , k ) ) ; } } ~~~~ \n import java . io . * ; class GFG { static int countNumbers ( int n , int k ) { return ( n / 10 + 1 ) * k ; } public static void main ( String [ ] args ) { int n = 100 , k = 5 ; System . out . println ( countNumbers ( n ,",0.345823691074168,0.17984921473518595,0.24964808120705576,0.3037974683544304,0.65
85,"import java . io . * ; class GFG { static int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } public static void main ( String [ ] args ) { int L = 1 , R = 20 ; System . out . println ( sum ( L , R ) ) ; } }","] \n import java . io . * ; class GFG { static int sumOfDivBy6 ( int l , int r ) { int count = ( r / 6 ) ; int count1 = ( l - 1 ) / 6 ; int sum = ( count * ( count + 1 ) * 6 ) / 2 ; int sum1 = ( count1 * ( count1 + 1 ) * 6 ) / 2 ; return ( sum - sum1 ) ; } public static void main ( String [ ] args ) { int l = 1 , r = 100 ; System . out . println ( sumOfDivBy6 ( l , r ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ",0.5959697869054317,0.36466459705695625,0.47381225171419583,0.6833333333333333,0.8620689655172413
86,"class GFG { static String prevNum ( String str ) { int len = str . length ( ) ; int index = - 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) > str . charAt ( i + 1 ) ) { index = i ; break ; } } int smallGreatDgt = - 1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str . charAt ( i ) < str . charAt ( index ) ) { if ( smallGreatDgt == - 1 ) { smallGreatDgt = i ; } else if ( str . charAt ( i ) >= str . charAt ( smallGreatDgt ) ) { smallGreatDgt = i ; } } } if ( index == - 1 ) { return "" - 1"" ; } if ( smallGreatDgt != - 1 ) { str = swap ( str , index , smallGreatDgt ) ; return str ; } return "" - 1"" ; } static String swap ( String str , int i , int j ) { char ch [ ] = str . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; } public static void main ( String [ ] args ) { String str = ""34125"" ; System . out . println ( prevNum ( str ) ) ; } }",3456789987654321000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
87,"class GFG { static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; } static int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; } public static void main ( String [ ] args ) { int poly [ ] = { 2 , - 6 , 2 , - 1 } ; int x = 3 ; int n = poly . length ; System . out . print ( "" Sign ▁ of ▁ polynomial ▁ is ▁ "" + findSign ( poly , n , x ) ) ; } }","] \n import java . io . * ; class GFG { static int evaluate ( int poly [ ] , int n , int x ) { int res = poly [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) res = res * x + poly [ i ] ; return res ; } static int signValue ( int poly [ ] , int n ) { int x = evaluate ( poly , n , - 1 ) ; if ( x == 0 ) return 0 ; else if ( x > 0 ) return 1 ; else return - 1 ; } public static void main ( String [ ] args ) { int poly [ ] = { 2 , - 6 , 2 , - 1 } ; int n = poly . length ; System . out . println ( signValue ( poly , n ) ) ; } } ------------------------------------------------------------------------------------------------------------------------------------------------ 2 x3 - 6 x2 + 2 x - 1 for x = 3 = 2 * 33 - 6 * 9 + 2 * 3 - 1 = 126 - 5",0.6275733104529461,0.5332934019006749,0.6218274261180059,0.6551724137931034,0.7
88,"class GFG { static int MAX = 100005 ; static boolean [ ] isPrime = new boolean [ MAX ] ; static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }","] \n import java . io . * ; class GFG { static int MAX = 1000000 ; static int [ ] primes = new int [ MAX + 1 ] ; static void sieveOfEratostheneses ( ) { primes [ 0 ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) primes [ i ] = 2 ; for ( int i = 3 ; i * i <= MAX ; i += 2 ) { if ( primes [ i ] == i ) { for ( int j = i * i ; j <= MAX ; j += 2 * i ) primes [ j ] = i ; } } } static int findPrimeGreater ( int n ) { int num = n ; while ( true ) { if ( primes [ num ] == num ) return num ; num ++ ; } } static int findNumToBeAdded ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [",0.42458165120581515,0.4113187713181885,0.42850151043182,0.4645669291338583,0.3939393939393939
89,"class GFG { public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( "" Sum ▁ of ▁ SubArray ▁ : ▁ "" + SubArraySum ( arr , n ) ) ; } }","] \n import java . util . * ; class GFG { static int sumSubarrays ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( sumSubarrays ( arr , n ) ) ; } } -------------------------------------------------------------------------------- 1 / 2 This is a Java program to compute sum of all subarray elements . ; Computes sum of all subarray elements ; Driver program [/INST] \n class GFG { static int sumSubarrays ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; } } return",0.552878458670057,0.44457545811068283,0.7067142869336908,0.6190476190476191,0.4411764705882353
90,"import java . io . * ; class GFG { static int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }",] \n class GFG { static int highestPowerOf2 ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerOf2 ( n ) ) ; } } đźŚŻ1/2,0.637439083641196,0.6294425672473714,0.6536471006507457,0.6666666666666666,0.6
91,"import java . io . * ; import java . util . * ; class KeyComparator implements Comparator < Key > { public int compare ( Key k1 , Key k2 ) { if ( k1 . freq < k2 . freq ) return 1 ; else if ( k1 . freq > k2 . freq ) return - 1 ; return 0 ; } } class Key { int freq ; char ch ; Key ( int val , char c ) { freq = val ; ch = c ; } } class GFG { static int MAX_CHAR = 26 ; static void rearrangeString ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ; PriorityQueue < Key > pq = new PriorityQueue < > ( new KeyComparator ( ) ) ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] > 0 ) pq . add ( new Key ( count [ val ] , c ) ) ; } str = "" "" ; Key prev = new Key ( - 1 , ' # ' ) ; while ( pq . size ( ) != 0 ) { Key k = pq . peek ( ) ; pq . poll ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . add ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) System . out . println ( "" ▁ Not ▁ valid ▁ String ▁ "" ) ; else System . out . println ( str ) ; } public static void main ( String args [ ] ) { String str = "" bbbaa "" ; rearrangeString ( str ) ; } }","] class GFG { static class Pair implements Comparable < Pair > { char ch ; int freq ; Pair ( char ch , int freq ) { this . ch = ch ; this . freq = freq ; } @ Override public int compareTo ( Pair p ) { return this . freq - p . freq ; } } static String rearrangeString ( String str ) { PriorityQueue < Pair > pq = new PriorityQueue < > ( ) ; int n = str . length ( ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { pq . add ( new Pair ( str . charAt ( i ) , 1 ) ) ; } String str1 = "" "" ; char prev = ' # ' ; prev -- ; while ( pq . size ( ) > 0 ) { Pair p = pq . poll ( ) ; str1 += p . ch ; if ( prev == p . ch ) continue ; else if ( prev != ' # ' ) str1 += prev ; prev = p . ch ; p . freq -- ; if ( p . freq",0.29026173562209123,0.1919441236842216,0.23855361971947528,0.4673913043478261,0.2631578947368421
92,"public class GFG { static int aModM ( String s , int mod ) { int number = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { number = ( number * 10 ) ; int x = Character . getNumericValue ( s . charAt ( i ) ) ; number = number + x ; number %= mod ; } return number ; } static int ApowBmodM ( String a , int b , int m ) { int ans = aModM ( a , m ) ; int mul = ans ; for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; } public static void main ( String args [ ] ) { String a = ""987584345091051645734583954832576"" ; int b = 3 , m = 11 ; System . out . println ( ApowBmodM ( a , b , m ) ) ; } }","] \n import java . io . * ; class GFG { static int mod = 1000000007 ; static int modulo ( int a , int m ) { return ( a % m + m ) % m ; } static int power ( int a , int b , int m ) { int ans = 1 ; a = modulo ( a , m ) ; while ( b > 0 ) { if ( ( b & 1 ) != 0 ) ans = ( ans * a ) % m ; a = ( a * a ) % m ; b >>= 1 ; } return ans ; } public static void main ( String [ ] args ) { int a = 1000000007 ; int b = 2 ; int m = 1000000007 ; System . out . println ( power ( a , b , m ) ) ; } } 1000000007 ; 2 ; 1000000007 ; 1000000007 ; 100000",0.3695295199542426,0.3756439870819499,0.38382329908422697,0.5222222222222223,0.19642857142857142
93,"import java . util . * ; class GFG { static class Data { int x , y ; public Data ( int x , int y ) { super ( ) ; this . x = x ; this . y = y ; } } ; static double interpolate ( Data f [ ] , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } public static void main ( String [ ] args ) { Data f [ ] = { new Data ( 0 , 2 ) , new Data ( 1 , 3 ) , new Data ( 2 , 12 ) , new Data ( 5 , 147 ) } ; System . out . print ( "" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ "" + ( int ) interpolate ( f , 3 , 4 ) ) ; } }","] \n import java . util . * ; class GFG { static class Point { int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } } static int interpolate ( Point data [ ] , int n , int xi ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int term = data [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) term *= ( xi - data [ j ] . x ) ; } result += term ; } return result ; } public static void main ( String [ ] args ) { Point data [ ] = { new Point ( 0 , 1 ) , new Point ( 1 , 2 ) , new Point ( 2 , 3 ) , new Point ( 3 , 4 ) } ; int xi = 3 ; int result = interpolate ( data , 4 , xi ) ; System . out . println ( result ) ; } } đź¤” [/INST] \n ",0.5969730242670398,0.5581767728099404,0.5686639503036188,0.6481481481481481,0.6129032258064516
94,"import java . util . Arrays ; class GFG { static int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; boolean marked [ ] = new boolean [ nNew + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + "" ▁ "" ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + "" ▁ "" ) ; return - 1 ; } public static void main ( String [ ] args ) { int n = 20 ; SieveOfSundaram ( n ) ; } }","] \n import java . util . * ; class GFG { static void printPrimes ( int n ) { n -- ; int mark [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) mark [ i ] = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { for ( int j = i * i ; j <= n ; j += i ) mark [ j ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) if ( mark [ i ] == 0 ) System . out . print ( i + ""   "" ) ; } public static void main ( String [ ] args ) { int n = 100 ; printPrimes ( n ) ; } } ficaf1234567890 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",0.3838476641829281,0.3646259900577396,0.43029899023880636,0.4574468085106383,0.2830188679245283
95,"class GFG { static void constructArray ( int A [ ] , int N , int K ) { int B [ ] = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = A . length ; constructArray ( A , N , K ) ; } }","] \n import java . io . * ; class GFG { static void originalArray ( int [ ] A , int N , int K ) { int [ ] B = new int [ N ] ; int X = 0 ; for ( int i = 0 ; i < N ; i ++ ) { X ^= A [ i ] ; B [ i ] = K ^ X ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + ""   "" ) ; } } public static void main ( String [ ] args ) { int [ ] A = { 4 , 2 , 1 , 3 , 5 } ; int N = A . length ; int K = 7 ; originalArray ( A , N , K ) ; } } 1 2 3 4 5 ; 7 ^ 4 = 3 ; 3 ^ 2 = 1 ; 1 ^ 1 = 0 ; 0 ^ 5 = 5 ; 5 ^ 3 = 2 ; 2 ^ 4 = 6 ; 6 ^ 1 = 7",0.5650807295379114,0.49409068318939986,0.6987328993257858,0.6901408450704225,0.37735849056603776
96,"class GFG { static int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = A . length ; System . out . println ( extraElement ( A , B , n ) ) ; } }","Function call [/INST] \n class GFG { static int findExtra ( int A [ ] , int B [ ] , int n ) { int XOR_A = 0 , XOR_B = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR_A ^= A [ i ] ; XOR_B ^= B [ i ] ; } return XOR_A ^ XOR_B ; } 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ",0.387514857134204,0.33118676640933387,0.3400847833396037,0.5454545454545454,0.3333333333333333
97,"class GFG { static int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } public static void main ( String [ ] args ) { int n1 = 9 , n2 = 14 ; System . out . println ( hammingDistance ( n1 , n2 ) ) ; } }","T] \n class GFG { static int hammingDistance ( int a , int b ) { int count = 0 ; while ( a > 0 && b > 0 ) { if ( ( a & 1 ) ++ count ; a = a >> 1 ; if ( ( b & 1 ) ++ count ; b = b >> 1 ; } return count ; } public static void main ( String [ ] args ) { int a = 10 , b = 15 ; System . out . println ( hammingDistance ( a , b ) ) ; } } 1 00000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 ",0.5214437754432669,0.35375821181348294,0.5146255856117585,0.717391304347826,0.5
98,"class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) System . out . print ( i + "" ▁ "" ) ; } public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }",] \n import java . io . * ; class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) System . out . println ( Integer . toBinaryString ( i ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; printSubsets ( n ) ; } } ~\n import java . io . * ; class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) System . out . println ( Integer . toBinaryString ( i ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; printSubsets ( n ) ; } } ~\n import java . io . * ; class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) System . out . println ( Integer . toBinaryString ( i ) ) ; } public static void main ( String [ ] args,0.5304895661525204,0.22759661419841973,0.683200262779686,0.5641025641025641,0.6470588235294118
99,class GFG { static int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return 1 << k ; } public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } },] \n import java . util . * ; class GFG { static int findMSB ( int n ) { int k = 0 ; while ( n != 0 ) { n = n >> 1 ; k ++ ; } return ( 1 << ( k - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( findMSB ( n ) ) ; } } ../../.. 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 10110010,0.46029965176844745,0.32872390864919315,0.4861589089509125,0.5263157894736842,0.5
100,"import java . util . * ; import java . lang . * ; public class GfG { public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }","] class GFG { static int countSubsets ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 4 } ; int n = arr . length ; System . out . println ( countSubsets ( arr , n ) ) ; } }                                                                   ",0.39666299607890243,0.4045006477319013,0.41357990801227984,0.5066666666666667,0.2619047619047619
101,"import java . util . HashMap ; import java . util . Map ; class GFG { static int subset ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( subset ( arr , n ) ) ; } }","] \n import java . util . * ; class GFG { static int countSubsets ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int max_val = 0 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( max_val < it . getValue ( ) ) max_val = it . getValue ( ) ; } return ( int ) Math . pow ( 2 , max_val ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 } ; int n = arr . length ; System . out . print ( countSubsets ( arr , n ) ) ; } } orszag { } ",0.5729362390806574,0.6001672320336082,0.6955459782572752,0.6071428571428571,0.3888888888888889
102,"import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static ArrayList < Integer > psquare = new ArrayList < > ( ) ; static void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . add ( i * i ) ; } static int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - psquare . get ( index ) ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; } public static void main ( String [ ] args ) { int N = 9 ; calcPsquare ( N ) ; System . out . print ( countWays ( psquare . size ( ) - 1 , N ) ) ; } }",] \n import java . util . * ; class GFG { static int N = 100000 ; static int [ ] perfectSquares = new int [ N + 1 ] ; static void calculatePerfectSquares ( ) { for ( int i = 1 ; i <= N ; i ++ ) { perfectSquares [ i ] = i * i ; } } static int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 1 ; if ( perfectSquares [ n ] == n ) return 1 ; int include = countWays ( n - perfectSquares [ n ] ) ; int exclude = countWays ( n ) ; return include + exclude ; } public static void main ( String [ ] args ) { int n = 5 ; calculatePerfectSquares ( ) ; System . out . print ( countWays ( n ) ) ; } } ？ lang = java,0.3817347645291582,0.40092797367522914,0.4157838117141311,0.4375,0.2727272727272727
103,"import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static class TreeNode { int data , size ; TreeNode left ; TreeNode right ; } ; static TreeNode newNode ( int data ) { TreeNode Node = new TreeNode ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static pair sumofsubtree ( TreeNode root ) { pair p = new pair ( 1 , 0 ) ; if ( root . left != null ) { pair ptemp = sumofsubtree ( root . left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root . right != null ) { pair ptemp = sumofsubtree ( root . right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root . size = p . first ; return p ; } static int sum = 0 ; static void distance ( TreeNode root , int target , int distancesum , int n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { int tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { int tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } } public static void main ( String [ ] args ) { TreeNode root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 7 ) ; root . left . left . left = newNode ( 8 ) ; root . left . left . right = newNode ( 9 ) ; int target = 3 ; pair p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; System . out . print ( sum + ""NEW_LINE""); } }","] \n import java . util . * ; class GFG { static class Node { int data ; Node left , right ; } ; static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static void sizeUtil ( Node root , int depth , int size [ ] ) { if ( root == null ) return ; sizeUtil ( root . left , depth + 1 , size ) ; size [ 0 ] += 1 ; size [ 1 ] += depth ; sizeUtil ( root . right , depth + 1 , size ) ; } static int totalDistUtil ( Node root , int target ) { if ( root == null ) return 0 ; if ( root . data == target ) return 0 ; int sum = 0 ; if ( root . left != null ) { sum += sizeUtil ( root . left , 1 , new int [ ] { 0 , 0 } ) ; sum += totalDistUtil ( root . left , target ) ; } if ( root . right != null ) { sum += sizeUtil ( root . right , 1",0.23759728563860372,0.13695742911038872,0.21290177173761388,0.3843137254901961,0.21621621621621623
104,"import java . util . * ; class GFG { static int [ ] reverse ( int a [ ] ) { int i , n = a . length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } static void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { Arrays . sort ( B ) ; B = reverse ( B ) ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { System . out . print ( "" - 1"" + ""NEW_LINE""); } else { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + "" ▁ "" ) ; } } } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = A . length ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; } }","] \n import java . util . * ; class GFG { static void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { Arrays . sort ( B ) ; Arrays . sort ( A ) ; int i = 0 ; for ( int j = N - 1 ; i < N ; i ++ , j -- ) { A [ i ] = A [ i ] + B [ j ] ; if ( A [ i ] > K ) { System . out . print ( "" - 1"" ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + ""   "" ) ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int B [ ] = { 10 , 20 , 30 , 40 , 50 } ; int K = 5 ; int N = A . length ; rearrangeArray ( A , B , N , K ) ; } } 1 ",0.4906305070947813,0.5128200896923475,0.54161370339266,0.5955882352941176,0.3125
105,"import java . io . * ; class GFG { static void countRows ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < m ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 2 , - 1 , 5 } , { - 3 , 0 , - 2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; } }","] \n import java . util . * ; class GFG { static void countRows ( int [ ] [ ] mat ) { int N = mat . length ; int M = mat [ 0 ] . length ; int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { sum += mat [ i ] [ j ] ; } for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < M ; j ++ ) { rowSum += mat [ i ] [ j ] ; } if ( rowSum > sum - rowSum ) { count ++ ; } } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; countRows ( mat ) ; } } 1 2",0.7722371770115057,0.728192202927041,0.7407565051189817,0.77,0.85
106,"import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","] class GFG { static boolean isContiguous ( int arr [ ] , int n ) { int i ; int prev = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { if ( prev == arr [ i ] ) continue ; if ( ( prev + 1 ) == arr [ i ] ) prev = arr [ i ] ; else return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 5 , 6 , 7 , 7 , 8 } ; int n = arr . length ; if ( isContiguous ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------",0.6401118178727307,0.5651842165498383,0.697644007322037,0.6190476190476191,0.6785714285714286
107,"import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }",= 2 ; 3 ; 4 ; 5 ; 6 ; 7 ; 8 ; 9 ; 10 ; 11 ; 12 ; 13 ; 14 ; 15 ; 16 ; 17 ; 18 ; 19 ; 20 ; 21 ; 22 ; 23 ; 24 ; 25 ; 26 ; 27 ; 28 ; 29 ; 30 ; 31 ; 32 ; 33 ; 34 ; 35 ; 36 ; 37 ; 38 ; 39 ; 40 ; 41 ; 42 ; 43 ; 44 ; 45 ; 46 ; 47 ; 48 ; 49 ; 50 ; 51 ; 52 ; 53 ; 54 ; 55 ; 56 ; 57 ; 58 ; 59 ; 60 ; 61 ; 62 ; 63 ; 64 ; 65,0.2507138441442742,0.001325460474620373,0.0015299161024765742,0.0,0.0
108,"import java . io . * ; import java . util . * ; class GFG { static Boolean areElementsContiguous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ( ) ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","] \n import java . util . * ; class GFG { static boolean check ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { us . add ( arr [ i ] ) ; } if ( us . contains ( arr [ 0 ] ) ) { int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) ) { curr_ele -- ; count ++ ; } if ( us . contains ( curr_ele ) ) { curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) ) { curr_ele ++ ; count ++ ; } } if ( count >= 2 ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 5 , 6 } ; int n = arr . length ; if ( check ( arr , n ) ) System . out . print ( "" Yes",0.6402807907803245,0.6981622125854342,0.700211662786576,0.6442307692307693,0.5185185185185185
109,"import java . util . * ; class GFG { static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . length ; int k = 3 ; longest ( a , n , k ) ; } }","] \n import java . io . * ; import java . util . * ; class GFG { static void findLongestSubarray ( int arr [ ] , int n , int k ) { int best = 0 , count = 0 ; int [ ] vis = new int [ n ] ; Arrays . fill ( vis , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { count ++ ; } vis [ i ] ++ ; if ( count > k ) { count = k ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( vis [ j ] == vis [ i ] ) { count -- ; } if ( count == k ) { int sub = i - j - 1 ; if ( sub > best ) best = sub ; } } vis [ i ] ++ ; } System . out . println ( "" The   longest   subarray   is   of   length   "" + best ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 2 ,",0.37392542255492345,0.36764920266291473,0.37651307868978423,0.5446428571428571,0.20689655172413793
110,"import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Stack ; class GFG { static class Pair { int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } } static boolean kOverlap ( ArrayList < Pair > pairs , int k ) { ArrayList < Pair > vec = new ArrayList < > ( ) ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) { vec . add ( new Pair ( pairs . get ( i ) . first , - 1 ) ) ; vec . add ( new Pair ( pairs . get ( i ) . second , + 1 ) ) ; } Collections . sort ( vec , new Comparator < Pair > ( ) { public int compare ( Pair a , Pair b ) { if ( a . first != b . first ) return a . first - b . first ; return ( a . second - b . second ) ; } } ) ; Stack < Pair > st = new Stack < > ( ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { Pair cur = vec . get ( i ) ; if ( cur . second == - 1 ) { st . push ( cur ) ; } else { st . pop ( ) ; } if ( st . size ( ) >= k ) { return true ; } } return false ; } public static void main ( String [ ] args ) { ArrayList < Pair > pairs = new ArrayList < > ( ) ; pairs . add ( new Pair ( 1 , 3 ) ) ; pairs . add ( new Pair ( 2 , 4 ) ) ; pairs . add ( new Pair ( 3 , 5 ) ) ; pairs . add ( new Pair ( 7 , 10 ) ) ; int n = pairs . size ( ) , k = 3 ; if ( kOverlap ( pairs , k ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","T] \n class GFG { static boolean checkOverlap ( int arr [ ] , int n , int k ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v . add ( new Integer ( arr [ i ] ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { v . add ( new Integer ( - 1 ) ) ; v . add ( new Integer ( + 1 ) ) ; } Collections . sort ( v , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o1 . compareTo ( o2 ) ; } } ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < 2 * n ; i ++ ) { int ele = v . get ( i ) ; if ( ele == - 1 ) st . push ( ele ) ; else { if ( st . size ( ) >= k ) return true ; else st . pop ( ) ; } } return false ; }",0.2904209006290989,0.21298280454429877,0.2812250698167572,0.4174757281553398,0.25
111,"class GFG { static final int N = 5 ; static int ptr [ ] = new int [ 501 ] ; static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) { minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( ""The smallest range is [%d, %d]NEW_LINE"", minel, maxel); } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = arr . length ; findSmallestRange ( arr , N , k ) ; } }","] import java . io . * ; import java . util . * ; class GFG { static int minrange ( int [ ] [ ] list , int k ) { int [ ] ptr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) ptr [ i ] = 0 ; while ( true ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; int index = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == list [ i ] . length ) break ; if ( list [ i ] [ ptr [ i ] ] < min ) { min = list [ i ] [ ptr [ i ] ] ; index = i ; } } for ( int i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == list [ i ] . length ) break ; if ( list [ i ] [ ptr [ i ] ] > max ) max = list [ i ] [ ptr [ i ] ] ; } if ( ptr [ index ] == list [ index ] . length ) break ; minrange = Math . min",0.3184804423241529,0.3003691474733524,0.33933362980610215,0.44155844155844154,0.1926605504587156
112,"import java . io . * ; import java . util . Arrays ; class GFG { static int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; } public static void main ( String [ ] args ) { int [ ] S = new int [ ] { 2 , 3 , 5 , 7 , 12 } ; int n = S . length ; int ans = findLargestd ( S , n ) ; if ( ans == Integer . MAX_VALUE ) System . out . println ( "" No ▁ Solution "" ) ; else System . out . println ( "" Largest ▁ d ▁ such ▁ that ▁ "" + "" a ▁ + ▁ "" + "" b ▁ + ▁ c ▁ = ▁ d ▁ is ▁ "" + ans ) ; } }","] import java . util . * ; class GFG { static int largestD ( int S [ ] , int n ) { Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { for ( int k = j - 1 ; k >= 0 ; k -- ) { for ( int l = k - 1 ; l >= 0 ; l -- ) { if ( S [ i ] == ( S [ j ] + S [ k ] + S [ l ] ) && S [ i ] != S [ j ] && S [ i ] != S [ k ] && S [ i ] != S [ l ] && S [ j ] != S [ k ] && S [ j ] != S [ l ] && S [ k ] != S [ l ] ) { return S [ i ] ; } } } } } return - 1 ; } public static void main ( String [ ] args ) { int S [ ] = { 3 , 4 , 5 , 6 , 7 , 8 } ; int n =",0.37418749769900395,0.36660708837477857,0.3820226016693574,0.39097744360902253,0.35714285714285715
113,"import java . util . HashMap ; import java . lang . Math ; class Indexes { int i , j ; Indexes ( int i , int j ) { this . i = i ; this . j = j ; } int getI ( ) { return i ; } int getJ ( ) { return j ; } } class GFG { static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = arr . length ; int res = findFourElements ( arr , n ) ; if ( res == Integer . MIN_VALUE ) System . out . println ( "" No ▁ Solution "" ) ; else System . out . println ( res ) ; } }","ass Main { static int hash [ ] = new int [ ] ; function to insert a pair ( i , j ) ; function to find the largest d such that a + b + c = d ; for all possible pairs ( a , b ) ; if a + b = d - c ; if no such pair is found ; Driver code [/ ] 1 / * * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * / * /",0.08686139379163933,0.022137417942209473,0.027290655864778957,0.1564245810055866,0.1415929203539823
114,"import java . util . Arrays ; public class GFG { static int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; System . out . println ( CountMaximum ( arr , n , k ) ) ; } }","] \n import java . util . * ; class GFG { static int countMaxElements ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) { count ++ ; sum = arr [ i ] ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 5 ; int n = arr . length ; System . out . println ( countMaxElements ( arr , n , k ) ) ; } } 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ;",0.6463848191557523,0.5507655207875014,0.7756526944756406,0.7313432835820896,0.5277777777777778
115,"class RotateArray { void leftRotatebyOne ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String [ ] args ) { RotateArray rotate = new RotateArray ( ) ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; rotate . leftRotate ( arr , 2 , 7 ) ; rotate . printArray ( arr , 7 ) ; } }","] class Main { static void leftRotate ( int arr [ ] , int n , int d ) { int i , t ; d = d % n ; for ( i = 0 ; i < d ; i ++ ) { t = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; j ++ ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = t ; } } static void leftRotateByD ( int arr [ ] , int n , int d ) { leftRotate ( arr , n , d ) ; } static void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + ""   "" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; int d = 3 ; leftRotateByD ( arr ,",0.6058948348429437,0.6070459870543174,0.6467831210501124,0.6914893617021277,0.4782608695652174
116,"import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + "" ▁ "" ) ; } } public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }","] import java . io . * ; import java . util . Arrays ; class GFG { static void sortInRange ( int arr [ ] , int a , int b ) { int start = a ; int end = b ; int [ ] temp = new int [ end - start + 1 ] ; int k = 0 ; for ( int i = start ; i <= end ; i ++ ) temp [ k ++ ] = arr [ i ] ; Arrays . sort ( temp ) ; for ( int i = start ; i <= end ; i ++ ) arr [ i ] = temp [ i - start ] ; for ( int i = 0 ; i <= end ; i ++ ) System . out . print ( arr [ i ] + ""   "" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 5 , 2 , 3 , 7 , 1 , 6 } ; int a = 1 , b = 5 ; sortInRange ( arr , a , b ) ; } } -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- ----------------",0.4938328174099302,0.4832063510977246,0.4977246827624498,0.6495726495726496,0.3448275862068966
117,"import java . util . * ; class GFG { static int MAX_SIZE = 10 ; static void sortByRow ( int [ ] [ ] mat , int n , boolean descending ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) { int t = i ; for ( int p = 0 ; p < n ; p ++ ) { for ( int j = p + 1 ; j < n ; j ++ ) { if ( mat [ t ] [ p ] < mat [ t ] [ j ] ) { temp = mat [ t ] [ p ] ; mat [ t ] [ p ] = mat [ t ] [ j ] ; mat [ t ] [ j ] = temp ; } } } } else Arrays . sort ( mat [ i ] ) ; } } static void transpose ( int mat [ ] [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } } static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + "" ▁ "" ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 3 ; int [ ] [ ] mat = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . println ( "" Original ▁ Matrix : "" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . println ( "" "" ▁ + ▁ "" Matrix After Sorting : ""); printMat ( mat , n ) ; } }","] \n import java . util . * ; class GFG { static void sortRow ( int [ ] [ ] mat , int descending ) { for ( int i = 0 ; i < mat . length ; i ++ ) { Arrays . sort ( mat [ i ] , ( a , b ) -> ( descending ? b - a : a - b ) ) ; } } static void transpose ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int [ ] [ ] transpose = new int [ m ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) transpose [ j ] [ i ] = mat [ i ] [ j ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = transpose [ i ] [ j ] ; } static void sortMatrix ( int [ ] [ ] mat , int descending ) { sortRow ( mat , descending",0.28189478278554836,0.20127443819117985,0.2988029676232012,0.4722222222222222,0.15527950310559005
118,"import java . io . * ; class PushZero { static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; pushZerosToEnd ( arr , n ) ; System . out . println ( "" Array ▁ after ▁ pushing ▁ zeros ▁ to ▁ the ▁ back : ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } }",= 0 ; 1 1 0 1 0 1 0 0 1 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 ,0.2530023264173528,0.005915870812155775,0.006093434857255549,0.0,0.0
119,"import java . io . * ; class GFG { static void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; System . out . print ( "" Original ▁ array : ▁ "" ) ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; System . out . print ( "" Modified array : ""); printArray ( arr , n ) ; } }","] import java . util . * ; class GFG { static void moveZeroes ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ count ] ; arr [ count ] = temp ; count ++ ; } } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + ""   "" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 0 , 0 , 0 , 10 , 100 , 0 , 0 , 1 , 0 } ; int n = arr . length ; moveZeroes ( arr , n ) ; System . out . println ( "" Array   after   moving   all   zeroes   to   end : "" ) ; printArray ( arr , n ) ; } } -------------------------------- 120 0 ",0.5951119622678852,0.6839212048951242,0.6987387616644343,0.7572815533980582,0.24050632911392406
120,"class GFG { static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } static void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = arr . length ; System . out . print ( "" Original ▁ array : ▁ "" ) ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; System . out . print ( "" Modified ▁ array : ▁ "" ) ; printArray ( arr , n ) ; } }","INST] \n class GFG { static void pushZeros ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { arr [ count ] = arr [ i ] ; count ++ ; } while ( count < n ) { arr [ count ] = 0 ; count ++ ; } } static void rearrange ( int arr [ ] , int n ) { if ( n == 1 ) { arr [ 0 ] = 2 * arr [ 0 ] ; return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZeros ( arr , n ) ; } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + ""   """,0.5051904595268438,0.48312047283355525,0.5364243267342665,0.6482758620689655,0.35294117647058826
121,"class GFG { public static void swap ( int [ ] A , int i , int j ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } static void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( int index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array , array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } } }","Function to double the first element and move zero to end of array ; Driver code ; Function Call [/INST] \n import java . io . * ; class GFG { static void swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } static void moveZeroesToEnd ( int arr [ ] , int n ) { int lastSeen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { swap ( arr , i , lastSeen ) ; lastSeen ++ ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 2 , 0 , 3 , 0 , 4 , 0 , 5 } ; int n = arr . length ; moveZeroesToEnd ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + ""  ",0.539206522540216,0.2874046786130743,0.5486977273372633,0.7894736842105263,0.53125
122,"import java . io . * ; class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; System . out . println ( ) ; } static void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int n = arr . length ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; } }","] class Rearrange { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + ""   "" ) ; } static void rearrange ( int arr [ ] , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) continue ; for ( j = i - 1 ; j >= 0 ; j -- ) if ( arr [ j ] >= 0 ) { int temp = arr [ j ] ; arr [ j ] = arr [ i ] ; arr [ i ] = temp ; i = j - 1 ; } arr [ i ] = - arr [ i ] ; } printArray ( arr , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( "" Before   rearrangement :",0.5334768483208521,0.6412734997075663,0.6452684636821991,0.6880733944954128,0.1592920353982301
123,"class GFG { static void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( A [ i ] + "" ▁ "" ) ; System . out . println ( "" "" ) ; ; } static void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } } static void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } static void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_size = arr . length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; } }","T ] \n import java . io . * ; import java . util . * ; class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + ""   "" ) ; System . out . println ( ) ; } static void reverse ( int arr [ ] , int l , int r ) { int i = l , j = r ; while ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } } static void merge ( int arr [ ] , int l , int m , int r ) { int i , j , k ; int i1 = l ; int j1 = m + 1 ; i = l ; j = m + 1 ; k = l ; while ( i <= m && j <= r ) { if ( arr [ i ] > arr [ j ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] =",0.3533773497472793,0.3324939557186474,0.39045282984034263,0.5526315789473685,0.13793103448275862
124,"import java . io . * ; class GFG { public static void RearrangePosNeg ( int arr [ ] ) { int i = 0 ; int j = arr . length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; RearrangePosNeg ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } }","] class GFG { static void rearrange ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i < n && arr [ i ] < 0 ) { i ++ ; } while ( j >= 0 && arr [ j ] > 0 ) { if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } i ++ ; j -- ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 7 , 8 , 2 , - 2 , 3 , 6 } ; int n = arr . length ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + ""   "" ) ; } } ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ----------------",0.5956491021210656,0.5741192761902102,0.6120046138362998,0.6304347826086957,0.5660377358490566
125,"class GFG { static void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { System . out . print ( "" A "" ) ; } else { System . out . print ( "" B "" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 24 , 45 , 45 , 24 } ; int N = arr . length ; winner ( arr , N ) ; } }","] \n import java . util . * ; class GFG { static void findWinner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { System . out . print ( "" A "" ) ; } else { System . out . print ( "" B "" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int N = arr . length ; findWinner ( arr , N ) ; } } orszag { } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 12345",0.7133702837693505,0.5871793968238761,0.8650859327824013,0.8297872340425532,0.5714285714285714
126,"import java . util . * ; class GFG { static int sz = 20 ; static int sqr = ( int ) ( Math . sqrt ( sz ) ) + 1 ; static void precomputeExpressionForAllVal ( int arr [ ] , int N , int dp [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= Math . sqrt ( N ) ; j ++ ) { if ( i + j < N ) { dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] ; } else { dp [ i ] [ j ] = arr [ i ] ; } } } } static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { int [ ] [ ] dp = new int [ sz ] [ sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; if ( y <= Math . sqrt ( N ) ) { System . out . print ( dp [ x ] [ y ] + "" ▁ "" ) ; continue ; } int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } System . out . print ( sum + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }","] \n import java . io . * ; class GFG { static void preCompute ( int arr [ ] , int N , int dp [ ] [ ] ) { for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 1 ; y <= Math . sqrt ( N ) ; y ++ ) { if ( x + y < N ) { dp [ x ] [ y ] = dp [ x + 1 ] [ y - 1 ] + arr [ x ] ; } else { dp [ x ] [ y ] = arr [ x ] ; } } } } static void findSum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { int dp [ ] [ ] = new int [ N ] [ ( int ) Math . sqrt ( N ) + 1 ] ; preCompute ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; for ( int j = 0 ; j < y ; j",0.3829871303574744,0.37268152453694997,0.4332037471655755,0.5428571428571428,0.183206106870229
127,"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }","] \n class GFG { static void printGreaterTwo ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count > 2 ) System . out . print ( arr [ i ] + ""   "" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 2 , 1 , 10 , 11 , 12 , 13 } ; int n = arr . length ; printGreaterTwo ( arr , n ) ; } } -------------------------------- -------------------------------- - -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- ",0.6792099569382513,0.6270040850789211,0.7232703931300111,0.6857142857142857,0.6808510638297872
128,"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }","] \n import java . util . * ; class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == arr [ i + 2 ] ) continue ; System . out . print ( arr [ i ] + ""   "" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 6 } ; int n = arr . length ; findElements ( arr , n ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- --------------------------------",0.6540495112148733,0.49627493834569486,0.7760077625984543,0.6296296296296297,0.7142857142857143
129,"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }","] \n class GFG { static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE , second = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= second ) System . out . print ( arr [ i ] + ""   "" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 5 , 4 , 6 } ; int n = arr . length ; findElements ( arr , n ) ; } }                              ",0.6846638224644145,0.721197707868597,0.7867749113213937,0.7790697674418605,0.45161290322580644
130,"import java . io . * ; import java . util . * ; class GFG { public static int getMinOps ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 1 , 2 } ; System . out . println ( getMinOps ( arr ) ) ; } }","] \n import java . io . * ; import java . util . * ; class GFG { static int minOperations ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) continue ; res += arr [ i ] - arr [ i + 1 ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 3 , 5 } ; int N = arr . length ; System . out . println ( minOperations ( arr , N ) ) ; } } 1 2 3 4 5 ; System . out . println ( minOperations ( arr , N ) ) ; } } 1 2 3 4 5 ; System . out . println ( minOperations ( arr , N ) ) ; } 1 2 3 4 5 ; System . out . println ( minOperations ( arr , N ) ) ; } 1 2 3 4",0.592471389361877,0.402198297870119,0.6998711676233662,0.5344827586206896,0.7333333333333333
131,"class SmallestMissing { int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } public static void main ( String [ ] args ) { SmallestMissing small = new SmallestMissing ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . length ; System . out . println ( "" First ▁ Missing ▁ element ▁ is ▁ : ▁ "" + small . findFirstMissing ( arr , 0 , n - 1 ) ) ; } }","] class FindMissingElement { static int findMissingElement ( int arr [ ] , int n ) { int low = 0 , high = n - 1 ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == mid ) low = mid + 1 ; else high = mid ; } return low ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( "" Missing   element   is   "" + findMissingElement ( arr , n ) ) ; } } 1 | Java program to find the smallest missing number in a sorted array ; function that returns smallest elements missing in a sorted array . ; Left half has all elements from 0 to mid ; Driver program to test the above function [/INST] \n class FindMissingElement { static int findMissingElement ( int arr [ ] , int n ) { int low = 0 , high = n - 1 ; while ( low <",0.4747569326455513,0.34176439251821517,0.4276952317516977,0.5714285714285714,0.5581395348837209
132,"import java . io . * ; class GFG { int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } int findSmallestMissinginSortedArray ( int [ ] arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; } public static void main ( String [ ] args ) { GFG small = new GFG ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ; System . out . println ( "" First ▁ Missing ▁ element ▁ is ▁ : ▁ "" + small . findSmallestMissinginSortedArray ( arr ) ) ; } }","] \n class GFG { static int findMissing ( int arr [ ] , int n ) { int i = 0 ; while ( i < n && arr [ i ] == i ) i ++ ; return i ; } static int smallestMissing ( int arr [ ] , int n ) { if ( arr [ 0 ] != 0 ) return 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] != i ) return i ; return n ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; int n = arr . length ; System . out . println ( smallestMissing ( arr , n ) ) ; } } -------------------------------- 1 / 2 1 / 3 1 / 4 1 / 5 1 / 6 1 / 7 1 / 8 1 / 9 1 / 10 1 / 11 1 / 12 1 / 13 1 / 14 1 / 15 1 / 16 1 / ",0.34193571970337516,0.2853858677589095,0.29829573334924564,0.3942307692307692,0.3898305084745763
133,"class MaximumSum { int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void main ( String [ ] args ) { MaximumSum sum = new MaximumSum ( ) ; int arr [ ] = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; System . out . println ( sum . FindMaxSum ( arr , arr . length ) ) ; } }","] import java . io . * ; class GFG { static int maxSum ( int arr [ ] , int n ) { int incl = 0 , excl = 0 ; for ( int i = 0 ; i < n ; i ++ ) { excl = Math . max ( excl , incl ) ; incl = incl + arr [ i ] ; } return Math . max ( excl , incl ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 3",0.41609507140797736,0.38559960487555217,0.4389873991026104,0.4444444444444444,0.3953488372093023
134,"import java . util . * ; class GFG { static final int N = 7 ; static int countChanges ( int matrix [ ] [ ] , int n , int m ) { int dist = n + m - 1 ; int [ ] [ ] freq = new int [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 } , { 3 , 5 } } ; System . out . print ( countChanges ( mat , 2 , 2 ) ) ; } }","] \n import java . util . * ; class GFG { public static int minChanges ( int matrix [ ] [ ] ) { int n = matrix . length ; int m = matrix [ 0 ] . length ; int ans = 0 ; for ( int i = 0 ; i < n + m - 2 ; i ++ ) { int [ ] freq = new int [ 10 ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < m ; k ++ ) { freq [ matrix [ j ] ] ++ ; } ans += Math . min ( freq [ i + i ] , freq [ n + m - 2 - i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 ,",0.36109148295102306,0.33514568382186904,0.3749736726397576,0.5342465753424658,0.2
135,"import java . io . * ; class GFG { static int MAX = 500 ; static int [ ] [ ] lookup = new int [ MAX ] [ MAX ] ; static void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } static int query ( int L , int R ) { int j = ( int ) Math . log ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; } public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . println ( query ( 0 , 4 ) ) ; System . out . println ( query ( 4 , 7 ) ) ; System . out . println ( query ( 7 , 8 ) ) ; } }",[ 0 ] = arr [ 0 ] [ 0 ] = arr [ 0 ] = 2 ; [ 0 ] [ 1 ] = arr [ 0 ] [ 1 ] = arr [ 1 ] = 3 ; [ 0 ] [ 2 ] = arr [ 0 ] [ 2 ] = arr [ 2 ] = 4 ; [ 0 ] [ 3 ] = arr [ 0 ] [ 3 ] = arr [ 3 ] = 5 ; [ 0 ] [ 4 ] = arr [ 0 ] [ 4 ] = arr [ 4 ] = 7 ; [ 0 ] [ 5 ] = arr [ 0 ] [ 5 ] = arr [ 5 ] = 8 ; [ 0 ] [ 6 ] = arr [ 0 ] [ 6 ] = arr [ 6 ] = 9 ; [ 0 ] [ 7 ] = arr [ 0 ] [ 7 ] = arr [ 7 ] = 10 ; [ 0 ] [ 8 ] = arr [ 0 ] [ 8 ] = arr [ 8,0.03582193737640261,0.030113616510269177,0.03698365680486507,0.0,0.0761904761904762
136,"import java . util . * ; class GFG { static final int MAX = 500 ; static int [ ] [ ] table = new int [ MAX ] [ MAX ] ; static void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } static int query ( int L , int R ) { int j = ( int ) Math . log ( R - L + 1 ) ; return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . print ( query ( 0 , 2 ) + ""NEW_LINE""); System . out . print ( query ( 1 , 3 ) + ""NEW_LINE""); System . out . print ( query ( 4 , 5 ) + ""NEW_LINE""); } }","] \n import java . util . * ; class GFG { static int MAX = 100 ; static int lookup [ ] [ ] = new int [ MAX ] [ MAX ] ; static void build ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j < n ; j ++ ) { for ( int i = 0 ; i + j < n ; i ++ ) lookup [ i ] [ j ] = __gcd ( lookup [ i ] [ j - 1 ] , lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static int findGCD ( int arr [ ] , int L , int R ) { int j = ( int ) ( Math . log ( R - L + 1 ) / Math . log ( 2 ) ) ; return __gcd (",0.4845173515874097,0.4774626086419059,0.5345690618586766,0.5660377358490566,0.36
137,"class GFG { static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = arr . length ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } }"," n - 1 ] = lexicographically smallest with k swaps . ; Set the position where we want to put the smallest integer ; If we exceed the Max swaps then terminate the loop ; Find the minimum value from i + 1 to max k or n ; Swap the elements from Minimum position we found till now to the i index ; Set the final value after swapping pos - i elements ; Driver method [/DRIVER_CODE] \n import java . util . Arrays ; import java . util . Collections ; class Test { static void lexicographicallySmallest ( int [ ] arr , int n , int k ) { int pos = n ; while ( k -- > 0 ) { int min = Arrays . stream ( ) . boxed ( ) . map ( x -> x ) . min ( ) . get ( ) ; int index = Collections . min_element ( Arrays . asList ( arr ) ) ; int temp = arr [ index ] ; arr [ index ] = arr [ pos - 1 ] ; arr [ pos - 1 ] = temp ; pos -- ; } } public static void main ( String [ ] args ) { int",0.30796429417426097,0.2449524146122095,0.2462825626225375,0.4392523364485981,0.3013698630136986
138,"import java . io . * ; class GFG { static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; } static public void main ( String [ ] args ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( "" The ▁ maximum ▁ "" + "" average ▁ subarray ▁ of ▁ length ▁ "" + k + "" ▁ begins ▁ at ▁ index ▁ "" + findMaxAverage ( arr , n , k ) ) ; } }","] class GFG { static int maxSubArraySum ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int csum [ ] = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] ; int max_start = 0 ; for ( int i = k ; i < n ; i ++ ) { if ( max_sum < csum [ i ] - csum [ i - k ] ) { max_sum = csum [ i ] - csum [ i - k ] ; max_start = i - k + 1 ; } } return max_start ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 11 , 100 , 3 , 12 , 7 , 16 , 2 , 1 } ; int n = arr . length ; int k",0.6232238352216062,0.5487158822477712,0.5749676359785549,0.6120689655172413,0.7571428571428571
139,"import java . io . * ; class GFG { static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( "" The ▁ maximum ▁ average "" + "" ▁ subarray ▁ of ▁ length ▁ "" + k + "" ▁ begins ▁ at ▁ index ▁ "" + findMaxAverage ( arr , n , k ) ) ; } }","] class GFG { static int maxSubArrayStart ( int arr [ ] , int n , int k ) { if ( n < k ) return - 1 ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int start_index = 0 ; for ( i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; max_sum = Math . max ( max_sum , sum ) ; } return start_index ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 2 , 3 , 1 } ; int k = 3 ; int n = arr . length ; System . out . println ( maxSubArrayStart ( arr , n , k ) ) ; } } �3cQuT3n 3eJv3M",0.5340183431871096,0.5357310147318052,0.5609875193069559,0.62,0.41935483870967744
140,"import java . io . * ; import java . util . * ; class GFG { static class R { int x , y ; public R ( int x , int y ) { this . x = x ; this . y = y ; } } static HashMap < R , Integer > m = new HashMap < > ( ) ; public static int findMinimum ( int [ ] arr , int N , int pos , int turn ) { R x = new R ( pos , turn ) ; if ( m . containsKey ( x ) ) { return m . get ( x ) ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; R v = new R ( pos , turn ) ; m . put ( v , ans ) ; return ans ; } if ( turn != 0 ) { int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; R v = new R ( pos , turn ) ; m . put ( v , ans ) ; return ans ; } return 0 ; } public static int countPenality ( int [ ] arr , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; } public static void printAnswer ( int [ ] arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } System . out . println ( a ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = 8 ; printAnswer ( arr , N ) ; } }","ST ] \n import java . util . * ; class GFG { static Map < Map . Entry < Integer , Integer > , Integer > mp = new HashMap < Map . Entry < Integer , Integer > , Integer > ( ) ; static int minScore ( int pos , int myTurn , int [ ] arr , int n ) { if ( pos == n ) { if ( myTurn == 1 ) return 0 ; else return Integer . MAX_VALUE ; } int ans = Integer . MAX_VALUE ; if ( myTurn == 1 ) { ans = Math . min ( arr [ pos ] + minScore ( pos + 1 , 0 , arr , n ) , 1 + minScore ( pos + 2 , 1 , arr , n ) ) ; } else { ans = Math . min ( arr [ pos ] + minScore ( pos + 1 , 0 , arr , n ) , 1 + minScore ( pos + 2 , 1 , arr , n ) ) ; } mp . put ( new Map . Entry < Integer , Integer > ( pos , myTurn ) , ans ) ; return ans ; } static int minPen",0.2617951109686646,0.13983944074400356,0.18751374348977307,0.4213197969543147,0.29850746268656714
141,"import java . io . * ; import java . util . * ; class GFG { static int MAX = 1000001 ; static int prime [ ] = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { Arrays . fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } } static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } static int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } static void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } static void updateValue ( int arr [ ] , int [ ] st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { System . out . print ( "" - 1"" ) ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } } static int getSum ( int [ ] st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { System . out . println ( "" - 1"" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } static int [ ] constructST ( int arr [ ] , int n ) { int x = ( int ) ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = arr . length ; int Q [ ] [ ] = { { 1 , 1 , 3 } , { 2 , 1 , 10 } , { 1 , 1 , 3 } } ; SieveOfEratosthenes ( ) ; int [ ] st = constructST ( arr , n ) ; System . out . println ( getSum ( st , n , 1 , 3 ) ) ; updateValue ( arr , st , n , 1 , 10 ) ; System . out . println ( getSum ( st , n , 1 , 3 ) ) ; } }","tatic int N = 1000005 ; static Vector < Integer > prime = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ N ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < N ; p ++ ) if ( prime [ p ] ) prime . add ( p ) ; } static int getIndex ( int l , int r , int lc , int rc , int index ) { if ( index < lc ) return 0 ; if ( index > rc ) return 2 * N ; return 1 ; } static int getSumUtil ( int node , int lc , int rc , int l , int r ) { if ( l > r ) return 0 ; if ( l == lc &&",0.14083061285719214,0.013379086231429112,0.10159863825978661,0.3617021276595745,0.08664259927797834
142,"import java . util . * ; class GFG { static int mod = 1000000007 ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static int calculate ( int pos , int prev , String s , Vector < Integer > index ) { if ( pos == s . length ( ) ) return 1 ; if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ; int answer = 0 ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( index . get ( i ) . compareTo ( prev ) >= 0 ) { answer = ( answer % mod + calculate ( pos + 1 , index . get ( i ) , s , index ) % mod ) % mod ; } } return dp [ pos ] [ prev ] = answer ; } static int countWays ( Vector < String > a , String s ) { int n = a . size ( ) ; Vector < Integer > [ ] index = new Vector [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . length ( ) ; j ++ ) { index [ a . get ( i ) . charAt ( j ) - ' a ' ] . add ( j + 1 ) ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; } public static void main ( String [ ] args ) { Vector < String > A = new Vector < String > ( ) ; A . add ( "" adc "" ) ; A . add ( "" aec "" ) ; A . add ( "" erg "" ) ; String S = "" ac "" ; System . out . print ( countWays ( A , S ) ) ; } }",= 1 ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 ,0.2502723873119018,8.90216265810772e-05,0.0010005276210261396,0.0,0.0
143,"import java . util . * ; class GFG { static final int MAX = 100005 ; static final int MOD = 1000000007 ; static int [ ] [ ] [ ] dp = new int [ MAX ] [ 101 ] [ 2 ] ; static int countNum ( int idx , int sum , int tight , Vector < Integer > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num . get ( idx ) ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } static Vector < Integer > process ( String s ) { Vector < Integer > num = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . add ( s . charAt ( i ) - '0' ) ; } return num ; } public static void main ( String [ ] args ) { String n = ""98765432109876543210"" ; int len = n . length ( ) ; int k = 58 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } Vector < Integer > num = process ( n ) ; System . out . print ( countNum ( 0 , 0 , 0 , num , len , k ) ) ; } }",] ; Fill the dp table [ ] 1 ] ; Print the result [/1 ] 1 ] ; Driver code ; Driver code [/1 ] 1 ] ; For large input number n ; Total number of digits in n [/1 ] 1 ] ; Fill the dp table [/1 ] 1 ] ; Print the result [/1 ] 1 ] ; For large input number n [/1 ] 1 ] ; Total number of digits in n [/1 ] 1 ] ; Fill the dp table [/1 ] 1 ] ; Print the result [/1 ] 1 ] ; For large input number n [/1 ] 1 ] ; Total number of digits in n [/1 ] 1 ] ; Fill the dp table [/1 ] 1 ] ; Print the result [/1 ] 1 ] ; For large input number n [/1 ] 1 ] ; Total number of digits in n [/1 ] 1 ] ; Fill the dp table [/1 ] 1 ] ; Print the result [/1 ],0.006803214280013431,0.0015034993782386936,0.002383296322113736,0.01485148514851485,0.00847457627118644
144,"import java . util . * ; import java . lang . * ; class GFG { public static int [ ] countSum ( int arr [ ] , int n ) { int result = 0 ; int [ ] countODD = new int [ n + 1 ] ; int [ ] countEVEN = new int [ n + 1 ] ; countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } int [ ] ans = new int [ 2 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 2 , 3 } ; int n = 4 ; int [ ] ans = countSum ( arr , n ) ; System . out . println ( "" EvenSum ▁ = ▁ "" + ans [ 0 ] ) ; System . out . println ( "" OddSum ▁ = ▁ "" + ans [ 1 ] ) ; } }","] \n import java . util . * ; class GFG { static int countSubsequences ( int arr [ ] , int n ) { int countEVEN [ ] = new int [ n ] ; int countODD [ ] = new int [ n ] ; countEVEN [ 0 ] = 1 ; countODD [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countEVEN [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] ; } } return countEVEN [ n - 1 ] + countODD [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , ",0.4098444289430171,0.43715248719251104,0.5038295066544236,0.5454545454545454,0.15294117647058825
145,"class GFG { static int maxN = 31 ; static int maxW = 31 ; static int dp [ ] [ ] [ ] = new int [ maxN ] [ maxW ] [ maxW ] ; static int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 2 , 3 } ; for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxW ; j ++ ) for ( int k = 0 ; k < maxW ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; int n = arr . length ; int w1 = 10 , w2 = 3 ; System . out . println ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ; } }","] [ ] ; 3D array to store states of DP ; Initialize the 3D array with - 1 ; Function to solve the knapsack problem ; Base case ; Initialize the answer ; Loop to iterate over all the elements of the array arr [ ] ; Loop to iterate over the remaining capacity of the knapsack ; Condition to check if the element is included in the knapsack or not ; Condition to check if the element is included in the knapsack or not ; Store the state in the 3D array ; Return the maximum value of the knapsack ; Function to print the result ; Driver code ; Function call to solve the knapsack problem ; Print the result [/INST] \n import java . util . * ; class GFG { static int [ ] [ ] [ ] dp ; static int solve ( int [ ] arr , int w1 , int w2 , int n , int w ) { if ( n == 0 ) { if ( w1 == 0 ) { dp [ 0 ] [ w1 ] [ w2 ] = 0 ; return 0 ; } int ans = ",0.13502110150908597,0.06453602443702629,0.08231559179465396,0.2251655629139073,0.16806722689075632
146,"import java . util . * ; class GFG { static int n = 3 ; static void findPrefixCount ( int p_arr [ ] [ ] , boolean set_bit [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( set_bit [ i ] [ j ] ) ? 1 : 0 ; } } } static class pair { int first , second ; pair ( ) { } pair ( int a , int b ) { first = a ; second = b ; } } static int matrixAllOne ( boolean set_bit [ ] [ ] ) { int p_arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) p_arr [ i ] [ j ] = 0 ; findPrefixCount ( p_arr , set_bit ) ; int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; Stack < pair > q = new Stack < pair > ( ) ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 && q . peek ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . peek ( ) . second + 1 ) * ( q . peek ( ) . first - p_arr [ i ] [ j ] ) ; c += q . peek ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( new pair ( p_arr [ i ] [ j ] , c ) ) ; i -- ; } } return ans ; } static int sumAndMatrix ( int arr [ ] [ ] ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { boolean set_bit [ ] [ ] = new boolean [ n ] [ n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; } public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; System . out . println ( sumAndMatrix ( arr ) ) ; } }","[ 0 ] = 1 if arr [ 0 ] [ 0 ] = 1 else 0 ; [/INST] \n class GFG { static int n = 3 ; static int m = 3 ; static void preCount ( int arr [ ] [ ] , int pre [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) pre [ i ] [ j ] = 1 ; else pre [ i ] [ j ] = 0 ; for ( int k = j - 1 ; k >= 0 ; k -- ) { if ( arr [ i ] [ k ] == 1 ) pre [ i ] [ j ] += pre [ i ] [ k ] ; } } } static int countSubmatrices ( int pre [ ] [ ] , int k ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ )",0.21830703257342515,0.10032354650755301,0.2232690475612673,0.43727598566308246,0.11235955056179775
147,import java . io . * ; class GFG { static int CountWays ( int n ) { int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } },] \n class GFG { static int countWays ( int n ) { int [ ] noOfWays = new int [ n + 2 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 2 ; noOfWays [ 2 ] = 3 ; for ( int i = 3 ; i <= n ; i ++ ) { int ways1 = noOfWays [ i - 1 ] ; int ways2 = noOfWays [ i - 2 ] ; int ways3 = noOfWays [ i - 3 ] ; noOfWays [ i ] = ways1 + ways2 + ways3 ; } return noOfWays [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } -------------------------------------------------------------------------------- 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1 / 2 1,0.5791751734173272,0.5475805197824244,0.6055390741355717,0.6103896103896104,0.5531914893617021
148,"import java . util . * ; public class Main { static class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int MAX = 105 , q = 0 ; static int [ ] prime = new int [ MAX ] ; static void sieve ( ) { for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = 1 ; } } } static void dfs ( int i , int j , int k , int n , int m , int [ ] [ ] mappedMatrix , int [ ] [ ] mark , pair [ ] ans ) { if ( ( mappedMatrix [ i ] [ j ] == 0 ? true : false ) || ( i > n ? true : false ) || ( j > m ? true : false ) || ( mark [ i ] [ j ] != 0 ? true : false ) || ( q != 0 ? true : false ) ) return ; mark [ i ] [ j ] = 1 ; ans [ k ] = new pair ( i , j ) ; if ( i == n && j == m ) { ( q ) = k ; return ; } dfs ( i + 1 , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i + 1 , j , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; } static void lexicographicalPath ( int n , int m , int [ ] [ ] mappedMatrix ) { int q = 0 ; pair [ ] ans = new pair [ MAX ] ; int [ ] [ ] mark = new int [ MAX ] [ MAX ] ; dfs ( 1 , 1 , 1 , n , m , mappedMatrix , mark , ans ) ; int [ ] [ ] anss = { { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 3 , 3 } } ; for ( int i = 0 ; i < 4 ; i ++ ) System . out . println ( anss [ i ] [ 0 ] + "" ▁ "" + anss [ i ] [ 1 ] ) ; } static void countPrimePath ( int [ ] [ ] mappedMatrix , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } System . out . println ( dp [ n ] [ m ] ) ; } static void preprocessMatrix ( int [ ] [ ] mappedMatrix , int [ ] [ ] a , int n , int m ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } } public static void main ( String [ ] args ) { int n = 3 ; int m = 3 ; int [ ] [ ] a = { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int [ ] [ ] mappedMatrix = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { mappedMatrix [ i ] [ j ] = 0 ; } } preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; } }","] \n import java . util . * ; class GFG { static int N = 3 ; static int M = 3 ; static boolean [ ] [ ] [ ] visited = new boolean [ N ] [ M ] [ M ] ; static int [ ] [ ] [ ] index = new int [ N ] [ M ] [ M ] ; static int [ ] [ ] [ ] [ ] m = new int [ N ] [ M ] [ M ] ; static int [ ] [ ] [ ] [ ] f = new int [ N ] [ M ] [ M ] ; static void dfs ( int i , int j , int k , int index , int n , int m ) { visited [ i ] [ j ] [ k ] = true ; index [ i ] [ j ] [ k ] = index ; if ( i == n - 1 && j == m - 1 ) { f [ i ] [ j ] [ k ] = index ; return ; } if ( i == 0 j == 0 k == 0 ) return ; if ( m [ i ] [ j ] [ k ] == 0 ) return ; if ( visited [",0.147131241949986,0.021896172897988588,0.12442483367144558,0.4023809523809524,0.03982300884955752
149,"class sumofSub { static int isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; int count [ ] [ ] = new int [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } public static void main ( String args [ ] ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = set . length ; System . out . println ( isSubsetSum ( set , n , sum ) ) ; } }","] class MaxSubset { static int subsetSum ( int set [ ] , int n , int sum ) { int [ ] [ ] subset = new int [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( set [ j - 1 ] <= i ) subset [ i ] [ j ] = subset [ i ] [ j - 1 ] subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } for ( int i = 1 ; i <= sum ; i ++ ) if ( subset [ i ] [ n ] == true ) return i ; return - 1 ; } public static void main ( String args [ ] ) { int set [ ] = { ",0.4595080776871862,0.4557510298755484,0.5240534327719307,0.6582278481012658,0.2
150,"class GFG { static int MAX = 100 ; static int lcslen = 0 ; static int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; static int lcs ( String str1 , String str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 . charAt ( i ) == str2 . charAt ( j ) ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; } static void printAll ( String str1 , String str2 , int len1 , int len2 , char [ ] data , int indx1 , int indx2 , int currlcs ) { if ( currlcs == lcslen ) { data [ currlcs ] = ' \0' ; System . out . println ( new String ( data ) ) ; return ; } if ( indx1 == len1 indx2 == len2 ) return ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { boolean done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) { if ( ch == str1 . charAt ( i ) ) { for ( int j = indx2 ; j < len2 ; j ++ ) { if ( ch == str2 . charAt ( j ) && dp [ i ] [ j ] == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } } if ( done ) break ; } } } static void prinlAllLCSSorted ( String str1 , String str2 ) { int len1 = str1 . length ( ) , len2 = str2 . length ( ) ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; } public static void main ( String [ ] args ) { String str1 = "" abcabcaa "" , str2 = "" acbacba "" ; prinlAllLCSSorted ( str1 , str2 ) ; } }","ass GFG { public static void printLCS ( char [ ] str1 , char [ ] str2 , int m , n , k ) { int lcs [ ] [ ] [ ] [ ] = new int [ ] [ ] ; int lcslen = 0 ; for ( i = 0 ; i < m ; for ( j = 0 ; j < n ; if ( str1 [ i ] == str2 [ j ] ) { lcslen ++ ; } ; lcs [ ] [ ] [ ] = lcslen ; } ; printLCSUtil ( str1 , str2 , lcs [ ] , m , n , lcslen , data ) ; } ; Driver code ; printLCS ( str1 , str2 , lcs [ ] , m , n , lcslen , data ) ; } 1 ; Driver code ; printLCS ( str1 , str2 ) ; } 1 ; Driver code [/ ] 1 ; printLCS ( str",0.15173302218867085,0.035626427346492066,0.1023334571418694,0.31512605042016806,0.15384615384615385
151,"import java . io . * ; class Majority { static boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . length ; int x = 4 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + "" ▁ appears ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; else System . out . println ( x + "" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; } }","] \n class GFG { static int getLastIndex ( int n ) { return n % 2 == 0 ? n / 2 : ( n / 2 ) + 1 ; } static boolean isMajority ( int arr [ ] , int n ) { int l = getLastIndex ( n ) ; int i = 0 ; while ( i < n ) { if ( arr [ i ] == arr [ l ] ) { int j = i ; while ( j < n && arr [ j ] == arr [ l ] ) j ++ ; if ( j - i > n / 2 ) return true ; i = j ; } i ++ ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 } ; int n = arr . length ; if ( isMajority ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } đ",0.45643169708483367,0.4680688767962781,0.4766121599090697,0.4888888888888889,0.39215686274509803
152,"import java . io . * ; class Majority { static int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } static boolean isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + "" ▁ appears ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; else System . out . println ( x + "" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; } }","] \n class BinarySearch { static int binarySearch ( int arr [ ] , int low , int high , int x ) { int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == x && ( ( mid == 0 mid == low ) || ( mid > 0 && arr [ mid - 1 ] < x ) ) return mid ; if ( arr [ mid ] < x ) low = mid + 1 ; else high = mid - 1 ; } return - 1 ; } static boolean isMajority ( int arr [ ] , int n , int x ) { int first = binarySearch ( arr , 0 , n - 1 , x ) ; if ( first == - 1 ) return false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) count ++ ; if ( count > n / 2 ) return true ; else return false ; } public static void main ( String args [ ] ) { int arr",0.4257288839456509,0.3349941275613355,0.3931696351716224,0.46808510638297873,0.5066666666666667
153,"import java . util . * ; class GFG { static boolean isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) System . out . printf ( "" % d ▁ appears ▁ more ▁ than ▁ % d ▁ "" + "" times ▁ in ▁ arr [ ] "" , x , n / 2 ) ; else System . out . printf ( "" % d ▁ does ▁ not ▁ appear ▁ more ▁ "" + "" than ▁ % d ▁ times ▁ in ▁ "" + "" arr [ ] "" , x , n / 2 ) ; } }","] \n class GFG { static boolean isMajority ( int arr [ ] , int n ) { return ( arr [ n / 2 ] >= n / 3 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 } ; int n = arr . length ; if ( isMajority ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ------------------------------------------------ 1 / 2 ------------------------------------------------ [/INST] \n class GFG { static boolean isMajority ( int arr [ ] , int n ) { return ( arr [ n / 2 ] >= n / 3 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 } ; int n = arr . length ; if ( isMajority ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . print",0.4801864313897407,0.39250700532410154,0.44525503725117843,0.47692307692307695,0.6060606060606061
154,"class RodCutting { static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( "" Maximum ▁ Obtainable ▁ Value ▁ is ▁ "" + cutRod ( arr , size ) ) ; } }","] class Solution { static int rodCut ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) val [ i ] = Integer . MIN_VALUE ; val [ 0 ] = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= i ; j ++ ) val [ i ] = Math . max ( val [ i ] , price [ j - 1 ] + val [ i - j ] ) ; } return val [ n ] ; } public static void main ( String [ ] args ) { int price [ ] = { 1 , 5 , 8 , 9 , 9 , 10 , 17 , 17 , 17 , 20 } ; int n = price . length ; System . out . println ( "" Maximum   price   is   "" + rodCut ( price , n ) ) ; } } 1 5 8 9 9 10 17 17 ",0.5821314181997836,0.5920163792557502,0.657033984901409,0.6419753086419753,0.4375
155,"import java . io . * ; import java . util . * ; class GFG { public static boolean isPossible ( int [ ] target ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target ) ; } public static void main ( String [ ] args ) { int [ ] target = { 9 , 3 , 5 } ; boolean res = isPossible ( target ) ; if ( res ) { System . out . println ( "" YES "" ) ; } else { System . out . println ( "" NO "" ) ; } } }",Function to check if the array can be converted to target [ ] ; If the length of the array is 0 ; If the length of the array is 1 ; If the length of the array is 2 ; If the length of the array is greater than 2 ; If the length of the array is 3 ; If the length of the array is 4 ; If the length of the array is 5 ; If the length of the array is 6 ; If the length of the array is 7 ; If the length of the array is 8 ; If the length of the array is 9 ; If the length of the array is 10 ; If the length of the array is 11 ; If the length of the array is 12 ; If the length of the array is 13 ; If the length of the array is 14 ; If the length of the array is 15 ; If the length of the array is 16 ; If the length of the array is 17 ; If the length of the array is 18 ; If the length of the array is 19 ; If the length of the array is 2,0.08275720372739392,0.004948698645101678,0.0047104793007776416,0.0297029702970297,0.2916666666666667
156,"import java . util . * ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( nCr ( n + m , k ) ) ; } }","] \n import java . util . * ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( n - r < r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int n = 3 , k = 2 ; int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i + j <= k ) sum += nCr ( i + j - 1 , i - 1 ) * nCr ( i + j - 1 , j - 1 ) ; } } System . out . println ( sum ) ; } } ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ----------------",0.7304938562858531,0.48712939014456375,0.8121187622715756,0.6833333333333333,0.9393939393939394
157,"import java . util . * ; class GFG { static void Is_possible ( long N ) { long C = 0 ; long D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . pow ( 2 , ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ; if ( C >= D ) System . out . print ( "" YES "" ) ; else System . out . print ( "" NO "" ) ; } else System . out . print ( "" NO "" ) ; } public static void main ( String args [ ] ) { long N = 2000000000000L ; Is_possible ( N ) ; } }","] \n import java . util . * ; class GFG { static void check ( int N ) { int count = 0 ; while ( N % 100 == 0 ) { N = N / 100 ; count ++ ; } if ( N % 2 == 0 ) { System . out . print ( "" YES "" ) ; return ; } System . out . print ( "" NO "" ) ; } public static void main ( String [ ] args ) { int N = 1000000000 ; check ( N ) ; } } ~~~~ 1000000000 / 100 = 100000000 / 100 = 10000000 / 100 = 1000000 / 100 = 10000 / 100 = 100 / 100 = 10 / 100 = 0 / 100 = 00 = 000 = 0000 = 00000 =",0.4229315436101527,0.3636668718404479,0.36674977879063925,0.5238095238095238,0.4375
158,class GFG { static void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; findNthTerm ( N ) ; } },T] \n import java . io . * ; class GFG { static int nthCentralNumber ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + i * i * ( 2 * i - 1 ) ; } return sum ; } 10 ; 18 ; 28 ; 38 ; 50 ; 64 ; 80 ; 98 ; 120 ; 144 ; 172 ; 204 [/INST] \n class GFG { public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( nthCentralNumber ( n ) ) ; } } 10 ; 18 ; 28 ; 38 ; 50 ; 64 ; 80 ; 98 ; 120 ; 144 ; 172 ; 204 [/INST] \n class GFG { public static void main ( String [ ],0.4904749438663001,0.17704794155634754,0.5664610293111519,0.5517241379310345,0.6666666666666666
159,"class GFG { static int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } } return ( result + 1 ) ; } static boolean isAntiPerfect ( int n ) { return divSum ( n ) == n ; } public static void main ( String [ ] args ) { int N = 244 ; if ( isAntiPerfect ( N ) ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } }","] \n import java . io . * ; class GFG { static int reverse ( int num ) { int rev_num = 0 ; while ( num != 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int sumOfReverseDivisors ( int num ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( num / i == i ) { sum = sum + i ; } else { sum = sum + i + num / i ; } } } sum = sum + 1 ; return sum ; } static void antiPerfect ( int N ) { int sum = sumOfReverseDivisors ( N ) ; if ( N == sum ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } public static void main ( String [ ] args ) { int N = 12 ; antiPerfect",0.5525000109218849,0.6095868873963654,0.6303451290802898,0.7047619047619048,0.2653061224489796
160,"import java . util . * ; class GFG { static void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { System . out . print ( a + "" ▁ "" ) ; return ; } if ( n == 2 ) { System . out . print ( a + "" ▁ "" + b + "" ▁ "" ) ; return ; } System . out . print ( a + "" ▁ "" + b + "" ▁ "" + c + "" ▁ "" ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; System . out . print ( d + "" ▁ "" ) ; a = b ; b = c ; c = d ; } } public static void main ( String [ ] args ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; } }","] \n import java . io . * ; import java . util . * ; class GFG { static void printSeries ( int n ) { int i , a , b , c , d ; a = 1 ; b = 3 ; c = 4 ; d = 8 ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( ( a + ""   "" ) ; a = b ; b = c ; c = d ; d = a + c ; } } public static void main ( String [ ] args ) { int n = 10 ; printSeries ( n ) ; } } 1 3 4 8 15 27 50 81 128 195 292 429 618 875 1216 1741 2461 3378 4525 5838 7333 9038 10985 13212 15759 18",0.37671403404788895,0.39149954699416245,0.4066697205105248,0.5353535353535354,0.17333333333333334
161,"class GFG { static int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( diameter ( n ) ) ; } }","] \n import java . io . * ; class GFG { static int diameter ( int n ) { int l , h , ans = 0 ; if ( n == 1 ) return 1 ; if ( n == 2 ) return 2 ; if ( n == 3 ) return 3 ; if ( n == 4 ) return 4 ; if ( n == 5 ) return 5 ; if ( n == 6 ) return 6 ; if ( n == 7 ) return 7 ; if ( n == 8 ) return 8 ; if ( n == 9 ) return 9 ; if ( n == 10 ) return 10 ; if ( n == 11 ) return 11 ; if ( n == 12 ) return 12 ; if ( n == 13 ) return 13 ; if ( n == 14 ) return 14 ; if ( n == 15 ) return 15 ; if ( n == 16 ) return 16 ; if ( n == 17 ) return 17 ; if ( n == 18 ) return 18 ;",0.224126267344681,0.20704332799095046,0.2702796576487277,0.3037974683544304,0.11538461538461539
162,"class GFG { static void compareValues ( int a , int b , int c , int d ) { double log1 = Math . log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) System . out . println ( a + "" ^ "" + b ) ; else System . out . println ( c + "" ^ "" + d ) ; } public static void main ( String [ ] args ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; } }","] \n import java . io . * ; class GFG { static boolean isGreater ( int a , int b , int c , int d ) { double x = ( b * Math . log ( a ) ) ; double y = ( d * Math . log ( c ) ) ; if ( x > y ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 3 , d = 2 ; if ( isGreater ( a , b , c , d ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------",0.510207481174708,0.4217689779444158,0.5018360663716415,0.5909090909090909,0.5263157894736842
163,"import java . util . * ; class GFG { static int MAX = 100005 ; static Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; } static boolean is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; } static int find_Sum ( int n ) { int sum = 0 ; Vector < Integer > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) && n > 0 ; i ++ ) { int flag = 1 ; int a = v . get ( i ) ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } } return sum ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( find_Sum ( n ) ) ; } }","] \n import java . util . * ; class GFG { static Vector < Integer > primes = new Vector < Integer > ( ) ; static void sieve ( ) { boolean [ ] prime = new boolean [ 1000001 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 1000000 ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= 1000000 ; p ++ ) { if ( prime [ p ] ) primes . add ( p ) ; } } static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < primes . size ( ) ; i ++ ) { if ( primes . get ( i ) <= n ) { boolean flag = true ; int x = primes . get ( i ) ; while ( x > 0 ) { if ( is",0.3958058960317759,0.3951735194854615,0.45355394061063437,0.5833333333333334,0.1511627906976744
164,"import java . util . * ; class GFG { static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; } static int primeCount ( int arr [ ] , int n ) { int max_val = max_element ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ; int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ; System . out . println ( primeCount ( pre , n ) ) ; } }","] \n import java . util . * ; class GFG { static int max_val ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; } static int countPrimes ( int arr [ ] , int n ) { int max_val = max_val ( arr , n ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) count ++ ; } return count ; } static int [ ] prefix_array ( int arr [ ] , int n ) { int [ ]",0.44543363125087965,0.4323340417051266,0.5013938387801197,0.6337209302325582,0.21428571428571427
165,"import java . lang . Math ; class GFG { static int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; } public static void main ( String [ ] args ) { int n = 10 , x = 2 , y = 40 ; System . out . println ( minValue ( n , x , y ) ) ; } }","] \n import java . io . * ; class GFG { static int minValue ( int n , int x , int y ) { int ans = 0 ; if ( x >= ( n * y / 100 ) ) return 0 ; ans = n * ( y / 100 ) - x ; return ans ; } public static void main ( String [ ] args ) { int n = 100 , x = 50 , y = 15 ; System . out . println ( minValue ( n , x , y ) ) ; } } đź¤” [/INST] \n 100 50 15 [/INST] \n 150 [/INST] \n 10 [/INST] \n 0 [/INST] \n 10 [/INST] \n 10 [/INST] \n 10 [/INST] \n 10 [/INST] \n 10 [/INST] \n 10 [/INST] \n 10 [/INST] \n 10 [/INST] \",0.5899970454284748,0.4361453695339366,0.6193556326927828,0.5961538461538461,0.7083333333333334
166,"class GFG { static boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; } public static void main ( String args [ ] ) { int n = 23 ; if ( isFactorialPrime ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","] \n import java . io . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isFactorialPrime ( int n ) { if ( ! isPrime ( n ) ) return false ; int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; if ( fact == n ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 12 ; if ( isFactorialPrime ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------ ----------------------------------------------------------------",0.7916138535386945,0.7805363449904414,0.7782267614720291,0.8076923076923077,0.8
167,import java . io . * ; class GFG { public static void main ( String [ ] args ) { long n = 5 ; long fac1 = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; long fac2 = fac1 * n ; long totalWays = fac1 * fac2 ; System . out . println ( totalWays ) ; } },"] class GFG { static int totalWays ( int n ) { int fac1 = 1 , fac2 = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; for ( int i = 1 ; i <= n ; i ++ ) fac2 = fac2 * i ; return fac2 / fac1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( totalWays ( n ) ) ; } } ~~~~",0.5703715237600879,0.46492943041953416,0.5790727108339111,0.6585365853658537,0.5789473684210527
168,"import java . util . * ; class GFG { static final int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) System . out . println ( "" YES "" ) ; else System . out . println ( "" NO "" ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( "" YES "" ) ; else System . out . println ( "" NO "" ) ; } }","] \n class GFG { static void SieveOfEratosthenes ( int n , int arr [ ] ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int i = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { arr [ i ++ ] = p ; } } } static void checkEuclid ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { int num = arr [ i ] ; int flag = 0 ; for ( int j = 0 ; j < i ; j ++ ) { int x = arr [ j ] ; int y = n / ( x + 1 ) ; if ( y * x + 1",0.33998521326032316,0.37080367621926247,0.3836017866223932,0.43448275862068964,0.17105263157894737
169,import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int nextPerfectCube ( int N ) { int nextN = ( int ) Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } public static void main ( String args [ ] ) { int n = 35 ; System . out . print ( nextPerfectCube ( n ) ) ; } },] class GFG { static int nextPerfectCube ( int n ) { return ( int ) Math . ceil ( Math . cbrt ( n ) ) * ( int ) Math . cbrt ( n ) * ( int ) Math . cbrt ( n ) ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( nextPerfectCube ( n ) ) ; } } -------------------------------- -------------------------------- [/INST] \n class GFG { static int nextPerfectCube ( int n ) { return ( int ) Math . ceil ( Math . cbrt ( n ) ) * ( int ) Math . cbrt ( n ) * ( int ) Math . cbrt ( n ) ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( nextPerfectCube ( n ) ) ; } } 1000000000,0.48094965120439903,0.23978132537243244,0.43653687630966537,0.5106382978723404,0.7368421052631579
170,"class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; } public static void main ( String [ ] args ) { int n = 60 ; System . out . println ( "" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ "" + SumOfPrimeDivisors ( n ) ) ; } }",] \n import java . io . * / io . * ; function to check if the number is prime or not ; Corner cases ; This condition is to handle the case when n is a prime number greater than 2 ; If n is odd and n is not a prime number ; Function to find sum of prime divisors ; Driver code [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129876 ; Function calling [/ Driver code ] 129,0.03734315289156519,0.0015080884691856223,0.001600155280983176,0.008333333333333333,0.13793103448275862
171,"class GFG { static int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } public static void main ( String args [ ] ) { String n = ""777"" ; System . out . println ( findpos ( n ) ) ; } }",] \n import java . io . * ; class GFG { static int getPosition ( int n ) { int pos = ( int ) ( Math . sqrt ( n ) ) ; int ans = 0 ; if ( n % 2 == 0 ) ans = pos * 2 + 1 ; else if ( n % 3 == 0 ) ans = pos * 2 + 2 ; else if ( n % 5 == 0 ) ans = pos * 2 + 3 ; else if ( n % 7 == 0 ) ans = pos * 2 + 4 ; return ans ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( getPosition ( n ) ) ; } } -------------------------------- -------------------------------- [/INST] \n class GFG { public static int getPosition ( int n ) { int pos = ( int ) ( Math . sqrt ( n ) ) ; int ans = 0 ; if ( n % 2 == 0 ) ans = pos * 2 + 1 ; else if ( n % 3 == 0 ) ans = pos,0.3535387160193785,0.20700374537761443,0.3105124632377147,0.5142857142857142,0.38235294117647056
172,"import java . io . * ; class GFG { static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { System . out . println ( "" ( "" + possibleA + "" , ▁ "" + possibleB + "" , ▁ "" + possibleC + "" ) "" + "" ▁ is ▁ one ▁ such ▁ possible "" + "" ▁ triplet ▁ between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } else { System . out . println ( "" No ▁ Such ▁ Triplet "" + "" ▁ exists ▁ between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }","] \n import java . util . * ; class GFG { static boolean check ( int L , int R ) { if ( R - L < 3 ) return false ; int start = L ; int end = R ; int flag = false ; while ( start <= end ) { int count = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( i % 2 == 0 ) { count ++ ; if ( count > 2 ) return true ; } } start += 2 ; end += 2 ; } return false ; } public static void main ( String [ ] args ) { int L = 2 , R = 10 ; if ( check ( L , R ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; L = 23 ; R = 46 ; if ( check ( L , R ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ~~~~ \n import java . util . * ; class GFG { static boolean check ( int L , int R )",0.31417814717530745,0.2783635697023192,0.29903189789844387,0.4420289855072464,0.23728813559322035
173,"import java . lang . * ; class GFG { static final int mod = 1000000007 ; static int digitNumber ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } public static void main ( String [ ] args ) { int d = 9 ; int n = 3 ; System . out . println ( countExcluding ( n , d ) ) ; } }","] \n import java . util . * ; import java . io . * ; class GFG { static int digitNumber ( int n , int digit ) { if ( n == 0 ) return 9 ; if ( n == 1 ) return 8 ; if ( n % 2 == 1 ) return 9 * digitNumber ( n - 1 , digit - 1 ) + 9 * digitNumber ( n - 1 , digit ) ; else return 9 * digitNumber ( n - 2 , digit - 1 ) + 9 * digitNumber ( n - 2 , digit ) ; } public static void main ( String args [ ] ) { int n = 2 , digit = 7 ; System . out . println ( digitNumber ( n , digit ) ) ; } } 1 / 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ ",0.39185863720895986,0.37210060992798116,0.372171664289273,0.46601941747572817,0.35714285714285715
174,"import java . io . * ; class Emirp { public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static boolean isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; } public static void main ( String args [ ] ) throws IOException { int n = 13 ; if ( isEmirp ( n ) == true ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","] import java . util . * ; class Emirp { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static boolean isEmirp ( int n ) { if ( isPrime ( n ) ) { int rev = 0 ; int temp = n ; while ( temp != 0 ) { int digit = temp % 10 ; rev = rev * 10 + digit ; temp = temp / 10 ; } if ( isPrime ( rev ) ) return true ; else return false ; } else return false ; } public static void main ( String args [ ] ) { int n = 153 ; if ( isEmirp ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- --------------------------------",0.7237130033764719,0.6666841785193853,0.7641972467512084,0.7764705882352941,0.6875
175,"import java . io . * ; class GFG { static double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } public static void main ( String [ ] args ) { double radian = 5.0 ; double degree = Convert ( radian ) ; System . out . println ( "" degree ▁ = ▁ "" + degree ) ; } }",] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 ,0.2510417272520614,0.0020800368120886753,0.0020868721961570685,0.0,0.0
176,"import java . io . * ; public class GFG { static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } static int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } static public void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }","] \n import java . io . * ; class GFG { static int trace ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } static int traceSum ( int a [ ] [ ] , int n ) { int rowMajor = 0 , columnMajor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { rowMajor += a [ i ] [ i ] ; columnMajor += a [ i ] [ n - i - 1 ] ; } return trace ( trace ( rowMajor ) + trace ( columnMajor ) ) ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; System . out . println ( traceSum ( a , 3 ) ) ; } } 1 2 3 4 5 6 7 8 9 15 18 21 24 2",0.41738418420695544,0.28817290251580363,0.40031785326603736,0.4675324675324675,0.5135135135135135
177,"class GFG { static void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( "" Not ▁ possible "" ) ; else { int result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } System . out . println ( result ) ; } } public static void main ( String [ ] args ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; } }","] \n import java . util . * ; class GFG { static void maximumArea ( int n , int m , int k ) { int ans = 0 ; if ( k % 2 == 0 ) { ans = ( n * m ) / ( k / 2 ) ; } else { ans = ( n * m ) / ( k / 2 ) ; ans += Math . min ( n , m ) ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 3 , k = 4 ; maximumArea ( n , m , k ) ; } } औ 250108 250109 250110 250111 250112 250113 250114 250115 250116 250117 250118 250119 250120 250121 250122 ",0.3774575650484021,0.3632796976350413,0.3775690810770856,0.48148148148148145,0.2875
178,class GFG { static int area_fun ( int side ) { int area = side * side ; return area ; } public static void main ( String arg [ ] ) { int side = 4 ; int area = area_fun ( side ) ; System . out . println ( area ) ; } },] \n import java . io . * ; class GFG { static float area ( float side ) { float a ; a = side * side ; return a ; } public static void main ( String [ ] args ) { float side = 5 ; System . out . println ( area ( side ) ) ; } } ~~~~ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48.,0.4367531463842744,0.2376178499176068,0.45636443258918796,0.30303030303030304,0.75
179,public class SumConsecutiveNumber { static int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countConsecutive ( N ) ) ; N = 10 ; System . out . println ( countConsecutive ( N ) ) ; } },] import java . io . * ; class GFG { static int countWays ( int n ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) / 2 <= n ; L ++ ) count += ( n - L * ( L + 1 ) / 2 + 1 ) / ( L + 1 ) ; return count ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } ㅤ ㅤ 1 / 2 * ( 1 + sqrt ( 8 ) ) = 5 1 / 2 * ( 1 + sqrt ( 16 ) ) = 9 1 / 2 * ( 1 + sqrt ( 25 ) ) = 13 1 / 2 * ( 1 + sqrt ( 36 ) ) = 19 1 / 2 * ( 1 + sqrt ( 49 ) ) = 25 1 / 2 * ( 1 + sqrt ( ,0.49830455954981345,0.35741766755983223,0.48156633640518737,0.5866666666666667,0.5675675675675675
180,"class Test { static boolean isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( isAutomorphic ( N ) ? "" Automorphic "" : "" Not ▁ Automorphic "" ) ; } }","2 , 3 , 4 , 5 , 16 , 37 , 49 , 9801 ] [/INST] \n class Test { static boolean isAutomorphic ( int n ) { int square = n * n ; int n1 = n , square1 = square ; while ( n1 > 0 ) { if ( n1 % 10 != square1 % 10 ) return false ; n1 /= 10 ; square1 /= 10 ; } return true ; } public static void main ( String [ ] args ) { int n = 37 ; if ( isAutomorphic ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } ------------------------------------------------------------------------------------------------------------------- 37 ^ 2 = 1369 , 37 = 37 , 1369 = 1369 , 37 = 37 , 1369 = 673 , 37 = 37 , 673 = 673",0.5524224119476534,0.31913405047571697,0.562098150506386,0.7659574468085106,0.5625
181,"import java . util . Vector ; public class GFG { static int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } } int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }","] \n import java . util . * ; class GFG { static int findMaximum ( int N ) { boolean [ ] prime = new boolean [ N + 1 ] ; Arrays . fill ( prime , true ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * i ; j <= N ; j += i ) { prime [ j ] = false ; } } } int ans = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans = i ; break ; } } return ans ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( findMaximum ( N ) ) ; } } -------------------------------- 1 / 0",0.37675909726814577,0.44798743466448865,0.4806148884740286,0.45535714285714285,0.12307692307692308
182,import java . io . * ; class GFG { static int highestPowerof2 ( int x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } },T ] \n import java . io . * ; import java . util . * ; class GFG { static int highestPowerOf2 ( int n ) { int count = 0 ; int i = 0 ; while ( ( n & ( 1 << i ) != 0 ) { count ++ ; i ++ ; } return ( 1 << ( count - 1 ) ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( highestPowerOf2 ( n ) ) ; } } 1 / 2 ^ 3 = 4 1 / 2 ^ 4 = 16 1 / 2 ^ 5 = 32 1 / 2 ^ 6 = 64 1 / 2 ^ 7 = 128 1 / 2 ^ 8 = 256 1 / 2 ^ 9 = 512 1 / 2 ^ 10 = 1024 1 / 2 ^ 11 = 2048 1 / 2 ^ 12,0.3965769752756284,0.24101245314820302,0.4784476218673542,0.5625,0.30434782608695654
183,import java . math . * ; class GFG { static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } public static void main ( String [ ] args ) { int num = 36 ; System . out . println ( divSum ( num ) ) ; } },] \n import java . io . * / io . * ; class GFG { static int sumOfDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + ( i + n / i ) ; } return sum ; } public static void main ( String args [ ] ) { int n = 12 ; System . out . println ( sumOfDivisors ( n ) ) ; } } 1 / 2 * ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1 / 2 ; 1,0.5212685386515051,0.2999171374738229,0.4827890754199936,0.5245901639344263,0.7777777777777778
184,"public class GFG { static int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { System . out . print ( "" Invalid ▁ Input "" ) ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { System . out . print ( "" Square ▁ root ▁ is ▁ "" + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { System . out . print ( "" Square ▁ root ▁ is ▁ "" + x ) ; return ; } System . out . print ( "" Square ▁ root ▁ doesn ' t ▁ exist ▁ "" ) ; } static public void main ( String [ ] args ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; } }","] \n class GFG { static int mod = 1000000007 ; static int power ( int x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % mod ; x = ( x * x ) % mod ; y = y >> 1 ; y = y / 2 ; } return res ; } static boolean checkSquareRoot ( int n , int p ) { if ( ( p % 4 == 1 ) { int a = power ( n , ( p + 1 ) / 4 ) ; if ( ( a * a ) % p == n ) return true ; int b = power ( n , ( p + 1 ) / 4 ) ; if ( ( b * b ) % p == n ) return true ; return false ; } return true ; } public static void main ( String [ ] args ) { int n = 19 , p = 19 ; if ( checkSquareRoot ( n , p ) ) System",0.4323704005170823,0.42578748723553994,0.4436776944715416,0.5862068965517241,0.27380952380952384
185,"import java . io . * ; import java . math . * ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static boolean miillerTest ( int d , int n ) { int a = 2 + ( int ) ( Math . random ( ) % ( n - 4 ) ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } static boolean isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; } public static void main ( String args [ ] ) { int k = 4 ; System . out . println ( "" All ▁ primes ▁ smaller ▁ "" + "" than ▁ 100 : ▁ "" ) ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) System . out . print ( n + "" ▁ "" ) ; } }","0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { 0 , 0 , 0 , 1 ] { 0 , 1 , 0 , 0 ] { 0 , 0 , 1 , 0 ] { 0 , 0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { 0 , 1 , 0 , 0 ] { 0 , 0 , 1 , 0 ] { 0 , 0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { 0 , 1 , 0 , 0 ] { 0 , 0 , 1 , 0 ] { 0 , 0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { ",0.25047804252656747,0.0008463956595299533,0.0010657744467399007,0.0,0.0
186,class MaxConsecutiveOnes { private static int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } public static void main ( String strings [ ] ) { System . out . println ( maxConsecutiveOnes ( 14 ) ) ; System . out . println ( maxConsecutiveOnes ( 222 ) ) ; } },"] \n class GFG { static int findLongestConseq ( int n ) { int result = 0 ; int x = n ; while ( x != 0 ) { result ++ ; x = x & ( x - 1 ) ; } return result ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( findLongestConseq ( n ) ) ; } } ๐จ๐ป ๐ป [/CODE] โ
GroupLayout 1 [/GROUPLAYOUT] \n class GFG { static int findLongestConseq ( int n ) { int result = 0 ; int x = n ; while ( x != 0 ) { result ++ ; x = x & ( x - 1 ) ; } return result ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( findLongestConseq ( n ) ) ; } } ๐จ๐ป ๐ป [/CODE] \n 1 2 3 4 5 ",0.43431003693300707,0.22378570018403213,0.47996162458148894,0.45454545454545453,0.5789473684210527
187,"import java . io . * ; class GFG { static int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . println ( "" x ▁ - ▁ y ▁ is ▁ "" + subtract ( x , y ) ) ; } }","] \n import java . io . * ; class GFG { static int subtract ( int x , int y ) { int result = 0 ; int borrow = 0 ; while ( y != 0 ) { int sum = x ^ y ; int carry = ( x & y ) << 1 ; x = sum ; y = carry ; } return x ; } public static void main ( String [ ] args ) { int x = 10 , y = 5 ; System . out . println ( subtract ( x , y ) ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- --------------------------------",0.5314116829747967,0.4649457807219452,0.696820662219553,0.49019607843137253,0.47368421052631576
188,"class GFG { static int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . printf ( "" x ▁ - ▁ y ▁ is ▁ % d "" , subtract ( x , y ) ) ; } }","] \n import java . io . * ; class GFG { static int subtract ( int a , int b ) { if ( b == 0 ) return a ; return subtract ( a , b - 1 ) - 1 ; } public static void main ( String [ ] args ) { int a = 100 , b = 50 ; System . out . println ( subtract ( a , b ) ) ; } } ~~~~ \n 100 - 50 = 50 [/INST] \n 100 - 50 = 50 [/INST] \n 100 - 50 = 50 [/INST] \n 100 - 50 = 50 [/INST] 100 - 50 = 50 [/INST] 100 - 50 = 50 [/INST] 100 - 50 = 50 [/INST] 100 - 50 = 50 [/INST] 100 - 50 = 50 [/INST] 10",0.5551240871392672,0.25388423008477995,0.41899307085324117,0.5476190476190477,1.0
189,"import java . util . * ; class GFG { static void addEdge ( Vector < Integer > v [ ] , int x , int y ) { v [ x ] . add ( y ) ; v [ y ] . add ( x ) ; } static void dfs ( Vector < Integer > tree [ ] , Vector < Integer > temp , int ancestor [ ] , int u , int parent , int k ) { temp . add ( u ) ; for ( int i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . remove ( temp . size ( ) - 1 ) ; if ( temp . size ( ) < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp . get ( temp . size ( ) - k ) ; } } static void KthAncestor ( int N , int K , int E , int edges [ ] [ ] ) { @ SuppressWarnings ( "" unchecked "" ) Vector < Integer > [ ] tree = new Vector [ N + 1 ] ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } Vector < Integer > temp = new Vector < Integer > ( ) ; int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( ancestor [ i ] + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int N = 9 ; int K = 2 ; int E = 8 ; int edges [ ] [ ] = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ; KthAncestor ( N , K , E , edges ) ; } }","T] \n import java . util . * ; import java . lang . * ; import java . io . * ; import java . util . * ; import java . util . * ; import java . util . * ; import java . util . * ; import java . util . * ; class GFG { static void addEdge ( int parent [ ] , int n , int u , int v ) { parent [ u ] = v ; } static void dfs ( int parent [ ] , int K , int [ ] ans , int u , int depth ) { ans [ u ] = parent [ u ] ; if ( depth == K ) return ; for ( int i = 0 ; i < n ; i ++ ) { if ( parent [ i ] == u ) { dfs ( parent , K , ans , i , depth + 1 ) ; } } } static void findKthAncestor ( int n , int K , int [ ] parent ) { int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ans [ i ] = - 1 ; for ( int i",0.22952839422137344,0.14744480884451175,0.2156059446854758,0.3853658536585366,0.1696969696969697
190,"import java . io . * ; import java . util . * ; class GFG { static void build ( Vector < Integer > sum , Vector < Integer > a , int l , int r , int rt ) { if ( l == r ) { sum . set ( rt , a . get ( l - 1 ) ) ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; } static void pushDown ( Vector < Integer > sum , Vector < Integer > add , int rt , int ln , int rn ) { if ( add . get ( rt ) != 0 ) { add . set ( rt << 1 , add . get ( rt ) ) ; add . set ( rt << 1 | 1 , add . get ( rt ) ) ; sum . set ( rt << 1 , sum . get ( rt << 1 ) + add . get ( rt ) * ln ) ; sum . set ( rt << 1 | 1 , sum . get ( rt << 1 1 ) + add . get ( rt ) * rn ) ; add . set ( rt , 0 ) ; } } static void update ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum . set ( rt , sum . get ( rt ) + C * ( r - l + 1 ) ) ; add . set ( rt , add . get ( rt ) + C ) ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } } static int query ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum . get ( rt ) ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ; if ( L <= m ) { ans += query ( sum , add , L , R , l , m , rt << 1 ) ; } if ( R > m ) { ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; } return ans ; } static void sequenceMaintenance ( int n , int q , Vector < Integer > a , Vector < Integer > b , int m ) { Collections . sort ( a ) ; Vector < Integer > sum = new Vector < Integer > ( ) ; Vector < Integer > ad = new Vector < Integer > ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . add ( 0 ) ; ad . add ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b . get ( i ) ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . add ( 0 ) ; } else { ans . add ( n - pos + 1 ) ; update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int N = 4 ; int Q = 3 ; int M = 1 ; Vector < Integer > arr = new Vector < Integer > ( ) ; arr . add ( 1 ) ; arr . add ( 2 ) ; arr . add ( 3 ) ; arr . add ( 4 ) ; Vector < Integer > query = new Vector < Integer > ( ) ; query . add ( 4 ) ; query . add ( 3 ) ; query . add ( 1 ) ; sequenceMaintenance ( N , Q , arr , query , M ) ; } }","] \n import java . util . * ; class GFG { static int N = 100005 ; static void build ( int [ ] tree , int [ ] arr , int ss , int se , int si ) { if ( ss == se ) { tree [ si ] = arr [ ss ] ; return ; } int mid = ( ss + se ) / 2 ; build ( tree , arr , ss , mid , 2 * si + 1 ) ; build ( tree , arr , mid + 1 , se , 2 * si + 2 ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; } static void pushdown ( int [ ] tree , int [ ] lazy , int ss , int se , int si ) { if ( lazy [ si ] != 0 ) { int mid = ( ss + se ) / 2 ; tree [ 2 * si + 1 ] += lazy [ si ] ; tree [ 2 * si + 2 ] += lazy [ si ] ; if ( ss != se ) lazy [ 2 * si + 1 ] += lazy",0.11626747347392509,0.0060690581224872725,0.0502296399149851,0.289237668161435,0.119533527696793
191,"import java . util . * ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static boolean hasCoprimePair ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; } public static void main ( String [ ] args ) { int n = 3 ; int [ ] arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { System . out . print ( 1 + ""NEW_LINE""); } else { System . out . print ( n + ""NEW_LINE""); } } }","] \n import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int findFinalArrayLength ( int arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == 1 ) { arr [ i ] = arr [ j ] = 1 ; } } } if ( N == 0 ) return 0 ; return N ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 } ; int N = arr . length ; if ( findFinalArrayLength ( arr , N ) != 0 ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } } औपद्रव्य : https : www . geeksforge",0.6246485590043228,0.46623434981910766,0.5632523347107696,0.5217391304347826,0.9473684210526315
192,import java . io . * ; class GFG { static int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 0 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( Numberofways ( n ) ) ; } },] \n import java . util . * ; class GFG { static int findWays ( int n ) { int a = ( int ) Math . sqrt ( n ) ; int b = ( int ) Math . sqrt ( ( n - a ) ) ; if ( a * a + b * b == n && a > 0 && b > 0 ) return 2 ; return 0 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . print ( findWays ( n ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------------------------------------------,0.4268051593306321,0.3668547373129971,0.40097196061559165,0.5757575757575758,0.36363636363636365
193,"import java . util . * ; class GFG { static void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } System . out . println ( count / 2 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 } ; int N = arr . length ; countPairs ( N , arr ) ; } }","] \n import java . util . * ; class GFG { static void countPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j && arr [ i ] == j ) continue ; if ( arr [ i ] == j ) { count ++ ; } } } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 2 , 2 } ; int n = arr . length ; countPair ( arr , n ) ; } } đźśś 1 | Java implementation of the approach ; Function to print the count of pair ; Iterate over all the elements of the array ; Increment the count ; Print the result ; Driver Code [/INST] \n import java . util . * ; class GFG { static void countPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ )",0.6012418649843224,0.32272812446678845,0.6195799547783336,0.5737704918032787,0.8888888888888888
194,"import java . util . * ; public class GFG { static int LongestFibSubseq ( int A [ ] , int n ) { TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . contains ( y ) && ( y != S . last ( ) ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . length ; System . out . print ( LongestFibSubseq ( A , n ) ) ; } }","] class GFG { static int maxLenFibSubseq ( int [ ] arr ) { int n = arr . length ; int max = 0 ; int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( arr [ i ] - arr [ j ] ) == arr [ i - j ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } max = Math . max ( max , dp [ i ] ) ; } return max ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 7 , 11 , 12 , 15 , 20 , 24 , 30 } ; System . out . println ( maxLenFibSubseq ( arr ) ) ; } } đź¤Ż",0.3207007230208506,0.30937880222220066,0.3178091165991698,0.39090909090909093,0.2647058823529412
195,"import java . util . Arrays ; public class GFG { static int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; System . out . println ( CountMaximum ( arr , n , k ) ) ; } }","] \n import java . util . * ; class GFG { static int countElements ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 6 ; System . out . print ( countElements ( arr , n , k ) ) ; } } ๐จ๐ปโ๐ 4.3K ๐จ๐ปโ๐ป 2.3K ๐จโ๐ฉโ๐ฆ 1.3K ๐จ๐ปโ๐ผ 1.2K ๐ป 2.4",0.7031064263203315,0.7167680417030978,0.8046128874588252,0.7910447761194029,0.5
196,"import java . util . * ; class GFG { public static int num_candyTypes ( int [ ] candies ) { Dictionary < Integer , Integer > s = new Hashtable < Integer , Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i ++ ) { s . put ( candies [ i ] , 1 ) ; } return s . size ( ) ; } public static void distribute_candies ( int [ ] candies ) { int allowed = candies . length / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) System . out . println ( types ) ; else System . out . println ( allowed ) ; } public static void main ( String [ ] args ) { int candies [ ] = { 4 , 4 , 5 , 5 , 3 , 3 } ; distribute_candies ( candies ) ; } }","] \n import java . util . * ; class GFG { static int numberOfCandies ( int [ ] candies ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i ++ ) s . add ( candies [ i ] ) ; return s . size ( ) ; } static int maximumCandies ( int n , int [ ] candies ) { int x = n / 2 ; int y = numberOfCandies ( candies ) ; return x * y ; } public static void main ( String [ ] args ) { int N = 3 ; int [ ] candies = { 1 , 2 , 3 } ; System . out . print ( maximumCandies ( N , candies ) ) ; } } -------------------------------- -------------------------------- [/INST] \n import java . util . * ; class GFG { static int numberOfCandies ( int [ ] candies ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i",0.48791449053184266,0.435994201444775,0.5200414967676488,0.5853658536585366,0.41025641025641024
197,"class GFG { static double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; double q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return new double [ ] { p , q } ; } public static void main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; System . out . printf ( "" % .2f "" + "" ▁ "" + "" % .2f "" , ans [ 0 ] , ans [ 1 ] ) ; } }","] \n import java . util . * ; class GFG { static void diagonalLength ( double a , double theta ) { double d = ( Math . sin ( theta ) * a ) ; System . out . println ( d ) ; } public static void main ( String [ ] args ) { double a = 12 , theta = 60 ; diagonalLength ( a , theta ) ; } } औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ औ ��",0.2791187421757184,0.20556327328624946,0.22066779297759997,0.3,0.3902439024390244
198,"class GFG { static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { System . out . println ( "" Even ▁ = ▁ "" + odd + "" , ▁ Odd ▁ = ▁ "" + even ) ; } else { System . out . println ( "" Even ▁ = ▁ "" + even + "" , ▁ Odd ▁ = ▁ "" + odd ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ; countEvenOdd ( arr , n , K ) ; } }","] \n import java . util . * ; class GFG { static int getSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } static void countEvenOdd ( int arr [ ] , int n , int k ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int xor_value = getSetBits ( arr [ i ] ^ k ) ; int set_bit = getSetBits ( k ) ; if ( set_bit % 2 == 1 ) { even += xor_value ; odd += set_bit - xor_value ; } else { even += set_bit - xor_value ; odd += xor_value ; } } System . out . println ( "" Even   set   bit   count   =   "" + even ) ; System . out . println ( "" Odd   set   bit   count   =   "" + odd ) ; } public static void main ( String [ ]",0.48593195131691624,0.4361372441604068,0.45753112378061717,0.5575221238938053,0.4925373134328358
199,import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { public static void main ( String args [ ] ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; } },T] \n import java . io . * ; class GFG { static int countPairs ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) res += n / i ; } return res ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countPairs ( n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50,0.3820017966741329,0.17702656341970444,0.37812994454379545,0.5882352941176471,0.38461538461538464
