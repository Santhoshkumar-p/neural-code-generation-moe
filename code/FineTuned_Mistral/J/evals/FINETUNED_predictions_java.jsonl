{"value":"] \\n class GFG { static int minSum ( int arr [ ] , int N ) { int [ ] freq = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += ( i + 1 ) * freq [ i ] ; } int minSum = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 1 ) { minSum -= ( freq [ i ] - 1 ) * ( i + 1 ) ; } } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 4 } ; int N = arr . length ; System . out . println ( minSum ( arr , N ) ) ; } } aupt ; 1 ; 2 ; 2 ; 3 ; 4 ; 4 ; 1 ; 2 ; 2 ; "}
{"value":"] = { 1 , 2 , 3 , 4 , 5 , 6 } ; Function call [\/ INPUT ] 1 2 3 4 5 6 [\/ INPUT ] ------------------------------------------------- 4 [\/ INPUT ] 1 2 3 4 5 6 [\/ INPUT ] --------------------------------- - 2 [\/ INPUT ] 1 2 3 4 5 6 [\/ INPUT ] --------------------------------- - 3 [\/ INPUT ] 1 2 3 4 5 6 [\/ INPUT ] --------------------------------- - 4 [\/ INPUT ] 1 2 3 4 5 6 [\/ INPUT ] --------------------------------- - 5 [\/ INPUT ] 1 2 3 4 5 6 [\/ INPUT ] --------------------------------- - 6 [\/ INPUT ] 1 2 3 4 5 6 [\/ INPUT ] --------------------------------- - 1 [\/ INPUT ] 1 2 3 "}
{"value":"] \\n class GFG { static int findSize ( int N ) { if ( N == 1 ) return 1 ; int Siz_M = findSize ( N \/ 2 ) ; if ( N % 2 == 0 ) return 2 * Siz_M ; else return 2 * Siz_M + 1 ; } static int countOnes ( int arr [ ] , int L , int R , int N ) { if ( L > R ) return 0 ; if ( L == R ) return arr [ L ] ; if ( L == R - 1 ) return ( arr [ L ] + arr [ R ] ) \/ 2 ; int Siz_M = findSize ( N ) ; int R_ = Math . min ( R , Siz_M ) ; int L_ = Math . max ( L , Siz_M + 1 ) ; return findSize ( N \/ 2 ) * ( ( R_ - L_ + 1 ) + arr [ L_ ] + arr [ R_ ] - arr [ L_ - 1 ] ; } public static void main ( String [ ]"}
{"value":"] \\n import java . io . * ; import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void find_pair ( int n ) { if ( isPrime ( n ) ) { System . out . println ( \" - 1\" ) ; } else { int i = 0 ; for ( i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n \/ i == i ) { System . out . println ( n \/ i + \"   \" + n \/ i ) ; } else { System . out . println ( n \/ i + \"   \" + ( n \/ i ) * ( n - 1 ) \/ i ) ; } break ; } } } } public static void main ( String [ ] args ) { int N = 20 ; find_pair ( N )"}
{"value":"] \\n class GFG { static int landau ( int n ) { int l = 0 ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == j ) dp [ i ] [ j ] = 1 ; else if ( j % i == 0 ) dp [ i ] [ j ] = dp [ i ] [ j \/ i ] + 1 ; else dp [ i ] [ j ] = dp [ i ] [ j - i ] ; l = Math . max ( l , dp [ i ] [ j ] ) ; } } return l ; } static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int lcm ( int a , int b ) { return ( a \/ gcd ( a , b ) * b ) ; } static int maxLCM ( int n ) { int l = 0 ; for ( int i = "}
{"value":"T ] \\n import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean check ( int n ) { if ( n % 2 == 0 ) return false ; if ( n % 3 == 0 ) return false ; return isPrime ( n - 1 ) ; } public static void main ( String [ ] args ) { int N = 5 ; if ( check ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } } -------------------------------------------------------------------------------- -------------------- [\/INST] \\n import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ("}
{"value":"] \\n import java . io . * ; class GFG { static boolean check ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) count ++ ; } if ( count % k == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; int k = 3 ; if ( check ( arr , n , k ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ------------------------------------------------ 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ "}
{"value":"] \\n class GFG { static int findSum ( int n ) { int max_ele = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] ++ ; max_ele = Math . max ( max_ele , arr [ i ] ) ; } int [ ] c = new int [ max_ele + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) c [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= max_ele ; i ++ ) c [ i ] += c [ i - 1 ] ; int ans = 0 ; for ( int i = 0 ; i <= max_ele ; i ++ ) { int x = ( i * ( i + 1 ) ) \/ 2 ; ans += ( c [ i ] - c [ i - 1 ] ) * x ; } ans += ( ( n - c [ max_ele ] + 1 ) * ( max_ele * ( max_ele + 1 ) \/ 2"}
{"value":"] \\n class GFG { static void findElements ( int [ ] arr , int n ) { int Xor = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= arr [ i ] ; sum += arr [ i ] ; } if ( sum == 2 * Xor ) System . out . println ( 0 ) ; else { System . out . println ( 1 ) ; System . out . println ( sum ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 5 , 3 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } } \u0111\u017a\u00a4\u0165 \u0111\u017a\u00a4\u0165 [\/INST] \\n \u0111\u017a\u2018\u2030 [\/INST] \\n \u0111\u017a\u2018\u2030 [\/INST] \\n \u0111\u017a\u2018\u2030 [\/INST] \\n \u0111\u017a\u2018\u2030 [\/INST] \\n \u0111\u017a\u2018\u2030 [\/INST] \\n \u0111\u017a\u2018\u2030 [\/INST] \\n \u0111\u017a\u2018\u2030 ["}
{"value":"T] \\n import java . io . * ; class GFG { static void checkReciprocal ( int a , int b , int c ) { if ( a != 0 ) { float d = ( float ) ( b * b - 4 * a * c ) ; if ( d > 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } else System . out . println ( \" Not   a   quadratic   equation \" ) ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 ; checkReciprocal ( a , b , c ) ; } } 1 \/ 2 ; } } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1 \/ 2 ; } 1"}
{"value":"] \\n import java . util . * ; class GFG { static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) return false ; return true ; } public static void main ( String [ ] args ) { int N = 15 ; if ( isSunnyNumber ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } } \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b"}
{"value":"] \\n import java . util . * ; class GFG { static int count ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( i * i == N ) count ++ ; else if ( ( N \/ i ) * i == N ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( count ( N ) ) ; } } 1 | Java program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Iterate through all the integers ; Check if N can be converted to 1 ; Incrementing the count if it can be converted ; Driver code [\/INST] \\n class GFG { public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( count ( N ) ) ; } static int count ( int N ) { int count = 0 ; for"}
{"value":"] \\n import java . io . * ; class GFG { static void printNumbers ( int N , int K ) { for ( int i = 1 ; i < K ; i ++ ) System . out . print ( i + \"   \" ) ; System . out . println ( N - K + 1 ) ; } public static void main ( String [ ] args ) { int N = 5 , K = 3 ; printNumbers ( N , K ) ; } } \u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430\u0446\u0430"}
{"value":"] \\n import java . util . * ; class GFG { static int findNthSteppingNumber ( int N ) { Queue < Integer > q = new LinkedList < Integer > ( ) ; for ( int i = 1 ; i <= 9 ; i ++ ) q . add ( i ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = q . peek ( ) ; q . remove ( ) ; if ( x % 10 != 0 ) q . add ( 10 * x + ( x % 10 ) - 1 ) ; q . add ( 10 * x + ( x % 10 ) ) ; if ( x % 10 != 9 ) q . add ( 10 * x + ( x % 10 ) + 1 ) ; } return q . peek ( ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( findNthSteppingNumber ( N ) ) ; } } 1 2 3 4 5 6 7 8 "}
{"value":"] \\n class GFG { static int leastNumber ( int n ) { int i = ( int ) Math . sqrt ( n ) ; int j = ( int ) Math . sqrt ( n + 1 ) ; if ( ( i * i - n ) < ( j * j - n ) ) return i * i - n ; return j * j - n ; } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( leastNumber ( n ) ) ; } } 1 \/ 12 \/ 13 \/ 14 \/ 15 \/ 16 \/ 17 \/ 18 \/ 19 \/ 20 \/ 21 \/ 22 \/ 23 \/ 24 \/ 25 \/ 26 \/ 27 \/ 28 \/ 29 \/ 30 \/ 31 \/ 32 \/ 33 \/ 34 \/ 35 \/ 36 \/ 37 \/ 38 \/ 39 \/ 40 \/ 41 \/ 42 \/ 43 \/ 44"}
{"value":"] \\n class GFG { static void printPi ( int N ) { double pi = Math . acos ( - 1 ) ; System . out . printf ( \" % .50f \" , pi ) ; } public static void main ( String [ ] args ) { int N = 50 ; printPi ( N ) ; } } \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b"}
{"value":"] \\n class GFG { static int [ ] toBinary ( int n ) { int [ ] arr = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { arr [ i ] = n % 2 ; n = n \/ 2 ; i ++ ; } return arr ; } static int toDecimal ( int [ ] arr ) { int decimal = 0 ; int i = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { decimal = decimal + arr [ i ] * ( int ) Math . pow ( 2 , i ) ; } return decimal ; } static int flipKthBit ( int n , int k ) { int [ ] arr = toBinary ( n ) ; int i = 0 ; int size = arr . length ; if ( k > size ) return - 1 ; if ( k <= size ) { arr [ k - 1 ] = 1 - arr [ k - 1 ] ; } return toDecimal ( arr ) ; } public static void main ( String [ ] args ) { int n = 5 ; int k = 3 ; System . out . print"}
{"value":"{ 0 , 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 , 3628800 , 39916800 , 479001600 , 6227020800 , 87178291200 , 1307674368000 , 20024188160000 , 3003072016160000 } ; Function call to precompute the factorial of n ; Function call to perform queries [\/ INPUT ] 10 4 12 5 [\/ INPUT ] 2 1 3 4 5 6 7 8 9 10 [\/ INPUT ] 3 1 2 3 [\/ INPUT ] 5 1 2"}
{"value":"] \\n import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int count ( int num , int a , int b , int c ) { int count_a = ( num \/ a ) ; int count_b = ( num \/ b ) ; int count_c = ( num \/ c ) ; int count_ab = ( count_a + count_b - ( count_a \/ gcd ( a , b ) * gcd ( a , b ) ) ) ; int count_bc = ( count_b + count_c - ( count_b \/ gcd ( b , c ) * gcd ( b , c ) ) ) ; int count_ca = ( count_a + count_c - ( count_a \/ gcd ( a , c ) * gcd ( a , c ) ) ) ; int count = count_a + count_b + count_c - count_ab - count_bc - count_ca ; return count ; } static int binarySearch ( int num , int a"}
{"value":"] \\n import java . io . * ; class GFG { static boolean checkAngle ( int n , int i , int j , int k ) { int x = Math . abs ( i - j ) ; int y = Math . abs ( j - k ) ; if ( ( x + y ) % n == 0 ) { int z = x + y ; if ( ( z % 360 ) == 0 ) return true ; else return false ; } return false ; } public static void main ( String [ ] args ) { int n = 6 ; int i = 1 , j = 3 , k = 4 ; if ( checkAngle ( n , i , j , k ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } \u0111\u017a\u00a4\u201d [\/INST] \\n class GFG { public static void main ( String [ ] args ) { int n = 6 ; int i = 1 , j = 3 , k = 4 ; if ( checkAngle ( n , i , j , k ) ) System . out . println ( \" Yes \""}
{"value":"] \\n import java . io . * _ * ; class GFG { static int findLoss ( int n ) { return ( n * 100 ) \/ 100 ; } public static void main ( String args [ ] ) { int n = 100 ; System . out . println ( findLoss ( n ) ) ; } } 1 \/ 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 100 * 10"}
{"value":"[\/INST] \\n import java . io . * ; import java . util . * ; import java . util . Arrays ; import java . util . Collections ; class GFG { static final int MAXN = 1000005 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] count = new int [ MAXN ] ; static void SieveOfEratosthenes ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) spf [ i ] = i ; for ( int j = i * 2 ; j < MAXN ; j += i ) { if ( spf [ j ] == j ) spf [ j ] = i ; } } static void primeFactors ( ) { for ( int i = 1 ; i < MAXN ; i ++ ) { int x = spf [ i ] ; while ( i > 1 ) { count [ x ] ++ ; i"}
{"value":"] \\n class GFG { static int countWays ( int n ) { int ans = 0 ; ans = ( int ) Math . pow ( 2 , ( n * ( n - 1 ) \/ 2 ) ) ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } ~\\n import java . io . * ; class GFG { static int countWays ( int n ) { int ans = 0 ; ans = ( int ) Math . pow ( 2 , ( n * ( n - 1 ) \/ 2 ) ) ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } ~\\n ----------------------auptika ---------------------- \\n class GFG { static int countWays ( int n ) { int ans = 0 ; ans = ( int ) Math . pow ( 2 , ( n * ( n - 1 ) \/ 2 ) ) ; return ans ; } public static"}
{"value":"] import java . util . * ; class GFG { static int MAX = 1000 ; static int [ ] [ ] pascal = new int [ MAX ] [ MAX ] ; static void buildPascal ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) pascal [ i ] [ j ] = 1 ; else pascal [ i ] [ j ] = pascal [ i - 1 ] [ j - 1 ] + pascal [ i - 1 ] [ j ] ; } } } static int nCr ( int n , int r ) { return pascal [ n ] [ r ] ; } public static void main ( String [ ] args ) { int n = 3 , r = 2 ; buildPascal ( ) ; System . out . println ( nCr ( n , r ) ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- ----------------"}
{"value":"ass GFG { static int minAbsDiff ( int n ) { int sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) sum += i ; return ( sum - 1 ) ; } 10 10 ; Driver code [\/ INPUT ] 10 ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ INPUT ] ; Function call [\/ IN"}
{"value":"0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; Driver code [\/DRIVER_CODE] \\n class GFG { static int isZeroXor ( int N ) { int [ ] freq = new int [ 10 ] ; int last_digit = N % 10 ; freq [ last_digit ] ++ ; while ( N > 9 ) { N = N \/ 10 ; int temp = N % 10 ; freq [ temp ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { ans = ans ^ freq [ i ] ; } return ans ; } public static void main ( String [ ] args ) { int N = 12345 ; if ( isZeroXor ( N ) == 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------------------------"}
{"value":"] \\n import java . util . * ; class GFG { static void print ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( i * K + \"   \" + ( i + 1 ) * K + \"   \" + ( i + 2 ) * K + \"   \" + ( i + 3 ) * K + \"NEW_LINE\"); } } public static void main ( String [ ] args ) { int N = 3 , K = 5 ; print ( N , K ) ; } } -------------------------------- 1 \/ 2 -------------------------------- - 2 \/ 2 -------------------------------- - 3 \/ 2 -------------------------------- - 4 \/ 2 -------------------------------- - 5 \/ 2 -------------------------------- - 6 \/ 2 -------------------------------- - 7 \/ 2 -------------------------------- - 8 \/ 2 -------------------------------- - 9 \/ 2 -------------------------------- - 10 \/ 2 -------------------------------- - 11 \/ 2 -------------------------------- - 12 \/ 2 -------------------------------- - 13 \/ 2 ----------------"}
{"value":"] class GFG { static int Sn ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) \/ 3 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( Sn ( n ) ) ; } } orszag 10.10K 0.0 0 onlinegooglegroups.com 10.10K 0.0 0 onlinegooglegroups.com"}
{"value":"] \\n import java . util . * ; class GFG { static int countSpecialStrings ( int n ) { int fib [ ] = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countSpecialStrings ( n ) ) ; } } ~~~~ \\n import java . util . * ; class GFG { static int countSpecialStrings ( int n ) { int fib [ ] = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n ="}
{"value":"] \\n import java . util . * ; class GFG { static int countPaths ( int [ ] arr , int i , int j , int n ) { if ( i == n - 1 ) return 1 ; if ( j == - 1 ) return 0 ; int ans = countPaths ( arr , i + 1 , j , n ) + countPaths ( arr , i , j - arr [ i ] , n ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 1 } ; int n = arr . length ; System . out . println ( countPaths ( arr , 0 , 0 , n ) ) ; } } ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------- --------------------------------------------------------------------------------"}
{"value":"] \\n import java . util . * ; class GFG { static int countPaths ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = i + 1 ; j <= i + k && j < n ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ 0 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 } ; int k = 2 ; int n = arr . length ; System . out . println ( countPaths ( arr , n , k ) ) ; } } \u0111\u017a\u00a4\u017b1 [\/INST] \\n import java . util . * ; class GFG { static int countPaths ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ n - 1 ] = "}
{"value":"] \\n import java . io . * ; class GFG { static int countSubsequences ( int arr [ ] , int n ) { int count_even = 0 , count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return count_even + count_odd ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( countSubsequences ( arr , n ) ) ; } 1 \/ 06\/java\/count_subsequences_with_even_and_odd_sum_1\/count_subsequences_with_even_and_odd_sum_1.java } ; 1 \/ 06\/java\/count_subsequences_with_even_and_odd_sum_1\/count_subsequ"}
{"value":"Function call to find the count of integers [\/INST] \\n import java . util . * ; class GFG { static int [ ] digitToInt ( int N ) { int [ ] digits = new int [ 30 ] ; int i = 0 ; while ( N > 0 ) { digits [ i ] = N % 10 ; N \/= 10 ; i ++ ; } if ( N == 0 ) { digits [ i ] = 0 ; } for ( int j = 0 ; j < i ; j ++ ) { digits [ i - 1 ] = digits [ j ] ; } return digits ; } static int countIntegers ( int B , int C , int [ ] A , int N ) { int [ ] digit = digitToInt ( N ) ; if ( digit [ B - 1 ] > C ) { return 0 ; } else if ( digit [ B - 1 ] < C ) { return 1 << B ; } int [ ] lower = new int [ 30 ] ; for ( int i = 0 ; i < B"}
{"value":"] class GFG { static int countPaths ( int wt , int k , int M , int used [ ] ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) return 1 ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( used [ i ] == 0 ) { count += countPaths ( wt - i , k , M , used ) ; used [ i ] = 1 ; } } return count ; } public static void main ( String [ ] args ) { int wt = 4 , k = 3 , M = 2 ; int used [ ] = new int [ k ] ; System . out . println ( countPaths ( wt , k , M , used ) ) ; } } \u0e50\u009f\u0091\u0e08\u0e42\u0080\u008d\u0e50\u009f\u008e\u0093 3.6K \u0e50\u009f\u0091\u0e08\u0e42\u0080\u008d\u0e50\u009f\u008e\u0093 105 \u0e50\u009f\u0091\u0e08\u0e42\u0080\u008d\u0e50\u009f\u008e\u0093 215 \u0e50\u009f\u0091\u0e08\u0e42\u0080\u008d\u0e50\u009f\u008e\u0093 417 \u0e50\u009f\u0091\u0e08\u0e42\u0080\u008d"}
{"value":"] \\n import java . io . * ; class GFG { static int countPartitions ( int N ) { if ( N == 1 ) return 1 ; return countPartitions ( N - 1 ) + countPartitions ( N - 2 ) + countPartitions ( N - 3 ) ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( countPartitions ( N ) ) ; } } \u0111\u017a\u0179\u00ab [\/INST] \\n 10 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 100 ; 100 \/ 10"}
{"value":"[ 0 ] = 0 ; [\/INST] \\n import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] [ ] dp = new int [ 1000 ] [ 1000 ] [ 1000 ] ; static int longestIncreasingPath ( int [ ] [ ] mat , int i , int j , int n , int m ) { if ( dp [ i ] [ j ] [ mat [ i ] [ j ] ] != - 1 ) return dp [ i ] [ j ] [ mat [ i ] [ j ] ] ; if ( i == n - 1 && j == m - 1 ) { dp [ i ] [ j ] [ mat [ i ] [ j ] ] = 1 ; return 1 ; } if ( i == 0 && j == 0 ) { dp [ i ] [ j ] [ mat [ i ] [ j ] ] = 1 ; return 1 ; } if ( mat [ i ] [ j ] > mat [ i + 1 ] [ j ] ) { int temp = longestIncreasing"}
{"value":"] \\n import java . util . * ; class GFG { static int countPaths ( int x , int y , int n ) { if ( x == 0 && y == 0 ) return 1 ; if ( x == 0 y == 0 ) return 1 ; return countPaths ( x - 1 , y , n ) + countPaths ( x , y - 1 , n ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countPaths ( n , n , n ) ) ; } } \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 "}
{"value":"ass GFG ; Returns maximum amount of gold that can be collected from goldMine [ ] [ ] [ ] ; Create a table to store intermediate results ; Fill the first row of the table ; Fill the rest of the rows ; Driver code [\/ INPUT : First row of the array ; Function call [\/ INPUT : First row of the array ; Print the maximum amount of gold collected [\/ ] 1 2 3 4 8 5 9 10 15 5 7 6 8 4 5 9 10 15 ; Driver code [\/ ] 1 2 3 4 8 5 9 10 15 5 7 6 8 4 5 9 10 15 ; Print the maximum amount of gold collected [\/ ] 1 2 3 4 8 5 9 10 15 5 7 6 8 4 5 9 10 15 ; Driver code [\/ ] 1 2"}
{"value":"] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"value":"] \\n import java . util . * ; class GFG { static int countTriplets ( int L , int R ) { int count = 0 ; int diff = R - L ; if ( diff < 3 ) return 0 ; count = ( diff * ( diff - 1 ) ) \/ 2 ; return count ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . print ( countTriplets ( L , R ) ) ; } } ~~~~ \\n class GFG { static int countTriplets ( int L , int R ) { int count = 0 ; int diff = R - L ; if ( diff < 3 ) return 0 ; count = ( diff * ( diff - 1 ) ) \/ 2 ; return count ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . print ( countTriplets ( L , R ) ) ; } } ~~~~ \\n class GFG { static int countTriplets ( int L , int R ) { int count = 0 ; int diff ="}
{"value":"] \\n import java . util . * ; class GFG { static void constructArrays ( int n ) { int [ ] A = new int [ 2 * n ] ; int [ ] B = new int [ 2 * n ] ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { A [ i - 1 ] = i ; B [ i - 1 ] = i ; } System . out . print ( \" Array   A :   \" ) ; for ( int i = 0 ; i < A . length ; i ++ ) { System . out . print ( A [ i ] + \"   \" ) ; } System . out . println ( ) ; System . out . print ( \" Array   B :   \" ) ; for ( int i = 0 ; i < B . length ; i ++ ) { System . out . print ( B [ i ] + \"   \" ) ; } } public static void main ( String [ ] args ) { int n = 3 ; constructArrays ( n ) ; } } 1 2 3 4 5 6 7 8 9 10 11"}
{"value":"T] \\n import java . util . * ; class GFG { static void flipBits ( int A , int B ) { int i ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) > 0 ) { if ( ( B & ( 1 << i ) > 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } } System . out . println ( A ) ; System . out . println ( B ) ; } public static void main ( String [ ] args ) { int A = 10 , B = 5 ; flipBits ( A , B ) ; } } 1010 101 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010"}
{"value":"] \\n class GFG { static int countDistinctSum ( int N ) { return ( N * ( N + 1 ) ) \/ 2 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( countDistinctSum ( N ) ) ; } } ~~~~"}
{"value":"] \\n import java . util . * ; class GFG { static int countSubstrings ( String str , int n ) { int freq [ ] = new int [ 3 ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - '0' ] ++ ; if ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) ans += n - i ; } return ans ; } public static void main ( String [ ] args ) { String str = \"01210\" ; int n = str . length ( ) ; System . out . println ( countSubstrings ( str , n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 "}
{"value":"] \\n import java . util . * ; class GFG { static int minimumFlips ( String s ) { int count = 0 ; if ( s . length ( ) < 4 ) return 0 ; int counter = 0 ; for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) && s . charAt ( i + 1 ) == s . charAt ( i + 2 ) ) { count += counter ; counter = 0 ; } else { counter ++ ; } } return count ; } public static void main ( String [ ] args ) { String s = \"101011\" ; System . out . println ( minimumFlips ( s ) ) ; } } ~\\n class GFG { static int minimumFlips ( String s ) { int count = 0 ; if ( s . length ( ) < 4 ) return 0 ; int counter = 0 ; for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . char"}
{"value":"] \\n import java . util . * ; class GFG { static String convertToHex ( int num ) { String hex = \"0123456789ABCDEF \" ; String ans = \" \" ; while ( num > 0 ) { ans = hex . charAt ( num % 16 ) + ans ; num = num \/ 16 ; } return ans ; } static String encrypt ( String S , int ch ) { int count = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == ch ) { count ++ ; } else { break ; } } int i = i - 1 ; String ans = \" \" ; while ( count > 0 ) { ans = ans + ch ; ans = ans + convertToHex ( count ) ; count = count - 1 ; i = i - 1 ; } ans = new StringBuilder ( ans ) . reverse ( ) . toString ( ) ; return ans ; } public static void main ( String [ ] args ) { String S = \" aaabbccddee \" ; int ch = ' a"}
{"value":"] \\n import java . util . * ; class GFG { static int C ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; } static int countBinaryStrings ( int n ) { int count = ( 1 << n ) ; int count1 = count \/ 2 ; int ans = count - count1 ; if ( n % 2 == 0 ) ans += count1 ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( countBinaryStrings ( N ) ) ; } } ---------------- LDAP ---------------- 2 \/ 3 2 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 "}
{"value":"2 ] public class GFG { public static String removeRecursive ( String str , char ch ) { if ( str . length ( ) == 0 ) return \" \" ; if ( str . charAt ( 0 ) == ch ) return removeRecursive ( str . substring ( 1 ) , ch ) ; return str . charAt ( 0 ) + removeRecursive ( str . substring ( 1 ) , ch ) ; } public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; char ch = ' e ' ; System . out . println ( removeRecursive ( str , ch ) ) ; } } \u0110\u1ed9 d\u00e0 gia c\u01b0 1.8.0.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt 1.1.1.msvcrt"}
{"value":"] \\n import java . util . * ; class GFG { static boolean isCorrect ( String time ) { int hour = 0 , minute = 0 ; for ( int i = 0 ; i < time . length ( ) ; i ++ ) { if ( time . charAt ( i ) == ' : ' ) continue ; if ( time . charAt ( i ) >= '0' && time . charAt ( i ) <= '9' ) { hour = hour * 10 + time . charAt ( i ) - '0' ; } else if ( time . charAt ( i ) >= '65' && time . charAt ( i ) <= '90' ) { minute = minute * 10 + time . charAt ( i ) - '65' ; } else { return false ; } } if ( hour > 23 hour < 0 minute > 59 minute < 0 ) return false ; if ( hour != 0 && minute != 0 ) { return false ; } return true ; } static boolean isDifferenceCorrect ( String time , int L , int R ) { int hour = 0 , minute ="}
{"value":"] \\n class GFG { static void checkString ( String str ) { int n = str . length ( ) ; int i ; int top = - 1 ; for ( i = 0 ; i < n ; i ++ ) { while ( top >= 0 && str . charAt ( top ) == str . charAt ( i ) ) top -- ; if ( top < 0 ) top = i ; else top -- ; } if ( top < 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; checkString ( str ) ; } } \u0914\u0939\u0947 \u092a\u0930 \u0915\u094d\u0932\u093f\u0915 \u0915\u0930\u0947\u0902 5 ; \u0914\u0939\u0947 \u092a\u0930 \u0915\u094d\u0932\u093f\u0915 \u0915\u0930\u0947\u0902 6 ; \u0914\u0939\u0947 \u092a\u0930 \u0915\u094d\u0932\u093f\u0915 \u0915\u0930\u0947\u0902 7 ; \u0914\u0939\u0947 \u092a\u0930 \u0915\u094d\u0932\u093f\u0915 \u0915\u0930\u0947\u0902 8 ; \ufffd\ufffd"}
{"value":"] \\n import java . util . * ; class GFG { static void countStrings ( String arr1 [ ] , String arr2 [ ] , int N , int M ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < arr1 [ i ] . length ( ) ; j ++ ) { if ( arr1 [ i ] . charAt ( j ) == '1' ) temp |= ( 1 << j ) ; } freq . put ( temp , freq . getOrDefault ( temp , 0 ) + 1 ) ; } ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < arr2 [ i ] . length ( ) ; j ++ ) { if ( arr2 [ i ] . charAt ( j ) == '1' ) temp |= ( 1 << j ) ; } if ( freq"}
{"value":"0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 ] ; Function call [\/INST] \\n class GFG { static void maxDecimal ( int [ ] arr , int n ) { int i = 0 ; int count = 0 ; int max = 0 ; while ( i < n ) { if ( arr [ i ] == 0 ) count ++ ; else { if ( count != 0 ) { max = Math . max ( max , count ) ; count = 0 ; } } i ++ ; } max = Math . max ( max , count ) ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = 1 ; j ++ ; } else { if ( j > 0 ) { arr [ i - j ] = 1 ; j = 0 ; } } } } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 1 ,"}
{"value":"] \\n import java . io . * ; class GFG { static String convert ( String s ) { String ans = \" \" ; ans += s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Character . isUpperCase ( s . charAt ( i ) ) ) ans += \"   \" ; ans += Character . toLowerCase ( s . charAt ( i ) ) ; } return ans ; } public static void main ( String [ ] args ) { String str = \" GeeksForGeeks \" ; System . out . println ( convert ( str ) ) ; } } \u00c2  1 | Java implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code [\/INST] \\n import java . io . * ; class GFG { static String convert ( String s ) { String ans = \" \" ; ans += s"}
{"value":"] \\n import java . io . * ; class GFG { static int countChar ( String s , int n , int k ) { int count = 0 ; int len = s . length ( ) ; while ( n > 0 ) { if ( n >= len ) count += ( n \/ len ) ; n %= len ; } return count ; } public static void main ( String [ ] args ) { String s = \" ab \" ; int n = 12 , k = 2 ; System . out . println ( countChar ( s , n , k ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------------------------"}
{"value":"] \\n import java . io . * ; import java . util . * ; class GFG { static int countFrequencies ( int arr [ ] , int n , int limit ) { int freq [ ] = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int count = 0 ; for ( int i = 0 ; i <= limit ; i ++ ) if ( freq [ i ] > 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 } ; int n = arr . length ; int limit = 5 ; System . out . println ( countFrequencies ( arr , n , limit ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------------------------------------------"}
{"value":"] \\n import java . io . * \/ * ; function that checks if the binary string contains m consecutive 1 ' s   or   0' s ; length of binary string ; count of 0 ' s ; count of 1 ' s ; count of consecutive 0 ' s ; count of consecutive 1 ' s ; if both 1 ' s   and   0' s   are   present ; if 1 ' s   are   present   but   not   consecutive ; if 0 ' s   are   present   but   not   consecutive ; Driver code [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call [\/ Driver code ] 1 ; function call ["}
{"value":"T] \\n class GFG { static int product ( int n , int k ) { int res = 1 ; int level = 1 ; int i = 0 ; while ( true ) { if ( level == k ) { res = res * i ; level ++ ; } else { level -- ; i ++ ; } if ( level == 1 ) break ; } return res ; } public static void main ( String [ ] args ) { int n = 100 ; int k = 3 ; System . out . println ( product ( n , k ) ) ; } } 1 | Java program to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program [\/INST] \\n class GFG { static int product ( int n , int k ) { int res = 1 ; int level = 1 ; int i = 0 ; while ( true ) { if ( level == k ) { res = res * i ; level ++"}
{"value":"] = { ' a ' , ' a ' , ' a ' , ' b ' , ' a ' , ' b ' , ' c ' , ' b ' , ' a ' , ' a ' } ; Function call [\/INST] \\n import java . util . * , * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * . * ."}
{"value":"] \\n import java . io . * ; class GFG { static boolean isValid ( String str ) { if ( str . length ( ) != 10 ) return false ; int sum = 0 , i ; for ( i = 0 ; i < 9 ; i ++ ) sum = sum + ( ( str . charAt ( i ) - '0' ) * ( 2 * i + 1 ) ) ; if ( str . charAt ( i ) == ' X ' ) sum = sum + 10 ; else sum = sum + ( str . charAt ( i ) - '0' ) ; return ( sum % 11 == 0 ) ; } public static void main ( String [ ] args ) { String str = \"9780131423954\" ; if ( isValid ( str ) ) System . out . println ( \" Valid \" ) ; else System . out . println ( \" Invalid \" ) ; } } -------------------------------- -------------------------------- [\/INST] \\n import java . io . * ; class GFG { static boolean isValid ( String str ) { if ( str . length ( ) != 1"}
{"value":"] import java . io . * ; import java . util . * ; class GFG { static boolean isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } static String reverseVowels ( String str ) { String vowels = \" \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) vowels += str . charAt ( i ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) str = str . substring ( 0 , i ) + vowels + str . substring ( i + 1 ) ; } return str ; } public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; System . out . println ( reverseVowels ( str ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------"}
{"value":"] \\n import java . io . * ; class GFG { static void findString ( String s ) { int n = s . length ( ) ; char [ ] output = new char [ n ] ; int i = 0 ; boolean v = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) == '   ' ) v = true ; else { if ( v == true ) { output [ i ++ ] = s . charAt ( j ) ; v = false ; } } } output [ i ] = ' \\0' ; System . out . print ( String . valueOf ( output ) ) ; } public static void main ( String [ ] args ) { String s = \" geeks   for   geeks \" ; findString ( s ) ; } } \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u0091\u0e09\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u0091\u0e07 2 \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u0091\u0e09\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u0091\u0e07 1 \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u0091\u0e09"}
{"value":"] \\n import java . io . * ; class GFG { static int n , m ; static int dfs ( int i , int j , int [ ] [ ] vis , int [ ] [ ] ans , int z , int z_count , int z_count_total ) { vis [ i ] [ j ] = 1 ; z ++ ; if ( i == n - 1 && j == m - 1 ) { if ( z_count == z_count_total ) ans [ i ] [ j ] = 1 ; return 0 ; } if ( i > 0 && vis [ i - 1 ] [ j ] == 0 && ans [ i - 1 ] [ j ] == 0 ) { z_count ++ ; z = dfs ( i - 1 , j , vis , ans , z , z_count , z_count_total ) ; } if ( j > 0 && vis [ i ] [ j - 1 ] == 0 && ans [ i ] [ j - 1 ] == 0 ) { z_count ++ ; z = dfs ( i , j - 1 , vis , ans , z"}
{"value":"] \\n import java . util . * ; class GFG { static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { int left = 0 , right = i - 1 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] == arr [ i ] ) { ans += right - left ; left ++ ; right = i - 1 ; } else if ( arr [ left ] + arr [ right ] < arr [ i ] ) left ++ ; else right -- ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , 3 , - 3 , - 5 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } } 1 | Java program for the above approach ;"}
{"value":"] \\n import java . util . * ; class GFG { static double area ( int a ) { double area = a * a ; return area ; } public static void main ( String [ ] args ) { int a = 4 ; System . out . print ( area ( a ) ) ; } } \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063 \u2063"}
{"value":"] \\n import java . util . * ; class GFG { static void maxIntersections ( int x , int y ) { System . out . println ( ( x * y ) ) ; } public static void main ( String [ ] args ) { int x = 5 , y = 10 ; maxIntersections ( x , y ) ; } } \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2 \/ 4 \u0111\u017a\u00a4\u017b \u00c2\u00a0 \u00c2\u00a0 2"}
{"value":"] \\n import java . io . * ; class GFG { static int icosihenagonalNum ( int n ) { return ( 24 * n * n - 23 * n ) \/ 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( \"5th   Icosihenagonal   Number   is   :   \" + icosihenagonalNum ( n ) ) ; } } ~~~~ 1 2 6 14 26 42 62 86 114 146 182 222 266 314 366 422 482 546 614 686 762 842 926 1014 1106 1202 1302 1406 1514 1626 1742 1862 1986 2114 2246 2382 "}
{"value":"] \\n class GFG { static double A , x , y ; static void findCentroid ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double A = ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) \/ 2.0 ; x = A * ( ( x1 + x2 + x3 ) ) \/ 6.0 ; y = A * ( ( y1 + y2 + y3 ) ) \/ 6.0 ; System . out . println ( \" Centroid   of   the   triangle   is   ( \" + x + \" ,   \" + y + \" ) \" ) ; } public static void main ( String [ ] args ) { double x1 = 0 , y1 = 0 ; double x2 = 1 , y2 = 1 ; double x3 = 1 , y3 = 0 ; findCentroid ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } } \b \b \b "}
{"value":"T] \\n import java . io . * ; class GFG { public static void main ( String [ ] args ) { double a = 20 , b = 10 , c = 30 , d = 50 ; System . out . println ( \" a   =   \" + ( 180 - ( a + b + c + d ) ) ; System . out . println ( \" b   =   \" + ( 180 - ( a + b + c + d ) ) ; System . out . println ( \" c   =   \" + ( 180 - ( a + b + c + d ) ) ; System . out . println ( \" d   =   \" + ( 180 - ( a + b + c + d ) ) ; } } 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1 \/ 0 ; 1"}
{"value":"] \\n class GFG { static double distance ( double a , double b , double c , double d1 , double d2 ) { return ( Math . abs ( a * d1 + b * d2 + c ) \/ Math . sqrt ( a * a + b * b ) ) ; } public static void main ( String [ ] args ) { double a = 1 , b = 1 , c = 1 , d1 = 2 , d2 = 3 ; System . out . println ( distance ( a , b , c , d1 , d2 ) ) ; } } \u0e50\u009f\u0091\u0087 View the Code [\/INST] \\n class GFG { static double distance ( double a , double b , double c , double d1 , double d2 ) { return ( Math . abs ( a * d1 + b * d2 + c ) \/ Math . sqrt ( a * a + b * b ) ) ; } public static void main ( String [ ] args ) { double a = 1 , b = 1 , c = 1 , d1 = 2 , d2 = 3 ; System . out . println ( distance ("}
{"value":"] \\n import java . io . * ; class GFG { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countWays ( int N ) { int ans = fact ( N ) ; ans = ans \/ fact ( N \/ 2 ) ; ans = ans \/ 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( countWays ( N ) ) ; } } ---------------- LRUN ---------------- import java . io . * ; class GFG { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countWays ( int N ) { int ans = fact ( N ) ; ans = ans \/ fact ( N \/ 2 ) ; ans = ans \/ 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( countW"}
{"value":"] \\n import java . util . * ; class GFG { static void check ( int S , int D ) { int v [ ] = new int [ 100000 ] ; int i = 0 ; v [ i ] = S % D ; HashSet < Integer > s = new HashSet < > ( ) ; s . add ( S % D ) ; while ( true ) { i ++ ; v [ i ] = ( v [ i - 1 ] + v [ i - 1 ] % D ) % D ; if ( s . contains ( v [ i ] ) ) { System . out . print ( \" No \" ) ; return ; } s . add ( v [ i ] ) ; } } public static void main ( String [ ] args ) { int S = 2 , D = 3 ; check ( S , D ) ; } } 1 | Java program for the above approach ; Function to check if S is divisible by D while changing S to ( S + S % D ) ; Stores the encountered values ; Stores the encountered values ; Check if the value has already been encountered ; Edge Case ; Otherwise , insert it into the hash"}
{"value":"] \\n import java . io . * ; class GFG { static void countSteps ( int x , int y ) { int count = 0 ; while ( x != 1 y != 1 ) { if ( x > y ) { count += x - y ; x -= y ; } else { count += y - x ; y -= x ; } } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 5 ; countSteps ( x , y ) ; } } \u0969\u0966 \u0968\u0966 \u0967\u096f \u0967\u096e \u0967\u096d \u0967\u096c \u0967\u096b \u0967\u096a \u0967\u0969 \u0967\u0968 \u0967\u0967 \u0967\u0966 \u096f \u096e \u096d \u096c \u096b \u096a \u0969 \u0968 \u0967 \u0966 \u0967"}
{"value":"] \\n import java . util . * ; class GFG { static void isStackSortable ( int [ ] A , int N ) { Stack < Integer > S = new Stack < > ( ) ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . isEmpty ( ) ) { int top = S . peek ( ) ; if ( top == B_end + 1 ) { S . pop ( ) ; B_end ++ ; } else if ( top == A [ i ] ) { S . pop ( ) ; B_end ++ ; } else { S . push ( A [ i ] ) ; break ; } } else { if ( A [ i ] == B_end + 1 ) { B_end ++ ; } else { S . push ( A [ i ] ) ; break ; } } } if ( S . isEmpty ( ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 3 ,"}
{"value":"] \\n public class Test { static int countMinimumReversals ( String str ) { int n = str . length ( ) ; if ( n % 2 == 1 ) return - 1 ; int m = 0 , n = 0 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' { ' ) s . add ( ' { ' ) ; else if ( str . charAt ( i ) == ' } ' ) s . add ( ' } ' ) ; else if ( str . charAt ( i ) == ' { ' ) m ++ ; else n ++ ; } int red_len = m + n ; int open = 0 ; while ( ! s . isEmpty ( ) ) { char c = s . peek ( ) ; if ( c == ' { ' ) open ++ ; else if ( c == ' } ' ) open -- ; s . pop ( ) ; } return ( m + n ) \/ 2 + open % 2 ; } public static void main ("}
{"value":"] \\n import java . util . * ; class GFG { static int countMinimumReversal ( String s ) { int n = s . length ( ) ; if ( n % 2 != 0 ) return - 1 ; int left = 0 , right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) left ++ ; else if ( left > 0 ) { left -- ; right ++ ; } else if ( left == 0 && right > 0 ) right -- ; } if ( left == 0 && right == 0 ) return 0 ; return - 1 ; } public static void main ( String [ ] args ) { String s = \" ( ( ) ) ( ) \" ; System . out . println ( countMinimumReversal ( s ) ) ; } } \u095e\u093f\u0902\u0926 \u0907\u0902\u0926\u0940\u092f\u093e\u0902\u0915 \u0915\u0947 \u0932\u093f\u090f \u0917\u0947\u0938\u094d\u091f \u092b\u0949\u0930\u094d\u0921 \u0917\u094d\u0930\u0941\u092a \u092e\u0947\u0902 \u0936\u093e\u092e\u093f\u0932 \u0939\u0948"}
{"value":"= 1 ; 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. "}
{"value":"T ] \\n import java . io . * ; import java . util . * ; class GFG { static void minNum ( String s ) { int n = s . length ( ) ; int min_avail = 0 ; int pos_of_I = - 1 ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' D ' ) { if ( min_avail > 0 ) { ans . add ( min_avail ) ; min_avail -- ; } else { ans . add ( pos_of_I + 1 ) ; pos_of_I = i ; } } ans . add ( min_avail ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) ) ; } public static void main ( String [ ] args ) { String s = \" IDDID \" ; minNum ( s ) ; } } 1234567891011121"}
{"value":"T ] \\n class GFG { static void decode ( String input ) { String result = \" \" ; Stack < Integer > stack = new Stack < Integer > ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { stack . push ( i + 1 ) ; if ( input . charAt ( i ) == ' D ' || stack . empty ( ) ) { while ( ! stack . empty ( ) ) { result += stack . peek ( ) + \" \" ; stack . pop ( ) ; } } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { String input = \" IDIDD \" ; decode ( input ) ; } } 1"}
{"value":"] \\n import java . io . * ; class GFG { static int minimumNumber ( String str ) { int rank = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str . charAt ( i ) == str . charAt ( j ) && i != j ) { rank ++ ; } } } return rank ; } public static void main ( String [ ] args ) { String str = \"123456789\" ; System . out . println ( minimumNumber ( str ) ) ; } } \u0111\u017a\u00a4\u0165 1 \/ 1 ( 1 ) 1 \/ 1 ( 2 ) 1 \/ 1 ( 3 ) 1 \/ 1 ( 4 ) 1 \/ 1 ( 5 ) 1 \/ 1 ( 6 ) 1 \/ 1 ( 7 ) 1 \/ 1 ( 8 ) 1 \/ 1 ( 9 ) 1 \/ 1 ( 10 ) 1 \/ 1 ( 11 ) "}
{"value":"public class GFG { static boolean isPrime ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void smallestPossible ( int [ ] arr ) { int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) hash [ arr [ i ] ] ++ ; String str = \" \" ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { str += Integer . toString ( i ) ; } } int first = Integer . parseInt ( str . substring ( 0 , 1 ) ) ; int last = Integer . parseInt ( str . substring ( str . length ( ) - 1 , str . length ( ) ) ) ; if ( isPrime ( first ) && isPrime ( last ) ) System . out . print ( str + \"NEW_LINE\"); } public static void"}
{"value":"] \\n import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static boolean coprime ( int a , int b ) { return gcd ( a , b ) == 1 ; } static boolean check ( int L , int R ) { for ( int a = L ; a <= R ; a ++ ) for ( int b = a + 1 ; b <= R ; b ++ ) for ( int c = b + 1 ; c <= R ; c ++ ) if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { return true ; } return false ; } public static void main ( String [ ] args ) { int L = 2 , R = 10 ; if ( check ( L , R ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; L = 23 ; R = 46 ; if ("}
{"value":"] \\n import java . io . * ; class GFG { static boolean isPossible ( int A , int B , int K ) { int cuberoot = ( int ) Math . cbrt ( A * B ) ; if ( A % cuberoot == 0 && B % cuberoot == 0 ) { if ( A \/ cuberoot == B \/ cuberoot ) return true ; } return false ; } public static void main ( String [ ] args ) { int A = 10 , B = 25 , K = 2 ; if ( isPossible ( A , B , K ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d \u0111\u017a\u00a4\u201d "}
{"value":"] class GFG { static boolean isUndulating ( int n ) { int x = n % 10 ; n \/= 10 ; int y = n % 10 ; n \/= 10 ; int z = n % 10 ; return ( x == y && y == z ) ; } public static void main ( String [ ] args ) { int n = 123456 ; if ( isUndulating ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 \u0969 "}
{"value":"] \\n import java . io . * ; class GFG { static int sum ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( sum ( n ) ) ; } } **** * Note : * This program gives the sum of the series 1 * 1 + 2 * 2 + 3 * 3 + ... + n * n ; Driver Code [\/INST] \\n import java . io . * ; class GFG { static int sum ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( sum ( n ) ) ; } } **** * Note : * This program gives the sum of the series 1 * 1 + 2 * 2 + 3 * 3 + ... + n * n ; Driver Code [\/INST] \\n import java"}
{"value":"] \\n import java . io . * ; class GFG { static int countNumbers ( int n , int k ) { return ( n \/ 10 + 1 ) * k ; } public static void main ( String [ ] args ) { int n = 100 , k = 5 ; System . out . println ( countNumbers ( n , k ) ) ; } } ~~~~ \\n import java . io . * ; class GFG { static int countNumbers ( int n , int k ) { return ( n \/ 10 + 1 ) * k ; } public static void main ( String [ ] args ) { int n = 100 , k = 5 ; System . out . println ( countNumbers ( n , k ) ) ; } } ~~~~ \\n import java . io . * ; class GFG { static int countNumbers ( int n , int k ) { return ( n \/ 10 + 1 ) * k ; } public static void main ( String [ ] args ) { int n = 100 , k = 5 ; System . out . println ( countNumbers ( n ,"}
{"value":"] \\n import java . io . * ; class GFG { static int sumOfDivBy6 ( int l , int r ) { int count = ( r \/ 6 ) ; int count1 = ( l - 1 ) \/ 6 ; int sum = ( count * ( count + 1 ) * 6 ) \/ 2 ; int sum1 = ( count1 * ( count1 + 1 ) * 6 ) \/ 2 ; return ( sum - sum1 ) ; } public static void main ( String [ ] args ) { int l = 1 , r = 100 ; System . out . println ( sumOfDivBy6 ( l , r ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- "}
{"value":"3456789987654321000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"value":"] \\n import java . io . * ; class GFG { static int evaluate ( int poly [ ] , int n , int x ) { int res = poly [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) res = res * x + poly [ i ] ; return res ; } static int signValue ( int poly [ ] , int n ) { int x = evaluate ( poly , n , - 1 ) ; if ( x == 0 ) return 0 ; else if ( x > 0 ) return 1 ; else return - 1 ; } public static void main ( String [ ] args ) { int poly [ ] = { 2 , - 6 , 2 , - 1 } ; int n = poly . length ; System . out . println ( signValue ( poly , n ) ) ; } } ------------------------------------------------------------------------------------------------------------------------------------------------ 2 x3 - 6 x2 + 2 x - 1 for x = 3 = 2 * 33 - 6 * 9 + 2 * 3 - 1 = 126 - 5"}
{"value":"] \\n import java . io . * ; class GFG { static int MAX = 1000000 ; static int [ ] primes = new int [ MAX + 1 ] ; static void sieveOfEratostheneses ( ) { primes [ 0 ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) primes [ i ] = 2 ; for ( int i = 3 ; i * i <= MAX ; i += 2 ) { if ( primes [ i ] == i ) { for ( int j = i * i ; j <= MAX ; j += 2 * i ) primes [ j ] = i ; } } } static int findPrimeGreater ( int n ) { int num = n ; while ( true ) { if ( primes [ num ] == num ) return num ; num ++ ; } } static int findNumToBeAdded ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr ["}
{"value":"] \\n import java . util . * ; class GFG { static int sumSubarrays ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( sumSubarrays ( arr , n ) ) ; } } -------------------------------------------------------------------------------- 1 \/ 2 This is a Java program to compute sum of all subarray elements . ; Computes sum of all subarray elements ; Driver program [\/INST] \\n class GFG { static int sumSubarrays ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; } } return"}
{"value":"] \\n class GFG { static int highestPowerOf2 ( int n ) { return ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerOf2 ( n ) ) ; } } \u0111\u017a\u015a\u017b1\/2"}
{"value":"] class GFG { static class Pair implements Comparable < Pair > { char ch ; int freq ; Pair ( char ch , int freq ) { this . ch = ch ; this . freq = freq ; } @ Override public int compareTo ( Pair p ) { return this . freq - p . freq ; } } static String rearrangeString ( String str ) { PriorityQueue < Pair > pq = new PriorityQueue < > ( ) ; int n = str . length ( ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { pq . add ( new Pair ( str . charAt ( i ) , 1 ) ) ; } String str1 = \" \" ; char prev = ' # ' ; prev -- ; while ( pq . size ( ) > 0 ) { Pair p = pq . poll ( ) ; str1 += p . ch ; if ( prev == p . ch ) continue ; else if ( prev != ' # ' ) str1 += prev ; prev = p . ch ; p . freq -- ; if ( p . freq"}
{"value":"] \\n import java . io . * ; class GFG { static int mod = 1000000007 ; static int modulo ( int a , int m ) { return ( a % m + m ) % m ; } static int power ( int a , int b , int m ) { int ans = 1 ; a = modulo ( a , m ) ; while ( b > 0 ) { if ( ( b & 1 ) != 0 ) ans = ( ans * a ) % m ; a = ( a * a ) % m ; b >>= 1 ; } return ans ; } public static void main ( String [ ] args ) { int a = 1000000007 ; int b = 2 ; int m = 1000000007 ; System . out . println ( power ( a , b , m ) ) ; } } 1000000007 ; 2 ; 1000000007 ; 1000000007 ; 100000"}
{"value":"] \\n import java . util . * ; class GFG { static class Point { int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } } static int interpolate ( Point data [ ] , int n , int xi ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int term = data [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) term *= ( xi - data [ j ] . x ) ; } result += term ; } return result ; } public static void main ( String [ ] args ) { Point data [ ] = { new Point ( 0 , 1 ) , new Point ( 1 , 2 ) , new Point ( 2 , 3 ) , new Point ( 3 , 4 ) } ; int xi = 3 ; int result = interpolate ( data , 4 , xi ) ; System . out . println ( result ) ; } } \u0111\u017a\u00a4\u201d [\/INST] \\n "}
{"value":"] \\n import java . util . * ; class GFG { static void printPrimes ( int n ) { n -- ; int mark [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) mark [ i ] = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { for ( int j = i * i ; j <= n ; j += i ) mark [ j ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) if ( mark [ i ] == 0 ) System . out . print ( i + \"   \" ) ; } public static void main ( String [ ] args ) { int n = 100 ; printPrimes ( n ) ; } } ficaf1234567890 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ."}
{"value":"] \\n import java . io . * ; class GFG { static void originalArray ( int [ ] A , int N , int K ) { int [ ] B = new int [ N ] ; int X = 0 ; for ( int i = 0 ; i < N ; i ++ ) { X ^= A [ i ] ; B [ i ] = K ^ X ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + \"   \" ) ; } } public static void main ( String [ ] args ) { int [ ] A = { 4 , 2 , 1 , 3 , 5 } ; int N = A . length ; int K = 7 ; originalArray ( A , N , K ) ; } } 1 2 3 4 5 ; 7 ^ 4 = 3 ; 3 ^ 2 = 1 ; 1 ^ 1 = 0 ; 0 ^ 5 = 5 ; 5 ^ 3 = 2 ; 2 ^ 4 = 6 ; 6 ^ 1 = 7"}
{"value":"Function call [\/INST] \\n class GFG { static int findExtra ( int A [ ] , int B [ ] , int n ) { int XOR_A = 0 , XOR_B = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR_A ^= A [ i ] ; XOR_B ^= B [ i ] ; } return XOR_A ^ XOR_B ; } 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 "}
{"value":"T] \\n class GFG { static int hammingDistance ( int a , int b ) { int count = 0 ; while ( a > 0 && b > 0 ) { if ( ( a & 1 ) ++ count ; a = a >> 1 ; if ( ( b & 1 ) ++ count ; b = b >> 1 ; } return count ; } public static void main ( String [ ] args ) { int a = 10 , b = 15 ; System . out . println ( hammingDistance ( a , b ) ) ; } } 1 00000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001 "}
{"value":"] \\n import java . io . * ; class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) System . out . println ( Integer . toBinaryString ( i ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; printSubsets ( n ) ; } } ~\\n import java . io . * ; class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) System . out . println ( Integer . toBinaryString ( i ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; printSubsets ( n ) ; } } ~\\n import java . io . * ; class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) System . out . println ( Integer . toBinaryString ( i ) ) ; } public static void main ( String [ ] args"}
{"value":"] \\n import java . util . * ; class GFG { static int findMSB ( int n ) { int k = 0 ; while ( n != 0 ) { n = n >> 1 ; k ++ ; } return ( 1 << ( k - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( findMSB ( n ) ) ; } } ..\/..\/.. 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 101100101 10110010"}
{"value":"] class GFG { static int countSubsets ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 4 } ; int n = arr . length ; System . out . println ( countSubsets ( arr , n ) ) ; } } \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b"}
{"value":"] \\n import java . util . * ; class GFG { static int countSubsets ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int max_val = 0 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( max_val < it . getValue ( ) ) max_val = it . getValue ( ) ; } return ( int ) Math . pow ( 2 , max_val ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 } ; int n = arr . length ; System . out . print ( countSubsets ( arr , n ) ) ; } } orszag { } "}
{"value":"] \\n import java . util . * ; class GFG { static int N = 100000 ; static int [ ] perfectSquares = new int [ N + 1 ] ; static void calculatePerfectSquares ( ) { for ( int i = 1 ; i <= N ; i ++ ) { perfectSquares [ i ] = i * i ; } } static int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 1 ; if ( perfectSquares [ n ] == n ) return 1 ; int include = countWays ( n - perfectSquares [ n ] ) ; int exclude = countWays ( n ) ; return include + exclude ; } public static void main ( String [ ] args ) { int n = 5 ; calculatePerfectSquares ( ) ; System . out . print ( countWays ( n ) ) ; } } \uff1f lang = java"}
{"value":"] \\n import java . util . * ; class GFG { static class Node { int data ; Node left , right ; } ; static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static void sizeUtil ( Node root , int depth , int size [ ] ) { if ( root == null ) return ; sizeUtil ( root . left , depth + 1 , size ) ; size [ 0 ] += 1 ; size [ 1 ] += depth ; sizeUtil ( root . right , depth + 1 , size ) ; } static int totalDistUtil ( Node root , int target ) { if ( root == null ) return 0 ; if ( root . data == target ) return 0 ; int sum = 0 ; if ( root . left != null ) { sum += sizeUtil ( root . left , 1 , new int [ ] { 0 , 0 } ) ; sum += totalDistUtil ( root . left , target ) ; } if ( root . right != null ) { sum += sizeUtil ( root . right , 1"}
{"value":"] \\n import java . util . * ; class GFG { static void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { Arrays . sort ( B ) ; Arrays . sort ( A ) ; int i = 0 ; for ( int j = N - 1 ; i < N ; i ++ , j -- ) { A [ i ] = A [ i ] + B [ j ] ; if ( A [ i ] > K ) { System . out . print ( \" - 1\" ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + \"   \" ) ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int B [ ] = { 10 , 20 , 30 , 40 , 50 } ; int K = 5 ; int N = A . length ; rearrangeArray ( A , B , N , K ) ; } } 1 "}
{"value":"] \\n import java . util . * ; class GFG { static void countRows ( int [ ] [ ] mat ) { int N = mat . length ; int M = mat [ 0 ] . length ; int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { sum += mat [ i ] [ j ] ; } for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < M ; j ++ ) { rowSum += mat [ i ] [ j ] ; } if ( rowSum > sum - rowSum ) { count ++ ; } } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; countRows ( mat ) ; } } 1 2"}
{"value":"] class GFG { static boolean isContiguous ( int arr [ ] , int n ) { int i ; int prev = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { if ( prev == arr [ i ] ) continue ; if ( ( prev + 1 ) == arr [ i ] ) prev = arr [ i ] ; else return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 5 , 6 , 7 , 7 , 8 } ; int n = arr . length ; if ( isContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------"}
{"value":"= 2 ; 3 ; 4 ; 5 ; 6 ; 7 ; 8 ; 9 ; 10 ; 11 ; 12 ; 13 ; 14 ; 15 ; 16 ; 17 ; 18 ; 19 ; 20 ; 21 ; 22 ; 23 ; 24 ; 25 ; 26 ; 27 ; 28 ; 29 ; 30 ; 31 ; 32 ; 33 ; 34 ; 35 ; 36 ; 37 ; 38 ; 39 ; 40 ; 41 ; 42 ; 43 ; 44 ; 45 ; 46 ; 47 ; 48 ; 49 ; 50 ; 51 ; 52 ; 53 ; 54 ; 55 ; 56 ; 57 ; 58 ; 59 ; 60 ; 61 ; 62 ; 63 ; 64 ; 65"}
{"value":"] \\n import java . util . * ; class GFG { static boolean check ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { us . add ( arr [ i ] ) ; } if ( us . contains ( arr [ 0 ] ) ) { int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) ) { curr_ele -- ; count ++ ; } if ( us . contains ( curr_ele ) ) { curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) ) { curr_ele ++ ; count ++ ; } } if ( count >= 2 ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 5 , 6 } ; int n = arr . length ; if ( check ( arr , n ) ) System . out . print ( \" Yes"}
{"value":"] \\n import java . io . * ; import java . util . * ; class GFG { static void findLongestSubarray ( int arr [ ] , int n , int k ) { int best = 0 , count = 0 ; int [ ] vis = new int [ n ] ; Arrays . fill ( vis , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { count ++ ; } vis [ i ] ++ ; if ( count > k ) { count = k ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( vis [ j ] == vis [ i ] ) { count -- ; } if ( count == k ) { int sub = i - j - 1 ; if ( sub > best ) best = sub ; } } vis [ i ] ++ ; } System . out . println ( \" The   longest   subarray   is   of   length   \" + best ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 2 ,"}
{"value":"T] \\n class GFG { static boolean checkOverlap ( int arr [ ] , int n , int k ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v . add ( new Integer ( arr [ i ] ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { v . add ( new Integer ( - 1 ) ) ; v . add ( new Integer ( + 1 ) ) ; } Collections . sort ( v , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o1 . compareTo ( o2 ) ; } } ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < 2 * n ; i ++ ) { int ele = v . get ( i ) ; if ( ele == - 1 ) st . push ( ele ) ; else { if ( st . size ( ) >= k ) return true ; else st . pop ( ) ; } } return false ; }"}
{"value":"] import java . io . * ; import java . util . * ; class GFG { static int minrange ( int [ ] [ ] list , int k ) { int [ ] ptr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) ptr [ i ] = 0 ; while ( true ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; int index = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == list [ i ] . length ) break ; if ( list [ i ] [ ptr [ i ] ] < min ) { min = list [ i ] [ ptr [ i ] ] ; index = i ; } } for ( int i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == list [ i ] . length ) break ; if ( list [ i ] [ ptr [ i ] ] > max ) max = list [ i ] [ ptr [ i ] ] ; } if ( ptr [ index ] == list [ index ] . length ) break ; minrange = Math . min"}
{"value":"] import java . util . * ; class GFG { static int largestD ( int S [ ] , int n ) { Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { for ( int k = j - 1 ; k >= 0 ; k -- ) { for ( int l = k - 1 ; l >= 0 ; l -- ) { if ( S [ i ] == ( S [ j ] + S [ k ] + S [ l ] ) && S [ i ] != S [ j ] && S [ i ] != S [ k ] && S [ i ] != S [ l ] && S [ j ] != S [ k ] && S [ j ] != S [ l ] && S [ k ] != S [ l ] ) { return S [ i ] ; } } } } } return - 1 ; } public static void main ( String [ ] args ) { int S [ ] = { 3 , 4 , 5 , 6 , 7 , 8 } ; int n ="}
{"value":"ass Main { static int hash [ ] = new int [ ] ; function to insert a pair ( i , j ) ; function to find the largest d such that a + b + c = d ; for all possible pairs ( a , b ) ; if a + b = d - c ; if no such pair is found ; Driver code [\/ ] 1 \/ * * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/ * \/"}
{"value":"] \\n import java . util . * ; class GFG { static int countMaxElements ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) { count ++ ; sum = arr [ i ] ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 5 ; int n = arr . length ; System . out . println ( countMaxElements ( arr , n , k ) ) ; } } 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ; 1 2 3 4 5 5 ;"}
{"value":"] class Main { static void leftRotate ( int arr [ ] , int n , int d ) { int i , t ; d = d % n ; for ( i = 0 ; i < d ; i ++ ) { t = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; j ++ ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = t ; } } static void leftRotateByD ( int arr [ ] , int n , int d ) { leftRotate ( arr , n , d ) ; } static void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \"   \" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; int d = 3 ; leftRotateByD ( arr ,"}
{"value":"] import java . io . * ; import java . util . Arrays ; class GFG { static void sortInRange ( int arr [ ] , int a , int b ) { int start = a ; int end = b ; int [ ] temp = new int [ end - start + 1 ] ; int k = 0 ; for ( int i = start ; i <= end ; i ++ ) temp [ k ++ ] = arr [ i ] ; Arrays . sort ( temp ) ; for ( int i = start ; i <= end ; i ++ ) arr [ i ] = temp [ i - start ] ; for ( int i = 0 ; i <= end ; i ++ ) System . out . print ( arr [ i ] + \"   \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 5 , 2 , 3 , 7 , 1 , 6 } ; int a = 1 , b = 5 ; sortInRange ( arr , a , b ) ; } } -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- ----------------"}
{"value":"] \\n import java . util . * ; class GFG { static void sortRow ( int [ ] [ ] mat , int descending ) { for ( int i = 0 ; i < mat . length ; i ++ ) { Arrays . sort ( mat [ i ] , ( a , b ) -> ( descending ? b - a : a - b ) ) ; } } static void transpose ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int [ ] [ ] transpose = new int [ m ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) transpose [ j ] [ i ] = mat [ i ] [ j ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = transpose [ i ] [ j ] ; } static void sortMatrix ( int [ ] [ ] mat , int descending ) { sortRow ( mat , descending"}
{"value":"= 0 ; 1 1 0 1 0 1 0 0 1 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 "}
{"value":"] import java . util . * ; class GFG { static void moveZeroes ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ count ] ; arr [ count ] = temp ; count ++ ; } } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \"   \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 0 , 0 , 0 , 10 , 100 , 0 , 0 , 1 , 0 } ; int n = arr . length ; moveZeroes ( arr , n ) ; System . out . println ( \" Array   after   moving   all   zeroes   to   end : \" ) ; printArray ( arr , n ) ; } } -------------------------------- 120 0 "}
{"value":"INST] \\n class GFG { static void pushZeros ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { arr [ count ] = arr [ i ] ; count ++ ; } while ( count < n ) { arr [ count ] = 0 ; count ++ ; } } static void rearrange ( int arr [ ] , int n ) { if ( n == 1 ) { arr [ 0 ] = 2 * arr [ 0 ] ; return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZeros ( arr , n ) ; } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \"   \""}
{"value":"Function to double the first element and move zero to end of array ; Driver code ; Function Call [\/INST] \\n import java . io . * ; class GFG { static void swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } static void moveZeroesToEnd ( int arr [ ] , int n ) { int lastSeen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { swap ( arr , i , lastSeen ) ; lastSeen ++ ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 2 , 0 , 3 , 0 , 4 , 0 , 5 } ; int n = arr . length ; moveZeroesToEnd ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \"  "}
{"value":"] class Rearrange { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \"   \" ) ; } static void rearrange ( int arr [ ] , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) continue ; for ( j = i - 1 ; j >= 0 ; j -- ) if ( arr [ j ] >= 0 ) { int temp = arr [ j ] ; arr [ j ] = arr [ i ] ; arr [ i ] = temp ; i = j - 1 ; } arr [ i ] = - arr [ i ] ; } printArray ( arr , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( \" Before   rearrangement :"}
{"value":"T ] \\n import java . io . * ; import java . util . * ; class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \"   \" ) ; System . out . println ( ) ; } static void reverse ( int arr [ ] , int l , int r ) { int i = l , j = r ; while ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } } static void merge ( int arr [ ] , int l , int m , int r ) { int i , j , k ; int i1 = l ; int j1 = m + 1 ; i = l ; j = m + 1 ; k = l ; while ( i <= m && j <= r ) { if ( arr [ i ] > arr [ j ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] ="}
{"value":"] class GFG { static void rearrange ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i < n && arr [ i ] < 0 ) { i ++ ; } while ( j >= 0 && arr [ j ] > 0 ) { if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } i ++ ; j -- ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 7 , 8 , 2 , - 2 , 3 , 6 } ; int n = arr . length ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \"   \" ) ; } } ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ---------------- ----------------"}
{"value":"] \\n import java . util . * ; class GFG { static void findWinner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { System . out . print ( \" A \" ) ; } else { System . out . print ( \" B \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int N = arr . length ; findWinner ( arr , N ) ; } } orszag { } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 123456789 } 12345"}
{"value":"] \\n import java . io . * ; class GFG { static void preCompute ( int arr [ ] , int N , int dp [ ] [ ] ) { for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 1 ; y <= Math . sqrt ( N ) ; y ++ ) { if ( x + y < N ) { dp [ x ] [ y ] = dp [ x + 1 ] [ y - 1 ] + arr [ x ] ; } else { dp [ x ] [ y ] = arr [ x ] ; } } } } static void findSum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { int dp [ ] [ ] = new int [ N ] [ ( int ) Math . sqrt ( N ) + 1 ] ; preCompute ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; for ( int j = 0 ; j < y ; j"}
{"value":"] \\n class GFG { static void printGreaterTwo ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count > 2 ) System . out . print ( arr [ i ] + \"   \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 2 , 1 , 10 , 11 , 12 , 13 } ; int n = arr . length ; printGreaterTwo ( arr , n ) ; } } -------------------------------- -------------------------------- - -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- "}
{"value":"] \\n import java . util . * ; class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == arr [ i + 2 ] ) continue ; System . out . print ( arr [ i ] + \"   \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 6 } ; int n = arr . length ; findElements ( arr , n ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- --------------------------------"}
{"value":"] \\n class GFG { static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE , second = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= second ) System . out . print ( arr [ i ] + \"   \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 5 , 4 , 6 } ; int n = arr . length ; findElements ( arr , n ) ; } } \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b \b"}
{"value":"] \\n import java . io . * ; import java . util . * ; class GFG { static int minOperations ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) continue ; res += arr [ i ] - arr [ i + 1 ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 3 , 5 } ; int N = arr . length ; System . out . println ( minOperations ( arr , N ) ) ; } } 1 2 3 4 5 ; System . out . println ( minOperations ( arr , N ) ) ; } } 1 2 3 4 5 ; System . out . println ( minOperations ( arr , N ) ) ; } 1 2 3 4 5 ; System . out . println ( minOperations ( arr , N ) ) ; } 1 2 3 4"}
{"value":"] class FindMissingElement { static int findMissingElement ( int arr [ ] , int n ) { int low = 0 , high = n - 1 ; while ( low < high ) { int mid = ( low + high ) \/ 2 ; if ( arr [ mid ] == mid ) low = mid + 1 ; else high = mid ; } return low ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( \" Missing   element   is   \" + findMissingElement ( arr , n ) ) ; } } 1 | Java program to find the smallest missing number in a sorted array ; function that returns smallest elements missing in a sorted array . ; Left half has all elements from 0 to mid ; Driver program to test the above function [\/INST] \\n class FindMissingElement { static int findMissingElement ( int arr [ ] , int n ) { int low = 0 , high = n - 1 ; while ( low <"}
{"value":"] \\n class GFG { static int findMissing ( int arr [ ] , int n ) { int i = 0 ; while ( i < n && arr [ i ] == i ) i ++ ; return i ; } static int smallestMissing ( int arr [ ] , int n ) { if ( arr [ 0 ] != 0 ) return 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] != i ) return i ; return n ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; int n = arr . length ; System . out . println ( smallestMissing ( arr , n ) ) ; } } -------------------------------- 1 \/ 2 1 \/ 3 1 \/ 4 1 \/ 5 1 \/ 6 1 \/ 7 1 \/ 8 1 \/ 9 1 \/ 10 1 \/ 11 1 \/ 12 1 \/ 13 1 \/ 14 1 \/ 15 1 \/ 16 1 \/ "}
{"value":"] import java . io . * ; class GFG { static int maxSum ( int arr [ ] , int n ) { int incl = 0 , excl = 0 ; for ( int i = 0 ; i < n ; i ++ ) { excl = Math . max ( excl , incl ) ; incl = incl + arr [ i ] ; } return Math . max ( excl , incl ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 3"}
{"value":"] \\n import java . util . * ; class GFG { public static int minChanges ( int matrix [ ] [ ] ) { int n = matrix . length ; int m = matrix [ 0 ] . length ; int ans = 0 ; for ( int i = 0 ; i < n + m - 2 ; i ++ ) { int [ ] freq = new int [ 10 ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < m ; k ++ ) { freq [ matrix [ j ] ] ++ ; } ans += Math . min ( freq [ i + i ] , freq [ n + m - 2 - i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 ,"}
{"value":"[ 0 ] = arr [ 0 ] [ 0 ] = arr [ 0 ] = 2 ; [ 0 ] [ 1 ] = arr [ 0 ] [ 1 ] = arr [ 1 ] = 3 ; [ 0 ] [ 2 ] = arr [ 0 ] [ 2 ] = arr [ 2 ] = 4 ; [ 0 ] [ 3 ] = arr [ 0 ] [ 3 ] = arr [ 3 ] = 5 ; [ 0 ] [ 4 ] = arr [ 0 ] [ 4 ] = arr [ 4 ] = 7 ; [ 0 ] [ 5 ] = arr [ 0 ] [ 5 ] = arr [ 5 ] = 8 ; [ 0 ] [ 6 ] = arr [ 0 ] [ 6 ] = arr [ 6 ] = 9 ; [ 0 ] [ 7 ] = arr [ 0 ] [ 7 ] = arr [ 7 ] = 10 ; [ 0 ] [ 8 ] = arr [ 0 ] [ 8 ] = arr [ 8"}
{"value":"] \\n import java . util . * ; class GFG { static int MAX = 100 ; static int lookup [ ] [ ] = new int [ MAX ] [ MAX ] ; static void build ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j < n ; j ++ ) { for ( int i = 0 ; i + j < n ; i ++ ) lookup [ i ] [ j ] = __gcd ( lookup [ i ] [ j - 1 ] , lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static int findGCD ( int arr [ ] , int L , int R ) { int j = ( int ) ( Math . log ( R - L + 1 ) \/ Math . log ( 2 ) ) ; return __gcd ("}
{"value":" n - 1 ] = lexicographically smallest with k swaps . ; Set the position where we want to put the smallest integer ; If we exceed the Max swaps then terminate the loop ; Find the minimum value from i + 1 to max k or n ; Swap the elements from Minimum position we found till now to the i index ; Set the final value after swapping pos - i elements ; Driver method [\/DRIVER_CODE] \\n import java . util . Arrays ; import java . util . Collections ; class Test { static void lexicographicallySmallest ( int [ ] arr , int n , int k ) { int pos = n ; while ( k -- > 0 ) { int min = Arrays . stream ( ) . boxed ( ) . map ( x -> x ) . min ( ) . get ( ) ; int index = Collections . min_element ( Arrays . asList ( arr ) ) ; int temp = arr [ index ] ; arr [ index ] = arr [ pos - 1 ] ; arr [ pos - 1 ] = temp ; pos -- ; } } public static void main ( String [ ] args ) { int"}
{"value":"] class GFG { static int maxSubArraySum ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int csum [ ] = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] ; int max_start = 0 ; for ( int i = k ; i < n ; i ++ ) { if ( max_sum < csum [ i ] - csum [ i - k ] ) { max_sum = csum [ i ] - csum [ i - k ] ; max_start = i - k + 1 ; } } return max_start ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 11 , 100 , 3 , 12 , 7 , 16 , 2 , 1 } ; int n = arr . length ; int k"}
{"value":"] class GFG { static int maxSubArrayStart ( int arr [ ] , int n , int k ) { if ( n < k ) return - 1 ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int start_index = 0 ; for ( i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; max_sum = Math . max ( max_sum , sum ) ; } return start_index ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 2 , 3 , 1 } ; int k = 3 ; int n = arr . length ; System . out . println ( maxSubArrayStart ( arr , n , k ) ) ; } } \ufffd3cQuT3n 3eJv3M"}
{"value":"ST ] \\n import java . util . * ; class GFG { static Map < Map . Entry < Integer , Integer > , Integer > mp = new HashMap < Map . Entry < Integer , Integer > , Integer > ( ) ; static int minScore ( int pos , int myTurn , int [ ] arr , int n ) { if ( pos == n ) { if ( myTurn == 1 ) return 0 ; else return Integer . MAX_VALUE ; } int ans = Integer . MAX_VALUE ; if ( myTurn == 1 ) { ans = Math . min ( arr [ pos ] + minScore ( pos + 1 , 0 , arr , n ) , 1 + minScore ( pos + 2 , 1 , arr , n ) ) ; } else { ans = Math . min ( arr [ pos ] + minScore ( pos + 1 , 0 , arr , n ) , 1 + minScore ( pos + 2 , 1 , arr , n ) ) ; } mp . put ( new Map . Entry < Integer , Integer > ( pos , myTurn ) , ans ) ; return ans ; } static int minPen"}
{"value":"tatic int N = 1000005 ; static Vector < Integer > prime = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ N ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < N ; p ++ ) if ( prime [ p ] ) prime . add ( p ) ; } static int getIndex ( int l , int r , int lc , int rc , int index ) { if ( index < lc ) return 0 ; if ( index > rc ) return 2 * N ; return 1 ; } static int getSumUtil ( int node , int lc , int rc , int l , int r ) { if ( l > r ) return 0 ; if ( l == lc &&"}
{"value":"= 1 ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 "}
{"value":"] ; Fill the dp table [ ] 1 ] ; Print the result [\/1 ] 1 ] ; Driver code ; Driver code [\/1 ] 1 ] ; For large input number n ; Total number of digits in n [\/1 ] 1 ] ; Fill the dp table [\/1 ] 1 ] ; Print the result [\/1 ] 1 ] ; For large input number n [\/1 ] 1 ] ; Total number of digits in n [\/1 ] 1 ] ; Fill the dp table [\/1 ] 1 ] ; Print the result [\/1 ] 1 ] ; For large input number n [\/1 ] 1 ] ; Total number of digits in n [\/1 ] 1 ] ; Fill the dp table [\/1 ] 1 ] ; Print the result [\/1 ] 1 ] ; For large input number n [\/1 ] 1 ] ; Total number of digits in n [\/1 ] 1 ] ; Fill the dp table [\/1 ] 1 ] ; Print the result [\/1 ]"}
{"value":"] \\n import java . util . * ; class GFG { static int countSubsequences ( int arr [ ] , int n ) { int countEVEN [ ] = new int [ n ] ; int countODD [ ] = new int [ n ] ; countEVEN [ 0 ] = 1 ; countODD [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countEVEN [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] ; } } return countEVEN [ n - 1 ] + countODD [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , "}
{"value":"] [ ] ; 3D array to store states of DP ; Initialize the 3D array with - 1 ; Function to solve the knapsack problem ; Base case ; Initialize the answer ; Loop to iterate over all the elements of the array arr [ ] ; Loop to iterate over the remaining capacity of the knapsack ; Condition to check if the element is included in the knapsack or not ; Condition to check if the element is included in the knapsack or not ; Store the state in the 3D array ; Return the maximum value of the knapsack ; Function to print the result ; Driver code ; Function call to solve the knapsack problem ; Print the result [\/INST] \\n import java . util . * ; class GFG { static int [ ] [ ] [ ] dp ; static int solve ( int [ ] arr , int w1 , int w2 , int n , int w ) { if ( n == 0 ) { if ( w1 == 0 ) { dp [ 0 ] [ w1 ] [ w2 ] = 0 ; return 0 ; } int ans = "}
{"value":"[ 0 ] = 1 if arr [ 0 ] [ 0 ] = 1 else 0 ; [\/INST] \\n class GFG { static int n = 3 ; static int m = 3 ; static void preCount ( int arr [ ] [ ] , int pre [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) pre [ i ] [ j ] = 1 ; else pre [ i ] [ j ] = 0 ; for ( int k = j - 1 ; k >= 0 ; k -- ) { if ( arr [ i ] [ k ] == 1 ) pre [ i ] [ j ] += pre [ i ] [ k ] ; } } } static int countSubmatrices ( int pre [ ] [ ] , int k ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ )"}
{"value":"] \\n class GFG { static int countWays ( int n ) { int [ ] noOfWays = new int [ n + 2 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 2 ; noOfWays [ 2 ] = 3 ; for ( int i = 3 ; i <= n ; i ++ ) { int ways1 = noOfWays [ i - 1 ] ; int ways2 = noOfWays [ i - 2 ] ; int ways3 = noOfWays [ i - 3 ] ; noOfWays [ i ] = ways1 + ways2 + ways3 ; } return noOfWays [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } -------------------------------------------------------------------------------- 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1 \/ 2 1"}
{"value":"] \\n import java . util . * ; class GFG { static int N = 3 ; static int M = 3 ; static boolean [ ] [ ] [ ] visited = new boolean [ N ] [ M ] [ M ] ; static int [ ] [ ] [ ] index = new int [ N ] [ M ] [ M ] ; static int [ ] [ ] [ ] [ ] m = new int [ N ] [ M ] [ M ] ; static int [ ] [ ] [ ] [ ] f = new int [ N ] [ M ] [ M ] ; static void dfs ( int i , int j , int k , int index , int n , int m ) { visited [ i ] [ j ] [ k ] = true ; index [ i ] [ j ] [ k ] = index ; if ( i == n - 1 && j == m - 1 ) { f [ i ] [ j ] [ k ] = index ; return ; } if ( i == 0 j == 0 k == 0 ) return ; if ( m [ i ] [ j ] [ k ] == 0 ) return ; if ( visited ["}
{"value":"] class MaxSubset { static int subsetSum ( int set [ ] , int n , int sum ) { int [ ] [ ] subset = new int [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( set [ j - 1 ] <= i ) subset [ i ] [ j ] = subset [ i ] [ j - 1 ] subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } for ( int i = 1 ; i <= sum ; i ++ ) if ( subset [ i ] [ n ] == true ) return i ; return - 1 ; } public static void main ( String args [ ] ) { int set [ ] = { "}
{"value":"ass GFG { public static void printLCS ( char [ ] str1 , char [ ] str2 , int m , n , k ) { int lcs [ ] [ ] [ ] [ ] = new int [ ] [ ] ; int lcslen = 0 ; for ( i = 0 ; i < m ; for ( j = 0 ; j < n ; if ( str1 [ i ] == str2 [ j ] ) { lcslen ++ ; } ; lcs [ ] [ ] [ ] = lcslen ; } ; printLCSUtil ( str1 , str2 , lcs [ ] , m , n , lcslen , data ) ; } ; Driver code ; printLCS ( str1 , str2 , lcs [ ] , m , n , lcslen , data ) ; } 1 ; Driver code ; printLCS ( str1 , str2 ) ; } 1 ; Driver code [\/ ] 1 ; printLCS ( str"}
{"value":"] \\n class GFG { static int getLastIndex ( int n ) { return n % 2 == 0 ? n \/ 2 : ( n \/ 2 ) + 1 ; } static boolean isMajority ( int arr [ ] , int n ) { int l = getLastIndex ( n ) ; int i = 0 ; while ( i < n ) { if ( arr [ i ] == arr [ l ] ) { int j = i ; while ( j < n && arr [ j ] == arr [ l ] ) j ++ ; if ( j - i > n \/ 2 ) return true ; i = j ; } i ++ ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 } ; int n = arr . length ; if ( isMajority ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } \u0111"}
{"value":"] \\n class BinarySearch { static int binarySearch ( int arr [ ] , int low , int high , int x ) { int mid ; while ( low <= high ) { mid = ( low + high ) \/ 2 ; if ( arr [ mid ] == x && ( ( mid == 0 mid == low ) || ( mid > 0 && arr [ mid - 1 ] < x ) ) return mid ; if ( arr [ mid ] < x ) low = mid + 1 ; else high = mid - 1 ; } return - 1 ; } static boolean isMajority ( int arr [ ] , int n , int x ) { int first = binarySearch ( arr , 0 , n - 1 , x ) ; if ( first == - 1 ) return false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) count ++ ; if ( count > n \/ 2 ) return true ; else return false ; } public static void main ( String args [ ] ) { int arr"}
{"value":"] \\n class GFG { static boolean isMajority ( int arr [ ] , int n ) { return ( arr [ n \/ 2 ] >= n \/ 3 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 } ; int n = arr . length ; if ( isMajority ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ------------------------------------------------ 1 \/ 2 ------------------------------------------------ [\/INST] \\n class GFG { static boolean isMajority ( int arr [ ] , int n ) { return ( arr [ n \/ 2 ] >= n \/ 3 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 } ; int n = arr . length ; if ( isMajority ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . print"}
{"value":"] class Solution { static int rodCut ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) val [ i ] = Integer . MIN_VALUE ; val [ 0 ] = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= i ; j ++ ) val [ i ] = Math . max ( val [ i ] , price [ j - 1 ] + val [ i - j ] ) ; } return val [ n ] ; } public static void main ( String [ ] args ) { int price [ ] = { 1 , 5 , 8 , 9 , 9 , 10 , 17 , 17 , 17 , 20 } ; int n = price . length ; System . out . println ( \" Maximum   price   is   \" + rodCut ( price , n ) ) ; } } 1 5 8 9 9 10 17 17 "}
{"value":"Function to check if the array can be converted to target [ ] ; If the length of the array is 0 ; If the length of the array is 1 ; If the length of the array is 2 ; If the length of the array is greater than 2 ; If the length of the array is 3 ; If the length of the array is 4 ; If the length of the array is 5 ; If the length of the array is 6 ; If the length of the array is 7 ; If the length of the array is 8 ; If the length of the array is 9 ; If the length of the array is 10 ; If the length of the array is 11 ; If the length of the array is 12 ; If the length of the array is 13 ; If the length of the array is 14 ; If the length of the array is 15 ; If the length of the array is 16 ; If the length of the array is 17 ; If the length of the array is 18 ; If the length of the array is 19 ; If the length of the array is 2"}
{"value":"] \\n import java . util . * ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( n - r < r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int n = 3 , k = 2 ; int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i + j <= k ) sum += nCr ( i + j - 1 , i - 1 ) * nCr ( i + j - 1 , j - 1 ) ; } } System . out . println ( sum ) ; } } ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ------------------------------------------------ ----------------"}
{"value":"] \\n import java . util . * ; class GFG { static void check ( int N ) { int count = 0 ; while ( N % 100 == 0 ) { N = N \/ 100 ; count ++ ; } if ( N % 2 == 0 ) { System . out . print ( \" YES \" ) ; return ; } System . out . print ( \" NO \" ) ; } public static void main ( String [ ] args ) { int N = 1000000000 ; check ( N ) ; } } ~~~~ 1000000000 \/ 100 = 100000000 \/ 100 = 10000000 \/ 100 = 1000000 \/ 100 = 10000 \/ 100 = 100 \/ 100 = 10 \/ 100 = 0 \/ 100 = 00 = 000 = 0000 = 00000 ="}
{"value":"T] \\n import java . io . * ; class GFG { static int nthCentralNumber ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + i * i * ( 2 * i - 1 ) ; } return sum ; } 10 ; 18 ; 28 ; 38 ; 50 ; 64 ; 80 ; 98 ; 120 ; 144 ; 172 ; 204 [\/INST] \\n class GFG { public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( nthCentralNumber ( n ) ) ; } } 10 ; 18 ; 28 ; 38 ; 50 ; 64 ; 80 ; 98 ; 120 ; 144 ; 172 ; 204 [\/INST] \\n class GFG { public static void main ( String [ ]"}
{"value":"] \\n import java . io . * ; class GFG { static int reverse ( int num ) { int rev_num = 0 ; while ( num != 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num \/ 10 ; } return rev_num ; } static int sumOfReverseDivisors ( int num ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( num \/ i == i ) { sum = sum + i ; } else { sum = sum + i + num \/ i ; } } } sum = sum + 1 ; return sum ; } static void antiPerfect ( int N ) { int sum = sumOfReverseDivisors ( N ) ; if ( N == sum ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void main ( String [ ] args ) { int N = 12 ; antiPerfect"}
{"value":"] \\n import java . io . * ; import java . util . * ; class GFG { static void printSeries ( int n ) { int i , a , b , c , d ; a = 1 ; b = 3 ; c = 4 ; d = 8 ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( ( a + \"   \" ) ; a = b ; b = c ; c = d ; d = a + c ; } } public static void main ( String [ ] args ) { int n = 10 ; printSeries ( n ) ; } } 1 3 4 8 15 27 50 81 128 195 292 429 618 875 1216 1741 2461 3378 4525 5838 7333 9038 10985 13212 15759 18"}
{"value":"] \\n import java . io . * ; class GFG { static int diameter ( int n ) { int l , h , ans = 0 ; if ( n == 1 ) return 1 ; if ( n == 2 ) return 2 ; if ( n == 3 ) return 3 ; if ( n == 4 ) return 4 ; if ( n == 5 ) return 5 ; if ( n == 6 ) return 6 ; if ( n == 7 ) return 7 ; if ( n == 8 ) return 8 ; if ( n == 9 ) return 9 ; if ( n == 10 ) return 10 ; if ( n == 11 ) return 11 ; if ( n == 12 ) return 12 ; if ( n == 13 ) return 13 ; if ( n == 14 ) return 14 ; if ( n == 15 ) return 15 ; if ( n == 16 ) return 16 ; if ( n == 17 ) return 17 ; if ( n == 18 ) return 18 ;"}
{"value":"] \\n import java . io . * ; class GFG { static boolean isGreater ( int a , int b , int c , int d ) { double x = ( b * Math . log ( a ) ) ; double y = ( d * Math . log ( c ) ) ; if ( x > y ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 3 , d = 2 ; if ( isGreater ( a , b , c , d ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------"}
{"value":"] \\n import java . util . * ; class GFG { static Vector < Integer > primes = new Vector < Integer > ( ) ; static void sieve ( ) { boolean [ ] prime = new boolean [ 1000001 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 1000000 ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= 1000000 ; p ++ ) { if ( prime [ p ] ) primes . add ( p ) ; } } static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < primes . size ( ) ; i ++ ) { if ( primes . get ( i ) <= n ) { boolean flag = true ; int x = primes . get ( i ) ; while ( x > 0 ) { if ( is"}
{"value":"] \\n import java . util . * ; class GFG { static int max_val ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; } static int countPrimes ( int arr [ ] , int n ) { int max_val = max_val ( arr , n ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) count ++ ; } return count ; } static int [ ] prefix_array ( int arr [ ] , int n ) { int [ ]"}
{"value":"] \\n import java . io . * ; class GFG { static int minValue ( int n , int x , int y ) { int ans = 0 ; if ( x >= ( n * y \/ 100 ) ) return 0 ; ans = n * ( y \/ 100 ) - x ; return ans ; } public static void main ( String [ ] args ) { int n = 100 , x = 50 , y = 15 ; System . out . println ( minValue ( n , x , y ) ) ; } } \u0111\u017a\u00a4\u201d [\/INST] \\n 100 50 15 [\/INST] \\n 150 [\/INST] \\n 10 [\/INST] \\n 0 [\/INST] \\n 10 [\/INST] \\n 10 [\/INST] \\n 10 [\/INST] \\n 10 [\/INST] \\n 10 [\/INST] \\n 10 [\/INST] \\n 10 [\/INST] \\n 10 [\/INST] \\"}
{"value":"] \\n import java . io . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isFactorialPrime ( int n ) { if ( ! isPrime ( n ) ) return false ; int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; if ( fact == n ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 12 ; if ( isFactorialPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------ ----------------------------------------------------------------"}
{"value":"] class GFG { static int totalWays ( int n ) { int fac1 = 1 , fac2 = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; for ( int i = 1 ; i <= n ; i ++ ) fac2 = fac2 * i ; return fac2 \/ fac1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( totalWays ( n ) ) ; } } ~~~~"}
{"value":"] \\n class GFG { static void SieveOfEratosthenes ( int n , int arr [ ] ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int i = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { arr [ i ++ ] = p ; } } } static void checkEuclid ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { int num = arr [ i ] ; int flag = 0 ; for ( int j = 0 ; j < i ; j ++ ) { int x = arr [ j ] ; int y = n \/ ( x + 1 ) ; if ( y * x + 1"}
{"value":"] class GFG { static int nextPerfectCube ( int n ) { return ( int ) Math . ceil ( Math . cbrt ( n ) ) * ( int ) Math . cbrt ( n ) * ( int ) Math . cbrt ( n ) ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( nextPerfectCube ( n ) ) ; } } -------------------------------- -------------------------------- [\/INST] \\n class GFG { static int nextPerfectCube ( int n ) { return ( int ) Math . ceil ( Math . cbrt ( n ) ) * ( int ) Math . cbrt ( n ) * ( int ) Math . cbrt ( n ) ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( nextPerfectCube ( n ) ) ; } } 1000000000"}
{"value":"] \\n import java . io . * \/ io . * ; function to check if the number is prime or not ; Corner cases ; This condition is to handle the case when n is a prime number greater than 2 ; If n is odd and n is not a prime number ; Function to find sum of prime divisors ; Driver code [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129876 ; Function calling [\/ Driver code ] 129"}
{"value":"] \\n import java . io . * ; class GFG { static int getPosition ( int n ) { int pos = ( int ) ( Math . sqrt ( n ) ) ; int ans = 0 ; if ( n % 2 == 0 ) ans = pos * 2 + 1 ; else if ( n % 3 == 0 ) ans = pos * 2 + 2 ; else if ( n % 5 == 0 ) ans = pos * 2 + 3 ; else if ( n % 7 == 0 ) ans = pos * 2 + 4 ; return ans ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( getPosition ( n ) ) ; } } -------------------------------- -------------------------------- [\/INST] \\n class GFG { public static int getPosition ( int n ) { int pos = ( int ) ( Math . sqrt ( n ) ) ; int ans = 0 ; if ( n % 2 == 0 ) ans = pos * 2 + 1 ; else if ( n % 3 == 0 ) ans = pos"}
{"value":"] \\n import java . util . * ; class GFG { static boolean check ( int L , int R ) { if ( R - L < 3 ) return false ; int start = L ; int end = R ; int flag = false ; while ( start <= end ) { int count = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( i % 2 == 0 ) { count ++ ; if ( count > 2 ) return true ; } } start += 2 ; end += 2 ; } return false ; } public static void main ( String [ ] args ) { int L = 2 , R = 10 ; if ( check ( L , R ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; L = 23 ; R = 46 ; if ( check ( L , R ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ~~~~ \\n import java . util . * ; class GFG { static boolean check ( int L , int R )"}
{"value":"] \\n import java . util . * ; import java . io . * ; class GFG { static int digitNumber ( int n , int digit ) { if ( n == 0 ) return 9 ; if ( n == 1 ) return 8 ; if ( n % 2 == 1 ) return 9 * digitNumber ( n - 1 , digit - 1 ) + 9 * digitNumber ( n - 1 , digit ) ; else return 9 * digitNumber ( n - 2 , digit - 1 ) + 9 * digitNumber ( n - 2 , digit ) ; } public static void main ( String args [ ] ) { int n = 2 , digit = 7 ; System . out . println ( digitNumber ( n , digit ) ) ; } } 1 \/ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ 10 ^ "}
{"value":"] import java . util . * ; class Emirp { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static boolean isEmirp ( int n ) { if ( isPrime ( n ) ) { int rev = 0 ; int temp = n ; while ( temp != 0 ) { int digit = temp % 10 ; rev = rev * 10 + digit ; temp = temp \/ 10 ; } if ( isPrime ( rev ) ) return true ; else return false ; } else return false ; } public static void main ( String args [ ] ) { int n = 153 ; if ( isEmirp ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- --------------------------------"}
{"value":"] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 "}
{"value":"] \\n import java . io . * ; class GFG { static int trace ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 ; } static int traceSum ( int a [ ] [ ] , int n ) { int rowMajor = 0 , columnMajor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { rowMajor += a [ i ] [ i ] ; columnMajor += a [ i ] [ n - i - 1 ] ; } return trace ( trace ( rowMajor ) + trace ( columnMajor ) ) ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; System . out . println ( traceSum ( a , 3 ) ) ; } } 1 2 3 4 5 6 7 8 9 15 18 21 24 2"}
{"value":"] \\n import java . util . * ; class GFG { static void maximumArea ( int n , int m , int k ) { int ans = 0 ; if ( k % 2 == 0 ) { ans = ( n * m ) \/ ( k \/ 2 ) ; } else { ans = ( n * m ) \/ ( k \/ 2 ) ; ans += Math . min ( n , m ) ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 3 , k = 4 ; maximumArea ( n , m , k ) ; } } \u0914 250108 250109 250110 250111 250112 250113 250114 250115 250116 250117 250118 250119 250120 250121 250122 "}
{"value":"] \\n import java . io . * ; class GFG { static float area ( float side ) { float a ; a = side * side ; return a ; } public static void main ( String [ ] args ) { float side = 5 ; System . out . println ( area ( side ) ) ; } } ~~~~ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48."}
{"value":"] import java . io . * ; class GFG { static int countWays ( int n ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) \/ 2 <= n ; L ++ ) count += ( n - L * ( L + 1 ) \/ 2 + 1 ) \/ ( L + 1 ) ; return count ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } } \u3164 \u3164 1 \/ 2 * ( 1 + sqrt ( 8 ) ) = 5 1 \/ 2 * ( 1 + sqrt ( 16 ) ) = 9 1 \/ 2 * ( 1 + sqrt ( 25 ) ) = 13 1 \/ 2 * ( 1 + sqrt ( 36 ) ) = 19 1 \/ 2 * ( 1 + sqrt ( 49 ) ) = 25 1 \/ 2 * ( 1 + sqrt ( "}
{"value":"2 , 3 , 4 , 5 , 16 , 37 , 49 , 9801 ] [\/INST] \\n class Test { static boolean isAutomorphic ( int n ) { int square = n * n ; int n1 = n , square1 = square ; while ( n1 > 0 ) { if ( n1 % 10 != square1 % 10 ) return false ; n1 \/= 10 ; square1 \/= 10 ; } return true ; } public static void main ( String [ ] args ) { int n = 37 ; if ( isAutomorphic ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } ------------------------------------------------------------------------------------------------------------------- 37 ^ 2 = 1369 , 37 = 37 , 1369 = 1369 , 37 = 37 , 1369 = 673 , 37 = 37 , 673 = 673"}
{"value":"] \\n import java . util . * ; class GFG { static int findMaximum ( int N ) { boolean [ ] prime = new boolean [ N + 1 ] ; Arrays . fill ( prime , true ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * i ; j <= N ; j += i ) { prime [ j ] = false ; } } } int ans = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans = i ; break ; } } return ans ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( findMaximum ( N ) ) ; } } -------------------------------- 1 \/ 0"}
{"value":"T ] \\n import java . io . * ; import java . util . * ; class GFG { static int highestPowerOf2 ( int n ) { int count = 0 ; int i = 0 ; while ( ( n & ( 1 << i ) != 0 ) { count ++ ; i ++ ; } return ( 1 << ( count - 1 ) ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( highestPowerOf2 ( n ) ) ; } } 1 \/ 2 ^ 3 = 4 1 \/ 2 ^ 4 = 16 1 \/ 2 ^ 5 = 32 1 \/ 2 ^ 6 = 64 1 \/ 2 ^ 7 = 128 1 \/ 2 ^ 8 = 256 1 \/ 2 ^ 9 = 512 1 \/ 2 ^ 10 = 1024 1 \/ 2 ^ 11 = 2048 1 \/ 2 ^ 12"}
{"value":"] \\n import java . io . * \/ io . * ; class GFG { static int sumOfDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n \/ i == i ) sum = sum + i ; else sum = sum + ( i + n \/ i ) ; } return sum ; } public static void main ( String args [ ] ) { int n = 12 ; System . out . println ( sumOfDivisors ( n ) ) ; } } 1 \/ 2 * ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1 \/ 2 ; 1"}
{"value":"] \\n class GFG { static int mod = 1000000007 ; static int power ( int x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % mod ; x = ( x * x ) % mod ; y = y >> 1 ; y = y \/ 2 ; } return res ; } static boolean checkSquareRoot ( int n , int p ) { if ( ( p % 4 == 1 ) { int a = power ( n , ( p + 1 ) \/ 4 ) ; if ( ( a * a ) % p == n ) return true ; int b = power ( n , ( p + 1 ) \/ 4 ) ; if ( ( b * b ) % p == n ) return true ; return false ; } return true ; } public static void main ( String [ ] args ) { int n = 19 , p = 19 ; if ( checkSquareRoot ( n , p ) ) System"}
{"value":"0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { 0 , 0 , 0 , 1 ] { 0 , 1 , 0 , 0 ] { 0 , 0 , 1 , 0 ] { 0 , 0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { 0 , 1 , 0 , 0 ] { 0 , 0 , 1 , 0 ] { 0 , 0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { 0 , 1 , 0 , 0 ] { 0 , 0 , 1 , 0 ] { 0 , 0 , 0 , 1 ] { 1 , 1 , 0 , 0 ] { 1 , 0 , 0 , 0 ] { "}
{"value":"] \\n class GFG { static int findLongestConseq ( int n ) { int result = 0 ; int x = n ; while ( x != 0 ) { result ++ ; x = x & ( x - 1 ) ; } return result ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( findLongestConseq ( n ) ) ; } } \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b \u0e50\u009f\u0092\u0e1b [\/CODE] \u0e42\u009c\nGroupLayout 1 [\/GROUPLAYOUT] \\n class GFG { static int findLongestConseq ( int n ) { int result = 0 ; int x = n ; while ( x != 0 ) { result ++ ; x = x & ( x - 1 ) ; } return result ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( findLongestConseq ( n ) ) ; } } \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b \u0e50\u009f\u0092\u0e1b [\/CODE] \\n 1 2 3 4 5 "}
{"value":"] \\n import java . io . * ; class GFG { static int subtract ( int x , int y ) { int result = 0 ; int borrow = 0 ; while ( y != 0 ) { int sum = x ^ y ; int carry = ( x & y ) << 1 ; x = sum ; y = carry ; } return x ; } public static void main ( String [ ] args ) { int x = 10 , y = 5 ; System . out . println ( subtract ( x , y ) ) ; } } -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- -------------------------------- --------------------------------"}
{"value":"] \\n import java . io . * ; class GFG { static int subtract ( int a , int b ) { if ( b == 0 ) return a ; return subtract ( a , b - 1 ) - 1 ; } public static void main ( String [ ] args ) { int a = 100 , b = 50 ; System . out . println ( subtract ( a , b ) ) ; } } ~~~~ \\n 100 - 50 = 50 [\/INST] \\n 100 - 50 = 50 [\/INST] \\n 100 - 50 = 50 [\/INST] \\n 100 - 50 = 50 [\/INST] 100 - 50 = 50 [\/INST] 100 - 50 = 50 [\/INST] 100 - 50 = 50 [\/INST] 100 - 50 = 50 [\/INST] 100 - 50 = 50 [\/INST] 10"}
{"value":"T] \\n import java . util . * ; import java . lang . * ; import java . io . * ; import java . util . * ; import java . util . * ; import java . util . * ; import java . util . * ; import java . util . * ; class GFG { static void addEdge ( int parent [ ] , int n , int u , int v ) { parent [ u ] = v ; } static void dfs ( int parent [ ] , int K , int [ ] ans , int u , int depth ) { ans [ u ] = parent [ u ] ; if ( depth == K ) return ; for ( int i = 0 ; i < n ; i ++ ) { if ( parent [ i ] == u ) { dfs ( parent , K , ans , i , depth + 1 ) ; } } } static void findKthAncestor ( int n , int K , int [ ] parent ) { int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ans [ i ] = - 1 ; for ( int i"}
{"value":"] \\n import java . util . * ; class GFG { static int N = 100005 ; static void build ( int [ ] tree , int [ ] arr , int ss , int se , int si ) { if ( ss == se ) { tree [ si ] = arr [ ss ] ; return ; } int mid = ( ss + se ) \/ 2 ; build ( tree , arr , ss , mid , 2 * si + 1 ) ; build ( tree , arr , mid + 1 , se , 2 * si + 2 ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; } static void pushdown ( int [ ] tree , int [ ] lazy , int ss , int se , int si ) { if ( lazy [ si ] != 0 ) { int mid = ( ss + se ) \/ 2 ; tree [ 2 * si + 1 ] += lazy [ si ] ; tree [ 2 * si + 2 ] += lazy [ si ] ; if ( ss != se ) lazy [ 2 * si + 1 ] += lazy"}
{"value":"] \\n import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int findFinalArrayLength ( int arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == 1 ) { arr [ i ] = arr [ j ] = 1 ; } } } if ( N == 0 ) return 0 ; return N ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 } ; int N = arr . length ; if ( findFinalArrayLength ( arr , N ) != 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } } \u0914\u092a\u0926\u094d\u0930\u0935\u094d\u092f : https : www . geeksforge"}
{"value":"] \\n import java . util . * ; class GFG { static int findWays ( int n ) { int a = ( int ) Math . sqrt ( n ) ; int b = ( int ) Math . sqrt ( ( n - a ) ) ; if ( a * a + b * b == n && a > 0 && b > 0 ) return 2 ; return 0 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . print ( findWays ( n ) ) ; } } ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------------------------------------------"}
{"value":"] \\n import java . util . * ; class GFG { static void countPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j && arr [ i ] == j ) continue ; if ( arr [ i ] == j ) { count ++ ; } } } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 2 , 2 } ; int n = arr . length ; countPair ( arr , n ) ; } } \u0111\u017a\u015b\u015b 1 | Java implementation of the approach ; Function to print the count of pair ; Iterate over all the elements of the array ; Increment the count ; Print the result ; Driver Code [\/INST] \\n import java . util . * ; class GFG { static void countPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ )"}
{"value":"] class GFG { static int maxLenFibSubseq ( int [ ] arr ) { int n = arr . length ; int max = 0 ; int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( arr [ i ] - arr [ j ] ) == arr [ i - j ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } max = Math . max ( max , dp [ i ] ) ; } return max ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 7 , 11 , 12 , 15 , 20 , 24 , 30 } ; System . out . println ( maxLenFibSubseq ( arr ) ) ; } } \u0111\u017a\u00a4\u017b"}
{"value":"] \\n import java . util . * ; class GFG { static int countElements ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 6 ; System . out . print ( countElements ( arr , n , k ) ) ; } } \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u008e\u0093 4.3K \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u0092\u0e1b 2.3K \u0e50\u009f\u0091\u0e08\u0e42\u0080\u008d\u0e50\u009f\u0091\u0e09\u0e42\u0080\u008d\u0e50\u009f\u0091\u0e06 1.3K \u0e50\u009f\u0091\u0e08\u0e50\u009f\u008f\u0e1b\u0e42\u0080\u008d\u0e50\u009f\u0092\u0e1c 1.2K \u0e50\u009f\u0092\u0e1b 2.4"}
{"value":"] \\n import java . util . * ; class GFG { static int numberOfCandies ( int [ ] candies ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i ++ ) s . add ( candies [ i ] ) ; return s . size ( ) ; } static int maximumCandies ( int n , int [ ] candies ) { int x = n \/ 2 ; int y = numberOfCandies ( candies ) ; return x * y ; } public static void main ( String [ ] args ) { int N = 3 ; int [ ] candies = { 1 , 2 , 3 } ; System . out . print ( maximumCandies ( N , candies ) ) ; } } -------------------------------- -------------------------------- [\/INST] \\n import java . util . * ; class GFG { static int numberOfCandies ( int [ ] candies ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i"}
{"value":"] \\n import java . util . * ; class GFG { static void diagonalLength ( double a , double theta ) { double d = ( Math . sin ( theta ) * a ) ; System . out . println ( d ) ; } public static void main ( String [ ] args ) { double a = 12 , theta = 60 ; diagonalLength ( a , theta ) ; } } \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \u0914 \ufffd\ufffd"}
{"value":"] \\n import java . util . * ; class GFG { static int getSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } static void countEvenOdd ( int arr [ ] , int n , int k ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int xor_value = getSetBits ( arr [ i ] ^ k ) ; int set_bit = getSetBits ( k ) ; if ( set_bit % 2 == 1 ) { even += xor_value ; odd += set_bit - xor_value ; } else { even += set_bit - xor_value ; odd += xor_value ; } } System . out . println ( \" Even   set   bit   count   =   \" + even ) ; System . out . println ( \" Odd   set   bit   count   =   \" + odd ) ; } public static void main ( String [ ]"}
{"value":"T] \\n import java . io . * ; class GFG { static int countPairs ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) res += n \/ i ; } return res ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countPairs ( n ) ) ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"}
