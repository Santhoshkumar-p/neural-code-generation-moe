,value,value,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
0,"def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( ' inf ' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE","] \n def minimumSum ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for it in mp : NEW_LINE INDENT sum += it * ( it + 1 ) / 2 NEW_LINE DEDENT min_sum = sum NEW_LINE for it in mp : NEW_LINE INDENT min_sum = min ( min_sum , sum - it * ( it + 1 ) / 2 ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumSum ( arr , n ) ) NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3",0.40075517329918675,0.28728075934826164,0.5449066005151522,0.4375,0.3333333333333333
1,"def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE maxi = - 1 * float ( ' inf ' ) NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE prev = arr [ j ] NEW_LINE DEDENT res . append ( maxi ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE","] def maxDiff ( arr , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prev = arr [ i ] NEW_LINE maxi = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT maxi = max ( maxi , arr [ j ] ) NEW_LINE arr [ j ] = - 1 NEW_LINE maxi = max ( maxi , arr [ j ] ) NEW_LINE ans . append ( maxi - prev ) NEW_LINE prev = maxi NEW_LINE DEDENT DEDENT print ( max ( ans ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE maxDiff ( arr , N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE ",0.28969143938619474,0.2900354933026921,0.46350150607215207,0.29411764705882354,0.1111111111111111
2,"def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( CountOnes ( N , L , R ) ) NEW_LINE DEDENT","] def findSize ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return findSize ( N // 2 ) + findSize ( N // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findSize ( N // 2 ) + 1 NEW_LINE DEDENT DEDENT def countOnes ( arr , L , R , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return findSize ( N // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findSize ( N // 2 ) + 1 NEW_LINE DEDENT DEDENT / * Driver Code * / NEW_LINE INDENT N = 3 NEW_LINE L = 2 NEW_LINE R = 3 NEW_LINE arr = [ 1 , 1 , 1 ] NEW_LINE print ( countOnes ( arr , L , R , N ) ) NEW_LINE N = 5 NEW_LINE L = 1 NEW_LINE R = 4 NEW_LINE arr = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE print ( countOnes ( arr , L , R , N ) ) NEW_LINE N = 10 NEW_LINE L = 3 NEW_LINE R = 9 NEW_LINE arr = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE print ( countOnes ( arr , L , R , N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_",0.4594636296808442,0.3300176537074897,0.41069400787303006,0.2571428571428571,0.84
3,"def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 4 NEW_LINE minDivisior ( N ) NEW_LINE","T ] def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPair ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT a = n // i NEW_LINE b = n // i * ( n - 1 ) NEW_LINE print ( a , b ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE findPair ( n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW",0.6169280222160567,0.39169270524836053,0.5509730014266265,0.6938775510204082,0.8311688311688312
4,"import sys NEW_LINE Landau = - sys . maxsize - 1 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT N = 4 NEW_LINE Landau_function ( N ) NEW_LINE","] NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def maxLCM ( n ) : NEW_LINE INDENT lcm = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT lcm = lcm ( lcm , i ) NEW_LINE DEDENT DEDENT return lcm NEW_LINE DEDENT def findLCM ( n , curr , prev , rep , ans ) : NEW_LINE INDENT if ( curr == n ) : NEW_LINE INDENT ans [ 0 ] += 1 NEW_LINE return NEW_LINE DEDENT for i in range ( prev , n + 1 ) : NEW_LINE INDENT curr += i NEW_LINE findLCM ( n , curr , i , rep , ans ) NEW_LINE curr -= i NEW_LINE DEDENT DEDENT def findLandau ( n ) : NEW_LINE INDENT ans = [ 0 ] * 2 NEW_LINE findLCM ( n , 0 , 0 , ans , ans ) NEW_LINE print ( maxLCM ( ans [ 0 ] ) ) NEW_LINE DEDENT n = 10 NEW_LINE findLandau ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_",0.4999257341897235,0.3844702030611246,0.471959582853273,0.5294117647058824,0.6138613861386139
5,"def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE DEDENT def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT","] \n def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( n ** ( 1 / 2 ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 9 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41",0.6443180599263825,0.45765222924633764,0.6657738566130383,0.6538461538461539,0.8
6,"def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] def check ( a , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE if ( check ( a , n , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 2 NEW_LINE 4 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE ",0.5203902651180938,0.35705545504929664,0.5682791903287394,0.39622641509433965,0.76
7,"from math import * NEW_LINE def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT","] \n import math NEW_LINE def findSum ( n , m ) : NEW_LINE INDENT freq = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT maxi = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT maxi = max ( maxi , freq [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += ( freq [ i ] * ( freq [ i ] - 1 ) ) // 2 NEW_LINE ans += ( maxi - freq [ i ] ) * ( maxi - freq [ i ] - 1 ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE m = max ( arr ) NEW_LINE print ( findSum ( n , m ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 5 NEW_LINE 5 NEW_LINE 5 NEW_LINE 5 NEW_LINE 6 NEW_LINE 6 NEW_LINE 7 NEW_LINE 7 NEW_LINE 8 NEW_LINE 8 NEW_LINE 9 NEW_LINE 9 NEW_LINE 10 NEW_LINE 10 NEW_LINE 11 NEW_LINE 11 NEW_LINE 12 NEW_LINE 12 NEW_LINE 13 NEW_LINE 1",0.31836687918907725,0.36657681198753916,0.3798121387886021,0.41304347826086957,0.11403508771929824
8,"def insert_element ( a , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE print ( 2 ) NEW_LINE print ( num1 , num2 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT","] def minInsertions ( arr , N ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT Xor = Xor ^ arr [ i ] NEW_LINE Sum = Sum + arr [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum + Xor , end = ""   "" ) NEW_LINE print ( Xor ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE minInsertions ( arr , N ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 5 NEW_LINE 1 NEW_LINE 1 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1",0.5995572075213671,0.3122570299309814,0.5435989187985548,0.5423728813559322,0.0
9,"def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE","] def checkReciprocal ( a , b , c ) : NEW_LINE INDENT if ( ( a == 0 ) and ( b == 0 ) and ( c == 0 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT elif ( ( a == 0 ) and ( b != 0 ) and ( c == 0 ) ) : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT elif ( ( a == 0 ) and ( b != 0 ) and ( c != 0 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT elif ( ( a != 0 ) and ( b == 0 ) and ( c != 0 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT elif ( ( a != 0 ) and ( b != 0 ) and ( c == 0 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT elif ( ( a != 0 ) and ( b != 0 ) and ( c != 0 ) ) : NEW_LINE INDENT if ( ( ( - b ) / ( 2 * a ) ) == ( c / ( a * ( - b ) ) ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE checkReciprocal ( a , b , c ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 2",0.49848533524455796,0.13258660000399342,0.6358905499928061,0.3793103448275862,0.8461538461538461
10,"from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE checkSunnyNumber ( N ) NEW_LINE DEDENT","] \n import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSunny ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE if ( isSunny ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53",0.5959124499681048,0.35215776169768664,0.8038960211050313,0.6486486486486487,0.5789473684210527
11,"def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT","] def count ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i * i * i + i * i + i == N ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 12 ; NEW_LINE print ( count ( N ) ) ; NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 15 NEW_LINE 16 NEW_LINE 27 NEW_LINE 32 NEW_LINE 49 NEW_LINE 64 NEW_LINE 81 NEW_LINE 100 NEW_LINE 121 NEW_LINE 144 NEW_LINE 169 NEW_LINE 196 NEW_LINE 225 NEW_LINE 256 NEW_LINE 289 NEW_LINE 324 NEW_LINE 361 NEW_LINE 400 NEW_LINE 441 NEW_LINE 484 NEW_LINE 529 NEW_LINE 576 NEW_LINE 625 NEW_LINE 676 NEW_LINE 729 NEW_LINE 784 NEW_LINE 841 NEW_LINE 900 NEW_LINE 961 NEW_LINE 1024 NEW_LINE 1089 NEW_LINE 1156 NEW_LINE 1225 NEW_LINE 1296 NEW_LINE 1369 NEW_LINE 1444 NEW_LINE 1521 NEW_LINE 1600 NEW_LINE 1681 NEW_LINE 1764 NEW_LINE 1849 NEW_LINE 1936 NEW_LINE 2025 NEW_LINE 2116 NEW_LINE 2208 NEW_LINE 2302 NEW_LINE 2400 NEW_LINE 2499 NEW_LINE 2599 NEW_LINE 2701 NEW",0.32822927110573985,0.17903313593213993,0.31153100731434896,0.38235294117647056,0.44
12,"def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT","] \n def printK ( N , K ) : NEW_LINE INDENT for i in range ( 1 , K ) : NEW_LINE INDENT print ( i , end = ""   "" ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 10 NEW_LINE K = 5 NEW_LINE printK ( N , K ) NEW_LINE DEDENT 1 NEW_LINE 5 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE ",0.5142361424971271,0.19985178794996095,0.6047850897308555,0.56,0.6923076923076923
13,"def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE DEDENT",] def getNthSteppingNumber ( N ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( 1 ) NEW_LINE q . append ( 2 ) NEW_LINE q . append ( 3 ) NEW_LINE q . append ( 4 ) NEW_LINE q . append ( 5 ) NEW_LINE q . append ( 6 ) NEW_LINE q . append ( 7 ) NEW_LINE q . append ( 8 ) NEW_LINE q . append ( 9 ) NEW_LINE while ( len ( q ) > 1 ) : NEW_LINE INDENT q . append ( q [ - 1 ] ) NEW_LINE q . pop ( ) NEW_LINE if ( q [ - 1 ] % 10 != 0 ) : NEW_LINE INDENT q . append ( 10 * q [ - 1 ] + ( q [ - 1 ] % 10 ) - 1 ) NEW_LINE DEDENT q . append ( 10 * q [ - 1 ] + ( q [ - 1 ] % 10 ) ) NEW_LINE if ( q [ - 1 ] % 10 != 9 ) : NEW_LINE INDENT q . append ( 10 * q [ - 1 ] + ( q [ - 1 ] % 10 ) + 1 ) NEW_LINE DEDENT DEDENT return q [ - 1 ] NEW_LINE DEDENT N = 10 NEW_LINE print ( getNthSteppingNumber ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_,0.43246687081628715,0.17962607405071865,0.3156735079798621,0.2345679012345679,1.0
14,"from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT",] \n import math NEW_LINE def getLeast ( N ) : NEW_LINE INDENT x = int ( math . sqrt ( N ) ) NEW_LINE y = int ( math . sqrt ( N ) ) NEW_LINE if ( N - x * x < y * y - N ) : NEW_LINE INDENT return x * x - N NEW_LINE DEDENT else : NEW_LINE INDENT return N - y * y NEW_LINE DEDENT DEDENT N = 15 NEW_LINE print ( getLeast ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65,0.14900180862221182,0.03956086630456209,0.06604232778024487,0.4722222222222222,0.01818181818181818
15,"from math import acos NEW_LINE def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 43 ; NEW_LINE printValueOfPi ( N ) ; NEW_LINE DEDENT","] \n import math NEW_LINE def pi ( n ) : NEW_LINE INDENT pi = math . acos ( - 1 ) NEW_LINE print ( pi , end = "" "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 50 NEW_LINE pi ( n ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE",0.2506149945909269,0.1054812708711598,0.3163981269119672,0.43243243243243246,0.14814814814814814
16,"import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE","] \n from math import log2 NEW_LINE def toBinary ( n ) : NEW_LINE INDENT arr = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT arr [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT def toDecimal ( arr ) : NEW_LINE INDENT n = 0 NEW_LINE i = 0 NEW_LINE while ( arr [ i ] ) : NEW_LINE INDENT n += arr [ i ] * ( 1 << i ) NEW_LINE i += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT def concatenate ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE a = a + b NEW_LINE return toDecimal ( a ) NEW_LINE DEDENT def flipKthBit ( n , k ) : NEW_LINE INDENT a = toBinary ( n ) NEW_LINE b = toBinary ( k - 1 ) NEW_LINE c = concatenate ( a , b ) NEW_LINE return toDecimal ( c ) NEW_LINE DEDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( flipKthBit ( n , k ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 3",0.2391367041845335,0.2666598071708097,0.3091978627090233,0.32098765432098764,0.05970149253731343
17,"MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE","= 1 NEW_LINE def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT result [ i ] = ( result [ i - 1 ] * i NEW_LINE DEDENT DEDENT def performQueries ( ) : NEW_LINE INDENT precompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ queries [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE queries = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE performQueries ( ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 6 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE 24 NEW_LINE 120 NEW_LINE 24 NEW_LINE ",0.29345057321872553,0.30188527388890385,0.3334554805244597,0.3076923076923077,0.23076923076923078
18,"import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE","] NEW_LINE import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def countTerms ( num , a , b , c ) : NEW_LINE INDENT count = 0 NEW_LINE count += num // a NEW_LINE count += num // b NEW_LINE count += num // c NEW_LINE count -= num // ( a * b ) NEW_LINE count -= num // ( b * c ) NEW_LINE count -= num // ( c * a ) NEW_LINE return count NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 NEW_LINE high = 10 ** 9 NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( countTerms ( mid , a , b , c ) >= n ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 5 NEW_LINE n = 10 NEW_LINE print ( findNthTerm ( a , b , c , n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3",0.42554468321523253,0.395823083789444,0.40552920279049437,0.33884297520661155,0.5619834710743802
19,"def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE","] def checkAngle ( n , i , j , k ) : NEW_LINE INDENT x = abs ( i - j ) NEW_LINE y = abs ( j - k ) NEW_LINE if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( ( ( n - x ) * 180 ) / y ) NEW_LINE DEDENT n = 6 NEW_LINE i = 1 NEW_LINE j = 3 NEW_LINE k = 5 NEW_LINE print ( checkAngle ( n , i , j , k ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE",0.23236774873103141,0.1899369541054799,0.31494882211578,0.4117647058823529,0.01282051282051282
20,"def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( "" Loss ▁ = "" , round ( loss , 3 ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT","] def calculateLoss ( cost , profit ) : NEW_LINE INDENT print ( "" Loss   =   "" , profit * 100 , "" % "" ) NEW_LINE DEDENT cost = 100 NEW_LINE profit = 20 NEW_LINE calculateLoss ( cost , profit ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 72 NEW_LINE 73 NEW_LINE 74 NEW_LINE 75 NEW_LINE",0.16491490765143585,0.045683052920925706,0.1053185690268091,0.15151515151515152,0.35714285714285715
21,"MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","= 1 NEW_LINE MAXN = 1000000 NEW_LINE spf = [ 0 for i in range ( MAXN + 1 ) ] NEW_LINE count = [ 0 for i in range ( MAXN + 1 ) ] NEW_LINE def Sieve ( ) : NEW_LINE INDENT spf [ 0 ] = - 1 NEW_LINE spf [ 1 ] = - 1 NEW_LINE for i in range ( 2 , MAXN + 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 2 , MAXN + 1 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * 2 , MAXN + 1 , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def primeFactors ( ) : NEW_LINE INDENT for i in range ( 1 , MAXN + 1 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE while ( i % spf [ i ] == 0 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE i //= spf [ i ] NEW_LINE DEDENT DEDENT DEDENT def isCoprime ( x , arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( count [ arr [ i ] ] > 0 and count [ x ] > 0 and count [ arr [ i ] ] == count [ x ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isCoprimeUtil ( arr , n ) : NEW_LINE INDENT Sieve ( ) NEW_LINE primeFactors ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isCoprime ( arr [ i ] , arr ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT",0.4108195626250907,0.44696704715017305,0.4609150205855858,0.39473684210526316,0.34065934065934067
22,"def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT","] def countWays ( n ) : NEW_LINE INDENT return ( 1 << ( n * ( n - 1 ) ) ) // 2 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 4 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE",0.397256669650365,0.11036601081251073,0.33153423100734025,0.41379310344827586,0.7333333333333333
23,"l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE","= [ 0 ] NEW_LINE INDENT INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT pascal [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pascal [ i ] [ j ] = pascal [ i - 1 ] [ j - 1 ] + pascal [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return pascal [ n ] [ r ] NEW_LINE DEDENT 0 NEW_LINE INDENT 0 NEW_LINE DEDENT 1 NEW_LINE INDENT 1 NEW_LINE DEDENT 2 NEW_LINE INDENT 1 NEW_LINE DEDENT 3 NEW_LINE INDENT 1 NEW_LINE DEDENT 4 NEW_LINE INDENT 1 NEW_LINE DEDENT 5 NEW_LINE INDENT 1 NEW_LINE DEDENT 6 NEW_LINE INDENT 1 NEW_LINE DEDENT 7 NEW_LINE INDENT 1 NEW_LINE DEDENT 8 NEW_LINE INDENT 1 NEW_LINE DEDENT 9 NEW_LINE INDENT 1 NEW_LINE DEDENT 10 NEW_LINE INDENT 1 NEW_LINE DEDENT 11 NEW_LINE INDENT 1 NEW_LINE DEDENT 12 NEW_LINE INDENT 1 NEW_LINE DEDENT 13 NEW_LINE INDENT 1 NEW_LINE DEDENT 14 NEW_LINE INDENT 1 NEW_LINE DEDENT 15 NEW_LINE INDENT 1 NEW_LINE DEDENT 16 NEW_LINE INDENT 1 NEW_LINE DEDENT 17 NEW_LINE INDENT 1 NEW_LINE DEDENT 18 NEW_LINE INDENT 1 NEW_LINE DEDENT 19 NEW_LINE INDENT 1 NEW_LINE DEDENT ",0.3547112783317045,0.30439313777748084,0.4665940863121376,0.3448275862068966,0.30303030303030304
24,"def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT","] def minDiff ( n ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE print ( minDiff ( n ) ) NEW_LINE DEDENT 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 72 NEW_LINE 73 NEW_LINE 74 NEW_LINE 7",0.3396317735708375,0.15385405055063106,0.4538312928909682,0.2962962962962963,0.45454545454545453
25,"def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def checkXor ( n ) : NEW_LINE INDENT freq = [ 0 for i in range ( 10 ) ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last = n % 10 NEW_LINE freq [ last ] += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 123 NEW_LINE if ( checkXor ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 2 NEW_LINE 4 NEW_LINE 123 NEW_LINE 1234 NEW_LINE 12345 NEW_LINE 123456 NEW_LINE 1234567 NEW_LINE 12345678 NEW_LINE 123456789 NEW_LINE 1234567890 [/INST] 2 NEW_LINE 4 NEW_LINE 123 NEW_LINE 1234 NEW_LINE 12345 NEW_LINE 123456 NEW_LINE 1234567 NEW_LINE 12345678 NEW_LINE 123456789 NEW_LINE 1234567890 2 NEW_LINE 4 NEW_LINE 123 NEW_LINE 1234 NEW_LINE 12345 NEW_LINE 123456 NEW_LINE 1234567 NEW_LINE 12345678 NEW_LINE 123456789 NEW_LINE",0.4586000159840209,0.3503823243021034,0.575684406300647,0.4583333333333333,0.45
26,"def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT","] \n def printLines ( N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( i + 1 , i + 2 , i + 3 , i + 4 , end = ""   "" ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE K = 2 NEW_LINE printLines ( N , K ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 12 NEW_LINE 14 NEW_LINE 16 NEW_LINE 18 NEW_LINE 20 NEW_LINE 22 NEW_LINE 24 NEW_LINE 26 NEW_LINE 28 NEW_LINE 30 NEW_LINE 32 NEW_LINE 34 NEW_LINE 36 NEW_LINE 38 NEW_LINE 40 NEW_LINE 42 NEW_LINE 44 NEW_LINE 46 NEW_LINE 48 NEW_LINE 50 NEW_LINE 52 NEW_LINE 54 NEW_LINE 56 NEW_LINE 58 NEW_LINE 60 NEW_LINE 62 NEW_LINE 64 NEW_LINE 66 NEW_LINE 68 NEW_LINE 70 NEW_LINE 72 NEW_LINE 74 NEW_LINE 76 NEW_LINE 78 NEW_LINE 80 NEW_LINE 82 NEW_LINE 84 NEW_LINE 86 NEW_LINE 88 NEW_LINE 90 NEW_LINE 92 NEW_LINE 94 NEW_LINE 96 NEW_LINE 98 NEW_LINE 100 NEW_LINE 102 NEW_LINE 104 NEW_LINE 106 NEW_LINE 108 NEW_LINE 110 NEW_LINE 112 NEW_LINE 114 NEW_LINE 116 NEW_LINE 118 NEW_LINE 120 NEW_LINE 122 NEW_LINE 124 NEW_LINE 126 NEW_LINE 128 NEW_LINE 130 NEW_LINE 132 NEW_LINE 134 NEW_",0.16587228193628203,0.12323616392048324,0.26378237558935075,0.17647058823529413,0.1
27,"def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( "" Sum ▁ = "" , calculateSum ( n ) ) NEW_LINE","] \n def sum ( n ) : NEW_LINE INDENT return ( n * ( 4 * n * n + 6 * n - 1 ) ) / 3 NEW_LINE DEDENT n = 5 NEW_LINE print ( "" Sum   of   "" , n , "" terms   = "" , sum ( n ) ) NEW_LINE 1 , 2 , 3 NEW_LINE 4 , 5 , 6 NEW_LINE 7 , 8 , 9 NEW_LINE 10 , 11 , 12 NEW_LINE 13 , 14 , 15 NEW_LINE 16 , 17 , 18 NEW_LINE 19 , 20 , 21 NEW_LINE 22 , 23 , 24 NEW_LINE 25 , 26 , 27 NEW_LINE 28 , 29 , 30 NEW_LINE 31 , 32 , 33 NEW_LINE 34 , 35 , 36 NEW_LINE 37 , 38 , 39 NEW_LINE 40 , 41 , 42 NEW_LINE 43 , 44 , 45 NEW_LINE 46 , 47 , 48 NEW_LINE 49 , 50 , 51 NEW_LINE 52 , 53 , 54 NEW_LINE 55 , 56 , 57 NEW_LINE 58 , 59 , 60 NEW_LINE 61 , 62 , 63 NEW_LINE 64 , 65 , 66 NEW_LINE 67 , 68 , 69 NEW_LINE 70 , 71 , 72 NEW_LINE 73 , 74 , 75 NEW_LINE 76 , 77 , 78 NEW_LINE 79 , 80 , 81 NEW_LINE 82 , 83 , 84 NEW_LINE 85 , 86 , 87 NEW_LINE 88 , 89 , 90 NEW_LINE 91 , 92 , 93 NEW_LINE 94 , 9",0.4112293534471949,0.07792142080928363,0.4717578977414009,0.23809523809523808,0.8571428571428571
28,"mod = 1000000007 NEW_LINE def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE DEDENT","] \n def countSpecialStrings ( n ) : NEW_LINE INDENT fib = [ 0 ] * ( n + 1 ) NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE print ( countSpecialStrings ( n ) ) NEW_LINE DEDENT 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 8 NEW_LINE 13 NEW_LINE 21 NEW_LINE 34 NEW_LINE 55 NEW_LINE 89 NEW_LINE 144 NEW_LINE 233 NEW_LINE 377 NEW_LINE 610 NEW_LINE 987 NEW_LINE 1597 NEW_LINE 2584 NEW_LINE 4181 NEW_LINE 6765 NEW_LINE 10946 NEW_LINE 17711 NEW_LINE 28561 NEW_LINE 46368 NEW_LINE 75025 NEW_LINE 121393 NEW_LINE 196418 NEW_LINE 317811 NEW_LINE 514229 NEW_LINE 832040 NEW_LINE 1346269 NEW_LINE 2178309 NEW_LINE 3524578 NEW_LINE 5702887 NEW_LINE 9227465 NEW_LINE 14930352 NEW_LINE 24157817 NEW_LINE 39088169 NEW_LINE 63245986 NEW_LINE 102334155 NEW_LINE 165580146 NEW_LINE 26791429",0.4562462831479816,0.43870245813104203,0.6825981908075373,0.5121951219512195,0.19148936170212766
29,"mod = 1e9 + 7 ; NEW_LINE def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT","] \n def countPaths ( arr , n , i , j , k ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE if ( i < n and arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT ans += countPaths ( arr , n , i + 1 , j , k ) NEW_LINE DEDENT if ( j < n and arr [ i ] [ j ] == 2 ) : NEW_LINE INDENT ans += countPaths ( arr , n , i , j + 1 , k ) NEW_LINE DEDENT if ( k > 0 and arr [ i ] [ j ] == 3 ) : NEW_LINE INDENT ans += countPaths ( arr , n , i , j , k - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 3 , 2 , 1 ] , [ 1 , 3 , 1 ] ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPaths ( arr , n , 0 , 0 , 1 ) ) NEW_LINE DEDENT 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_",0.3689072671527569,0.1956578254472069,0.3890621522547299,0.16363636363636364,0.7272727272727273
30,"mod = 10 ** 9 + 7 NEW_LINE def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE","] \n def countPaths ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , i + k + 1 ) : NEW_LINE INDENT if j >= n : NEW_LINE INDENT break NEW_LINE DEDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( countPaths ( arr , n , k ) ) NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW",0.36400312426253445,0.2933952730164432,0.49076872205517574,0.3442622950819672,0.3275862068965517
31,"def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT DEDENT return ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( "" EvenSum ▁ = ▁ "" , count_even , "" ▁ OddSum ▁ = ▁ "" , count_odd ) NEW_LINE","] \n def countSubsequences ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd = count_odd + 1 NEW_LINE DEDENT DEDENT return count_even , count_odd NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSubsequences ( arr , n ) NEW_LINE print ( "" Even   Count   of   Subsequences :   "" , count_even ) NEW_LINE print ( "" Odd   Count   of   Subsequences :   "" , count_odd ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 4",0.40299906050337597,0.37538605257970314,0.5571843521132266,0.3157894736842105,0.36363636363636365
32,"MAX = 10 NEW_LINE def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE return digit NEW_LINE DEDENT def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( B < len ( digit ) ) : NEW_LINE INDENT if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE DEDENT return dp [ B ] NEW_LINE DEDENT DEDENT A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE","] \n import numpy as np NEW_LINE def convertToVector ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( n ) : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT v . append ( 0 ) NEW_LINE DEDENT v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT def countIntegers ( A , B , C ) : NEW_LINE INDENT digit = convertToVector ( C ) NEW_LINE if ( digit [ - 1 ] < A [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( digit [ - 1 ] == A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT lower = np . zeros ( B ) NEW_LINE lower [ 0 ] = 0 NEW_LINE for i in range ( 1 , B ) : NEW_LINE INDENT lower [ i ] = A [ i ] NEW_LINE DEDENT if ( digit [ - i - 1 ] == A [ i ] ) : NEW_LINE INDENT lower [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , B ) : NEW_LINE INDENT if ( digit [ - i - 1 ] >= A [ i ] ) : NEW_LINE INDENT if ( digit [ - i - 1 ] == A [ i ] ) : NEW_LINE INDENT lower [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT lower [ i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 1 , B ) : NEW_LINE INDENT ans = ans + lower [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE B = 3 NEW_LINE C = 123 NEW_LINE print ( countIntegers ( A , B , C ) ) NEW_LINE 1 NEW_LINE 2 NEW",0.4146212001990972,0.349212337359967,0.36549160661208674,0.4492753623188406,0.4945054945054945
33,"import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT","] NEW_LINE import sys NEW_LINE def countPaths ( wt , M , K , used , n ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( wt - i >= 0 and used [ wt - i ] == False ) : NEW_LINE INDENT res += countPaths ( wt - i , M , K , used , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE M = 1 NEW_LINE K = 2 NEW_LINE wt = 2 NEW_LINE used = [ False for i in range ( n + 1 ) ] NEW_LINE print ( countPaths ( wt , M , K , used , n ) ) NEW_LINE DEDENT 1 , 2 NEW_LINE 2 , 1 NEW_LINE 1 , 1 NEW_LINE 2 , 2 NEW_LINE 3 , 1 NEW_LINE 3 , 2 NEW_LINE 4 , 1 NEW_LINE 4 , 2 NEW_LINE 5 , 1 NEW_LINE 5 , 2 NEW_LINE 6 , 1 NEW_LINE 6 , 2 NEW_LINE 7 , 1 NEW_LINE 7 , 2 NEW_LINE 8 , 1 NEW_LINE 8 , 2 NEW_LINE 9 , 1 NEW_LINE 9 , 2 NEW_LINE 10 , 1 NEW_LINE 10 , 2 NEW_LINE 11 , 1 NEW_LINE 11 , 2 NEW_LINE 12 , 1 NEW_LINE 12 , 2 NEW_LINE 13 , 1 NEW_LINE 13 , 2 NEW_LINE 14 , 1 NEW_LINE 14 , 2 NEW_LINE 15 , 1 NEW_LINE 15 , 2",0.3742639685640426,0.30907875383438593,0.3826910715760167,0.29508196721311475,0.5102040816326531
34,"def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT",] \n def findPartitions ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT return findPartitions ( n - 1 ) + findPartitions ( n - 2 ) + findPartitions ( n - 3 ) NEW_LINE DEDENT n = 6 NEW_LINE print ( findPartitions ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_,0.21186204282026694,0.08637236542268138,0.1045644557986492,0.1935483870967742,0.46296296296296297
35,"MAX = 20 NEW_LINE def LIP ( dp , mat , n , m , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE DEDENT return dp [ x ] [ y ] NEW_LINE DEDENT def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE","] \n 3 [/INST] \n def dfs ( grid , row , col , dp ) : NEW_LINE INDENT if ( dp [ row ] [ col ] != - 1 ) : NEW_LINE INDENT return dp [ row ] [ col ] NEW_LINE DEDENT if ( row == 0 and col == 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( row == 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = dfs ( grid , row , col - 1 , dp ) + 1 NEW_LINE return dp [ row ] [ col ] NEW_LINE DEDENT if ( col == 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = dfs ( grid , row - 1 , col , dp ) + 1 NEW_LINE return dp [ row ] [ col ] NEW_LINE DEDENT if ( grid [ row ] [ col ] > grid [ row - 1 ] [ col ] ) : NEW_LINE INDENT dp [ row ] [ col ] = dfs ( grid , row - 1 , col , dp ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ row ] [ col ] = dfs ( grid , row , col - 1 , dp ) + 1 NEW_LINE DEDENT return dp [ row ] [ col ] NEW_LINE DEDENT def longestIncreasingPath ( grid ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE dp = [ [ - 1 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE maxi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT maxi = max ( maxi , dfs ( grid , i , j , dp ) ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT grid = [ [ 9 , 9 , 4 ] , [ 6 , 6 , 8 ] , [ 2 , 1 , 1 ] ] NEW_LINE",0.4208065229823642,0.2762756633631849,0.2960949034844354,0.449438202247191,0.6614173228346457
36,"def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( "" ▁ Number ▁ of ▁ Paths ▁ "" , countPaths ( n , m ) ) NEW_LINE","] def countPaths ( x , y ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( x == 0 or y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return countPaths ( x - 1 , y ) + countPaths ( x , y - 1 ) NEW_LINE DEDENT DEDENT x = 2 NEW_LINE y = 2 NEW_LINE print ( countPaths ( x , y ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 6",0.5378086847287811,0.13346747620945107,0.3814036263420368,0.6363636363636364,1.0
37,"MAX = 100 NEW_LINE def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE","] \n def goldMine ( grid , m , n ) : NEW_LINE INDENT goldMineTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT goldMineTable [ i ] [ 0 ] = grid [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT goldMineTable [ 0 ] [ i ] = max ( grid [ 0 ] [ i ] , goldMineTable [ 0 ] [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT goldMineTable [ i ] [ j ] = max ( grid [ i ] [ j ] + max ( goldMineTable [ i - 1 ] [ j ] , goldMineTable [ i - 1 ] [ j - 1 ] , goldMineTable [ i ] [ j - 1 ] ) , goldMineTable [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return goldMineTable [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT grid = [ [ 1 , 3 , 1 , 5 ] , [ 5 , 3 , 4 , 4 ] , [ 2 , 4 , 3 , 1 ] , [ 1 , 2 , 1 , 1 ] ] NEW_LINE m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE print ( "" Maximum   gold   collected   is   "" , goldMine ( grid , m , n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 0 NEW_LINE 3 NEW_LINE 4 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE",0.46652428928721834,0.4030821837279708,0.4187232590260954,0.5257731958762887,0.5185185185185185
38,"M = 100 NEW_LINE def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( "" Minimum ▁ adjustment ▁ cost ▁ is "" , minAdjustmentCost ( arr , n , target ) , sep = ' ▁ ' ) NEW_LINE","] NEW_LINE def minCost ( A , target , M ) : NEW_LINE INDENT N = len ( A ) NEW_LINE dp = [ [ 0 ] * ( M + 1 ) for i in range ( N ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( A [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , abs ( A [ i ] - k ) + dp [ i - 1 ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] [ target ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE M = 3 NEW_LINE target = 1 NEW_LINE print ( minCost ( A , target , M ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 3",0.5485629105294919,0.5105266971887829,0.5673803394541447,0.5978260869565217,0.5185185185185185
39,"def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT","] def countTriplets ( L , R ) : NEW_LINE INDENT total_triplets = 0 NEW_LINE diff = R - L NEW_LINE if ( diff < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT total_triplets = ( diff - 1 ) * diff // 2 NEW_LINE DEDENT return total_triplets NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT L = 1 NEW_LINE R = 1000000 NEW_LINE print ( countTriplets ( L , R ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 1000000 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE ",0.29956857826637723,0.1843844132151616,0.4530958551853349,0.4838709677419355,0.07692307692307693
40,"def printArrays ( n ) : NEW_LINE INDENT A , B = [ ] , [ ] ; NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT DEDENT print ( "" { ▁ "" , end = "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = "" "" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( "" , ▁ "" , end = "" "" ) ; NEW_LINE DEDENT DEDENT print ( "" } "" ) ; NEW_LINE print ( "" { ▁ "" , end = "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = "" "" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( "" , "" , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT print ( "" ▁ } "" , end = "" "" ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE printArrays ( N ) ; NEW_LINE DEDENT","] def generateArrays ( n ) : NEW_LINE INDENT a = [ 0 ] * ( 2 * n ) NEW_LINE b = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT a [ i - 1 ] = i NEW_LINE b [ i - 1 ] = i - n NEW_LINE DEDENT print ( * a , sep = ""   "" ) NEW_LINE print ( * b , sep = ""   "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE generateArrays ( n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW",0.31904781116488345,0.2095455818987158,0.20795001058690496,0.4673913043478261,0.391304347826087
41,"def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT","] \n def flipBits ( A , B ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , ""   "" , B ) NEW_LINE DEDENT A = 15 NEW_LINE B = 11 NEW_LINE flipBits ( A , B ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE",0.6693877415481427,0.3553016824730298,0.7449599064301639,0.6285714285714286,0.9487179487179487
42,def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE,"] def countSum ( arr1 , arr2 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr1 [ i ] + arr2 [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( countSum ( arr1 , arr2 , n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_",0.3075924820043582,0.025752320246393873,0.19481368620241146,0.17647058823529413,0.8333333333333334
43,"def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT count += i NEW_LINE DEDENT return count NEW_LINE DEDENT str = ""00021"" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE","] def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE ans = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT if ( freq [ 0 ] and freq [ 1 ] and freq [ 2 ] ) : NEW_LINE INDENT ans = ( ( freq [ 0 ] * ( freq [ 0 ] - 1 ) ) // 2 + ( freq [ 1 ] * ( freq [ 1 ] - 1 ) ) // 2 + ( freq [ 2 ] * ( freq [ 2 ] - 1 ) ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = ""100010"" NEW_LINE print ( countSubstrings ( str ) ) NEW_LINE DEDENT 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1",0.3663804214086661,0.25597042399843734,0.5257181455997212,0.4915254237288136,0.19230769230769232
44,"def minFlips ( st ) : NEW_LINE INDENT count = 0 NEW_LINE if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( st ) - 2 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = ""0011101"" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT","] \n def minFlips ( s , N ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( N - 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] and s [ i + 1 ] == s [ i + 2 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE S = ""1000"" NEW_LINE print ( minFlips ( S , N ) ) NEW_LINE DEDENT 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_",0.48482447567388487,0.2548715338131618,0.5101406545966634,0.46,0.7142857142857143
45,"def convertToHex ( num ) : NEW_LINE INDENT temp = "" "" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num // 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT def encryptString ( S , N ) : NEW_LINE INDENT ans = "" "" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE while ( i < N and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE hex = convertToHex ( count ) NEW_LINE ans += ch NEW_LINE ans += hex NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" abc "" NEW_LINE N = len ( S ) NEW_LINE print ( encryptString ( S , N ) ) NEW_LINE DEDENT","NT def convertToHex ( n ) : NEW_LINE INDENT hex_ = ""0123456789ABCDEF"" NEW_LINE result = "" "" NEW_LINE while ( n > 0 ) : NEW_LINE INDENT result = hex_ [ n % 16 ] + result NEW_LINE n = n // 16 NEW_LINE DEDENT return result NEW_LINE DEDENT def encrypt ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE result = "" "" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE j = i NEW_LINE while ( S [ j ] == ch ) : NEW_LINE INDENT j += 1 NEW_LINE count += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE result += ch NEW_LINE result += convertToHex ( count ) NEW_LINE DEDENT result = result [ : : - 1 ] NEW_LINE return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = "" aaaaabbbb "" NEW_LINE print ( encrypt ( S ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE ",0.3778814879981217,0.37073544015462634,0.4432744861968347,0.5256410256410257,0.171875
46,"def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countOfString ( N ) : NEW_LINE INDENT Stotal = pow ( 2 , N ) NEW_LINE Sequal = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N // 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) // 2 NEW_LINE return S1 NEW_LINE DEDENT N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE","] def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countStrings ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N , N ) NEW_LINE count1 = binomialCoeff ( 2 * N , N // 2 ) NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT count -= 2 * count1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countStrings ( N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_",0.4922722023006476,0.40509627207571897,0.7336980069725938,0.717391304347826,0.11290322580645161
47,"def removeCharRecursive ( str , X ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return "" "" NEW_LINE DEDENT if ( str [ 0 ] == X ) : NEW_LINE INDENT return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT str = "" geeksforgeeks "" NEW_LINE X = ' e ' NEW_LINE str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE","NT def removeChar ( str , c ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return "" "" NEW_LINE DEDENT if ( str [ 0 ] == c ) : NEW_LINE INDENT return removeChar ( str [ 1 : ] , c ) NEW_LINE DEDENT return str [ 0 ] + removeChar ( str [ 1 : ] , c ) NEW_LINE DEDENT str = "" geeksforgeeks "" NEW_LINE c = ' e ' NEW_LINE print ( removeChar ( str , c ) ) NEW_LINE 2 NEW_LINE DEDENT 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_",0.6991499641519856,0.26619241001588395,0.682737195696001,0.9032258064516129,0.9444444444444444
48,"def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE DEDENT if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = "" : "" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( ""0"" , hh , end = "" : "" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( ""0"" , mm ) NEW_LINE DEDENT DEDENT def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i // 10 NEW_LINE if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j // 10 NEW_LINE if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT timeValue = "" ? ? : ? ? "" NEW_LINE L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE","] def isCorrect ( time , flag ) : NEW_LINE INDENT h = int ( time [ 0 : 2 ] ) NEW_LINE m = int ( time [ 3 : 5 ] ) NEW_LINE if ( h < 0 or h > 23 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( m < 0 or m > 59 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT if ( h != 23 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( m != 59 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkDifference ( time , L , R ) : NEW_LINE INDENT h = int ( time [ 0 : 2 ] ) NEW_LINE m = int ( time [ 3 : 5 ] ) NEW_LINE if ( abs ( h - m ) < L or abs ( h - m ) > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def findTime ( time , L , R ) : NEW_LINE INDENT hour = 0 NEW_LINE minute = 0 NEW_LINE flag = 0 NEW_LINE for i in range ( len ( time ) ) : NEW_LINE INDENT if ( time [ i ] == ' ? ' ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT hour += 1 NEW_LINE DEDENT else : NEW_LINE INDENT minute += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( time [ i ] == ' : ' ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( isCorrect ( time , flag ) ) : NEW_LINE INDENT if ( checkDifference ( time , L , R ) ) : NEW_LINE INDENT return time NEW_LINE DEDENT DEDENT DEDENT DEDENT D",0.29150145000656535,0.2678585441357963,0.29800117570867657,0.32786885245901637,0.2722772277227723
49,"def check ( s , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT str = "" aanncddc "" ; NEW_LINE n = len ( str ) NEW_LINE if ( check ( str , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def isPossible ( str ) : NEW_LINE INDENT stack = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( len ( stack ) > 0 and stack [ - 1 ] == str [ i ] ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT stack . append ( str [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( stack ) == 0 ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT str = "" ababab "" NEW_LINE print ( isPossible ( str ) ) NEW_LINE 3 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE ",0.41595150170046147,0.27124146838342056,0.4487523051325077,0.36486486486486486,0.5789473684210527
50,"from collections import defaultdict NEW_LINE def findNumOfValidWords ( w , p ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE res = [ ] NEW_LINE for s in w : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT m [ val ] += 1 NEW_LINE DEDENT for s in p : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT temp = val NEW_LINE first = ord ( s [ 0 ] ) - ord ( ' a ' ) NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT if ( ( ( temp >> first ) & 1 ) == 1 ) : NEW_LINE INDENT if ( temp in m ) : NEW_LINE INDENT count += m [ temp ] NEW_LINE DEDENT DEDENT temp = ( temp - 1 ) & val NEW_LINE DEDENT res . append ( count ) NEW_LINE DEDENT for it in res : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr1 = [ "" aaaa "" , "" asas "" , "" able "" , "" ability "" , "" actt "" , "" actor "" , "" access "" ] NEW_LINE arr2 = [ "" aboveyz "" , "" abrodyz "" , "" absolute "" , "" absoryz "" , "" actresz "" , "" gaswxyz "" ] NEW_LINE findNumOfValidWords ( arr1 , arr2 ) NEW_LINE DEDENT"," NEW_LINE from collections import defaultdict NEW_LINE from math import log2 NEW_LINE def countStrings ( arr1 , arr2 , n , m ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( len ( arr1 [ i ] ) ) : NEW_LINE INDENT if ( arr1 [ i ] [ j ] == '1' ) : NEW_LINE INDENT temp = temp | ( 1 << j ) NEW_LINE DEDENT DEDENT freq [ temp ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( len ( arr2 [ i ] ) ) : NEW_LINE INDENT if ( arr2 [ i ] [ j ] == '1' ) : NEW_LINE INDENT temp = temp | ( 1 << j ) NEW_LINE DEDENT DEDENT if ( temp in freq ) : NEW_LINE INDENT result . append ( freq [ temp ] ) NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( len ( arr2 [ i ] ) ) : NEW_LINE INDENT if ( arr2 [ i ] [ j ] == '1' ) : NEW_LINE INDENT temp = temp | ( 1 << j ) NEW_LINE DEDENT DEDENT if ( temp in freq ) : NEW_LINE INDENT result . append ( freq [ temp ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT print ( result [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ ""1000"" , ""0100"" , ""1000"" , ""1010"" ] NEW_LINE arr2 = [ ""1000"" , ""0100"" , ""1000"" , ""1010"" ] NEW_LINE N = len ( arr1 ) NEW",0.37521032599254517,0.2655482075058383,0.28409572953663825,0.43434343434343436,0.5168539325842697
51,"def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT while ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE i += 1 NEW_LINE DEDENT s = ' ' . join ( map ( str , s ) ) NEW_LINE return s NEW_LINE DEDENT DEDENT DEDENT s = ""100010001"" NEW_LINE print ( flip ( s ) ) NEW_LINE","T ] \n def printBinary ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT s = s [ 0 : i ] + '1' + s [ i + count : ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT s = ""010010110"" NEW_LINE printBinary ( s ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE",0.34863419419984243,0.22056254028961694,0.513259950795467,0.4107142857142857,0.25
52,"def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = "" "" ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( "" ▁ "" , s [ i ] . lower ( ) , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = "" "" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT s = "" ILoveGeeksForGeeks "" NEW_LINE getOrgString ( s ) NEW_LINE","] def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( s [ i ] , end = "" "" ) NEW_LINE DEDENT elif ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT print ( ""   "" , end = "" "" ) NEW_LINE DEDENT print ( s [ i ] , end = "" "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" GeeksForGeeks "" NEW_LINE convert ( s ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_",0.5132877213947111,0.27243015984696617,0.4831016781128305,0.4642857142857143,0.8333333333333334
53,"' NEW_LINE def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = "" abcac "" NEW_LINE print ( countChar ( str , ' a ' ) ) NEW_LINE","] \n def count_a ( n , k , s ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n >= k ) : NEW_LINE INDENT count = n // k NEW_LINE DEDENT else : NEW_LINE INDENT count = n // k + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 25 NEW_LINE k = 4 NEW_LINE s = "" aabb "" NEW_LINE print ( count_a ( n , k , s ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE aabb NEW_LINE 6 NEW_LINE 10 NEW_LINE 12 NEW_LINE 16 NEW_LINE 20 NEW_LINE 24 NEW_LINE 2 NEW_LINE 6 NEW_LINE 10 NEW_LINE 14 NEW_LINE 18 NEW_LINE 22 NEW_LINE 26 NEW_LINE 1 NEW_LINE 5 NEW_LINE 9 NEW_LINE 13 NEW_LINE 17 NEW_LINE 21 NEW_LINE 25 NEW_LINE 0 NEW_LINE 4 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 20 NEW_LINE 24 NEW_LINE 1 NEW_LINE 5 NEW_LINE 9 NEW_LINE 13 NEW_LINE 17 NEW_LINE 21 NEW_LINE 25 NEW_LINE 0 NEW_LINE 4 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 20 NEW_LINE 24 NEW_LINE 1 NEW_LINE 5 NEW_LINE 9 NEW_LINE 13 NEW_LINE 17 NEW_LINE 21 NEW_LINE 25 NEW_LINE 0 NEW_LINE 4 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 20 NEW_LINE 24 NEW_LINE 1 NEW_LINE 5 NEW_LINE 9 NEW_LINE 13 NEW_LINE 17 NEW_LINE 21 NEW_LINE 25 NEW_LINE ",0.43577559165253743,0.1238072026718661,0.21929516393828347,0.4,0.0
54,"def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 10 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE","] \n def countFrequencies ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , limit + 1 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 9 , 9 , 9 , 9 , 10 , 10 , 10 , 10 , 10 , 10 , 11 , 11 , 11 , 11 , 11 , 12 , 12 , 12 , 13 , 13 , 13 , 13 , 13 , 14 , 14 , 14 , 14 , 14 , 15 , 15 , 15 , 15 , 15 , 15 , 16 , 16 , 16 , 16 , 16 , 16 , 17 , 17 , 17 , 17 , 17 , 17 , 17 , 17 , 17 , 18 , 18 , 18 , 18 , 18 , 18 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 21",0.34172665218452347,0.2496736543488898,0.5447691862732622,0.2391304347826087,0.3333333333333333
55,"def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = ""001001"" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( "" YES "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) ; NEW_LINE DEDENT","] def check ( s , m ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count1 = 0 NEW_LINE count0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if ( count0 >= m ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT if ( count1 >= m ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT DEDENT return "" No "" NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = ""10001"" NEW_LINE m = 3 NEW_LINE print ( check ( s , m ) ) NEW_LINE DEDENT 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE",0.35707793494581175,0.2539640443882802,0.4138434937142945,0.36764705882352944,0.39285714285714285
56,"def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" NEW_LINE k = 2 NEW_LINE print ( productAtKthLevel ( tree , k ) ) NEW_LINE","] def product ( a , k ) : NEW_LINE INDENT res = 1 NEW_LINE level = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT a = 4 NEW_LINE k = 2 NEW_LINE print ( product ( a , k ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE",0.15154318008494494,0.12343092793197948,0.14653489585607618,0.08620689655172414,0.25
57,"def findDuplicates ( a , n , m ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if i != k and a [ i ] [ j ] == a [ k ] [ j ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT for k in range ( m ) : NEW_LINE INDENT if j != k and a [ i ] [ j ] == a [ i ] [ k ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if not isPresent [ i ] [ j ] : NEW_LINE INDENT print ( a [ i ] [ j ] , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE a = [ "" zx "" , "" xz "" ] NEW_LINE findDuplicates ( a , n , m ) NEW_LINE DEDENT","] \n def removeDuplicates ( a , n ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( isPresent [ i ] [ j ] == False ) : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( isPresent [ i ] [ j ] == False ) : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( isPresent [ i ] [ j ] == False ) : NEW_LINE INDENT print ( ""   "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] [ j ] , end = "" "" ) NEW_LINE DEDENT DEDENT print ( "" "" , end = "" "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ [ ' a ' , ' a ' , ' b ' , ' c ' ] , [ ' a ' , ' b ' , ' b ' , ' d ' ] , [ ' b ' , ' d ' , ' e ' , ' e ' ] , [ ' b ' , ' c ' , ' c ' , ' d ' ] ] NEW_LINE n = 4 NEW_LINE removeDuplicates ( a , n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1",0.6016304659185545,0.46648073737287504,0.6215766441200467,0.7432432432432432,0.5752212389380531
58,"def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = ""007462542X "" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Invalid "" ) NEW_LINE DEDENT","] \n def isValidISBN ( s ) : NEW_LINE INDENT if ( len ( s ) != 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT sum = sum + ( ord ( s [ i ] ) - ord ( '0' ) ) * ( 10 - i ) NEW_LINE DEDENT if ( ( ( sum % 11 ) == 0 ) or ( ( sum % 11 ) == 10 and s [ 9 ] == 'X' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s = "" 9781449352717 "" NEW_LINE if ( isValidISBN ( s ) ) : NEW_LINE INDENT print ( "" Valid   ISBN "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Invalid   ISBN "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47",0.4486197443238324,0.27603672587220235,0.3851089180897939,0.5833333333333334,0.55
59,"def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" hello ▁ world "" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT","] \n def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) NEW_LINE DEDENT def reverseVowels ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE vowels = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT vowels . append ( str [ i ] ) NEW_LINE DEDENT DEDENT j = 0 NEW_LINE k = len ( vowels ) - 1 NEW_LINE while ( j < k ) : NEW_LINE INDENT str [ j ] , str [ k ] = str [ k ] , str [ j ] NEW_LINE j += 1 NEW_LINE k -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT str = "" geeksforgeeks "" NEW_LINE str = list ( str ) NEW_LINE print ( "" Original   String : "" , str ) NEW_LINE str = reverseVowels ( str ) NEW_LINE print ( "" Modified   String : "" , "" "" . join ( str ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 3",0.430588299352088,0.24527836227921374,0.28878320707847377,0.6626506024096386,0.5256410256410257
60,"def firstLetterWord ( str ) : NEW_LINE INDENT result = "" "" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" geeks ▁ for ▁ geeks "" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT","] def getString ( s ) : NEW_LINE INDENT output = "" "" NEW_LINE v = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '   ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( v == True ) : NEW_LINE INDENT output += s [ i ] NEW_LINE v = False NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" Geeks   for   Geeks "" NEW_LINE print ( getString ( s ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 5",0.5796504247737673,0.2820947001409825,0.5415575040045915,0.7222222222222222,0.7727272727272727
61,"def dfs ( i , j , grid , vis , ans , z , z_count ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE vis [ i ] [ j ] = 1 NEW_LINE if ( grid [ i ] [ j ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT if ( grid [ i ] [ j ] == 2 ) : NEW_LINE INDENT if ( z == z_count ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT if ( i >= 1 and not vis [ i - 1 ] [ j ] and grid [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i - 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( i < n - 1 and not vis [ i + 1 ] [ j ] and grid [ i + 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i + 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j >= 1 and not vis [ i ] [ j - 1 ] and grid [ i ] [ j - 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j - 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j < m - 1 and not vis [ i ] [ j + 1 ] and grid [ i ] [ j + 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j + 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT def uniquePaths ( grid ) : NEW_LINE INDENT z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT x = i NEW_LINE y = j NEW_LINE DEDENT DEDENT DEDENT grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] NEW_LINE print ( uniquePaths ( grid ) ) NEW_LINE DEDENT","] def dfs ( i , j , vis , ans , z , z_count , mat ) : NEW_LINE INDENT vis [ i ] [ j ] = True NEW_LINE z += 1 NEW_LINE if ( i == len ( mat ) - 1 and j == len ( mat [ 0 ] ) - 1 ) : NEW_LINE INDENT if ( z == z_count ) : NEW_LINE INDENT ans . append ( z ) NEW_LINE DEDENT DEDENT if ( i > 0 and mat [ i - 1 ] [ j ] == '0' and vis [ i - 1 ] [ j ] == False ) : NEW_LINE INDENT dfs ( i - 1 , j , vis , ans , z , z_count , mat ) NEW_LINE DEDENT if ( j > 0 and mat [ i ] [ j - 1 ] == '0' and vis [ i ] [ j - 1 ] == False ) : NEW_LINE INDENT dfs ( i , j - 1 , vis , ans , z , z_count , mat ) NEW_LINE DEDENT if ( i < len ( mat ) - 1 and mat [ i + 1 ] [ j ] == '0' and vis [ i + 1 ] [ j ] == False ) : NEW_LINE INDENT dfs ( i + 1 , j , vis , ans , z , z_count , mat ) NEW_LINE DEDENT if ( j < len ( mat [ 0 ] ) - 1 and mat [ i ] [ j + 1 ] == '0' and vis [ i ] [ j + 1 ] == False ) : NEW_LINE INDENT dfs ( i , j + 1 , vis , ans , z , z_count , mat ) NEW_LINE DEDENT vis [ i ] [ j ] = False NEW_LINE DEDENT def countPaths ( mat ) : NEW_LINE INDENT z_count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT for j in range ( len ( mat [ 0 ] ) ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == '1' ) : NEW_LINE INDENT z_count +=",0.47036405077596444,0.36180531576227115,0.4070483519202592,0.5570469798657718,0.5555555555555556
62,"def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 3 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( numPairs ( a , n ) ) NEW_LINE","] \n def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT right = n - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] > arr [ right ] ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += right - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 1 , - 2 , - 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT 2 1 - 2 - 3 4 NEW_LINE / * 4 * / NEW_LINE / * 2 * / NEW_LINE / * 2 * / NEW_LINE / * 1 * / NEW_LINE / * 4 * / NEW_LINE 2 NEW_LINE 1 NEW_LINE - 2 NEW_LINE - 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE - 2 NEW_LINE - 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE - 2 NEW_LINE - 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE - 2 NEW_LINE - 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE - 2 NEW_LINE - 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE - 2 NEW_LINE - 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE - 2 NEW_LINE - 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE -",0.45114050657333005,0.29642296510084715,0.5540697622400153,0.5294117647058824,0.4246575342465753
63,def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE print ( areaOfSquare ( S ) ) NEW_LINE DEDENT,] def areaOfSquare ( S ) : NEW_LINE INDENT d = S NEW_LINE return d * d NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE print ( areaOfSquare ( S ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 72 NEW_LINE 73 NEW_LINE 7,0.41940617924148976,0.18376707111002888,0.8271909791892634,0.6,0.06666666666666667
64,"def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT x = 3 NEW_LINE y = 4 NEW_LINE print ( maxPointOfIntersection ( x , y ) ) NEW_LINE","] \n N = 4 NEW_LINE M = 5 NEW_LINE def maxPoints ( points ) : NEW_LINE INDENT n = len ( points ) NEW_LINE m = len ( points [ 0 ] ) NEW_LINE dp = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , 1 + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ m - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT points = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 2 ] , [ 2 , 1 ] ] NEW_LINE print ( maxPoints ( points ) ) NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE ",0.1322112274782321,0.02507529343148062,0.12413998685181822,0.08333333333333333,0.2962962962962963
65,def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE,W_LINE INDENT def icosihenagonal ( n ) : NEW_LINE INDENT return ( 17 * n * n - 16 * n + 5 ) // 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( icosihenagonal ( n ) ) NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE 34 NEW_LINE,0.377890186455656,0.10385273908747678,0.36828148343765615,0.4838709677419355,0.5555555555555556
66,"def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( round ( ans [ 0 ] , 12 ) , ans [ 1 ] ) NEW_LINE","] \n def findCentroid ( vertices ) : NEW_LINE INDENT n = len ( vertices ) NEW_LINE A = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT A = A + vertices [ i ] [ 0 ] * vertices [ ( i + 1 ) % n ] [ 1 ] NEW_LINE DEDENT A = A / 3 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = x + vertices [ i ] [ 0 ] * vertices [ ( i + 1 ) % n ] [ 1 ] NEW_LINE y = y + vertices [ i ] [ 1 ] * vertices [ ( i + 1 ) % n ] [ 1 ] NEW_LINE DEDENT x = x / 3 NEW_LINE y = y / 3 NEW_LINE print ( "" Centroid   is   ( "" , x , "" ,   "" , y , "" ) "" ) NEW_LINE DEDENT vertices = [ [ 1 , 1 ] , [ 2 , 4 ] , [ 5 , 3 ] , [ 4 , 1 ] ] NEW_LINE findCentroid ( vertices ) NEW_LINE 1 , 1 NEW_LINE 2 , 4 NEW_LINE 5 , 3 NEW_LINE 4 , 1 NEW_LINE 1 , 1 NEW_LINE 2 , 4 NEW_LINE 5 , 3 NEW_LINE 4 , 1 NEW_LINE 1 , 1 NEW_LINE 2 , 4 NEW_LINE 5 , 3 NEW_LINE 4 , 1 NEW_LINE 1 , 1 NEW_LINE 2 , 4 NEW_LINE 5 , 3 NEW_LINE 4 , 1 NEW_LINE 1 , 1 NEW_LINE 2 , 4 NEW_LINE 5 , 3 NEW_LINE 4 , 1 NEW_LINE 1 , 1 NEW_LINE 2 , 4 NEW_LINE 5 , 3 NEW_LINE 4 , 1 NEW_LINE 1 , 1 NEW_LINE 2 , 4 NEW_LINE 5 , 3 NEW_LINE 4 , 1 NEW_LINE 1 , 1",0.2731523873756963,0.21640127764275183,0.29967443251784487,0.3118279569892473,0.2647058823529412
67,"d = 10 NEW_LINE a = 0.0 NEW_LINE a = ( 360 - ( 6 * d ) ) / 4 NEW_LINE print ( a , "" , "" , a + d , "" , "" , a + 2 * d , "" , "" , a + 3 * d , sep = ' ▁ ' ) NEW_LINE","] \n def angles ( a , b , c , d ) : NEW_LINE INDENT print ( "" Angles   are   : "" ) NEW_LINE print ( "" a   =   "" , ( 180 - a ) ) NEW_LINE print ( "" b   =   "" , ( 180 - b ) ) NEW_LINE print ( "" c   =   "" , ( 180 - c ) ) NEW_LINE print ( "" d   =   "" , ( 180 - d ) ) NEW_LINE DEDENT a = 45 NEW_LINE b = 50 NEW_LINE c = 60 NEW_LINE d = 80 NEW_LINE angles ( a , b , c , d ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE",0.19062188861823753,0.01734054250231187,0.06514701197063828,0.32,0.36
68,"import math NEW_LINE def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( "" Perpendicular ▁ distance ▁ is "" ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Planes ▁ are ▁ not ▁ parallel "" ) NEW_LINE DEDENT DEDENT a1 = 1 NEW_LINE b1 = 2 NEW_LINE c1 = - 1 NEW_LINE d1 = 1 NEW_LINE a2 = 3 NEW_LINE b2 = 6 NEW_LINE c2 = - 3 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) NEW_LINE","] \n def distance ( a , b , c , d , e , f , g , h , i ) : NEW_LINE INDENT return abs ( ( ( a * e - b * d ) * ( g - h ) - ( a * g - c * d ) * ( e - h ) ) / ( ( a * e - b * d ) * ( f - h ) - ( a * f - c * d ) * ( e - h ) ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE e = 5 NEW_LINE f = 6 NEW_LINE g = 7 NEW_LINE h = 8 NEW_LINE i = 9 NEW_LINE print ( distance ( a , b , c , d , e , f , g , h , i ) ) NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE ",0.26706174618837936,0.058276724955425144,0.09032740265523521,0.1875,0.7321428571428571
69,def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def numOfNecklace ( N ) : NEW_LINE INDENT ans = factorial ( N ) // ( factorial ( N // 2 ) * factorial ( N // 2 ) ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans //= 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( numOfNecklace ( N ) ) NEW_LINE DEDENT,"] def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def countWays ( N ) : NEW_LINE INDENT ans = ( fact ( N ) // fact ( N // 2 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66",0.2888122968819759,0.1787033127578673,0.30611600069274586,0.425531914893617,0.24489795918367346
70,"def isDivisibleByDivisor ( S , D ) : NEW_LINE INDENT S %= D NEW_LINE hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE INDENT S += ( S % D ) NEW_LINE S %= D NEW_LINE if ( S in hashMap ) : NEW_LINE INDENT if ( S == 0 ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT return "" No "" NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT DEDENT return "" Yes "" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 3 NEW_LINE D = 6 NEW_LINE print ( isDivisibleByDivisor ( S , D ) ) NEW_LINE DEDENT","] def check ( S , D ) : NEW_LINE INDENT hash = { } NEW_LINE hash [ 0 ] = S % D NEW_LINE for i in range ( 1 , S + 1 ) : NEW_LINE INDENT if ( hash . get ( i , - 1 ) != - 1 ) : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT hash [ i ] = ( hash [ i - 1 ] + hash [ i - 1 ] % D ) % D NEW_LINE DEDENT return "" Yes "" NEW_LINE DEDENT S = 1000 NEW_LINE D = 3 NEW_LINE print ( check ( S , D ) ) NEW_LINE 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1",0.32248859936107244,0.13229084738725186,0.3475162505480363,0.38461538461538464,0.425531914893617
71,"def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x / y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y / x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( int ( cnt ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE y = 1 NEW_LINE minimumSteps ( x , y ) NEW_LINE DEDENT","] def minSteps ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT count += x // y NEW_LINE x = x % y NEW_LINE DEDENT else : NEW_LINE INDENT count += y // x NEW_LINE y = y % x NEW_LINE DEDENT DEDENT if ( x > 1 or y > 1 ) : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT X = 2 NEW_LINE Y = 3 NEW_LINE minSteps ( X , Y ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE ",0.4748109800243958,0.27066256902433716,0.5145462633539478,0.5,0.6140350877192983
72,"def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT red_len = len ( s ) NEW_LINE n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT return ( red_len // 2 + n % 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT expr = "" } } { { "" NEW_LINE print ( countMinReversals ( expr . strip ( ) ) ) NEW_LINE DEDENT","] def minReversals ( s ) : NEW_LINE INDENT m = s . count ( ' ( ' ) ; NEW_LINE n = s . count ( ' ) ' ) ; NEW_LINE if ( ( m + n ) % 2 == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT while ( m > 0 and n > 0 ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT s = s [ : - 1 ] ; NEW_LINE m -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ : - 1 ] ; NEW_LINE n -= 1 ; NEW_LINE DEDENT DEDENT red_len = ( m + n ) ; NEW_LINE return ( m + n ) / 2 + n % 2 ; NEW_LINE DEDENT s = "" ( ( ( ( ) ) ) "" ; NEW_LINE print ( minReversals ( s ) ) ; NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 12 NEW_LINE 14 NEW_LINE 16 NEW_LINE 18 NEW_LINE 20 NEW_LINE 22 NEW_LINE 24 NEW_LINE 26 NEW_LINE 28 NEW_LINE 30 NEW_LINE 32 NEW_LINE 34 NEW_LINE 36 NEW_LINE 38 NEW_LINE 40 NEW_LINE 42 NEW_LINE 44 NEW_LINE 46 NEW_LINE 48 NEW_LINE 50 NEW_LINE 52 NEW_LINE 54 NEW_LINE 56 NEW_LINE 58 NEW_LINE 60 NEW_LINE 62 NEW_LINE 64 NEW_LINE 66 NEW_LINE 68 NEW_LINE 70 NEW_LINE 72 NEW_LINE 74 NEW_LINE 76 NEW_LINE 78 NEW_LINE 80 NEW_LINE 82 NEW_LINE 84 NEW_LINE 86 NEW_LINE 88 NEW_LINE 90 NEW_LINE 92 NEW_LINE ",0.30839292178626365,0.19462271437047632,0.23591099809103414,0.36,0.4430379746835443
73,"def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == "" I "" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == "" D "" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE print ( "" "" , curr_max , end = "" "" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == "" D "" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == "" D "" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( "" "" , curr_max , curr_max - 1 , end = "" "" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" "" , last_entry - 1 , end = "" "" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT PrintMinNumberForPattern ( "" IDID "" ) NEW_LINE PrintMinNumberForPattern ( "" I "" ) NEW_LINE PrintMinNumberForPattern ( "" DD "" ) NEW_LINE PrintMinNumberForPattern ( "" II "" ) NEW_LINE PrintMinNumberForPattern ( "" DIDI "" ) NEW_LINE PrintMinNumberForPattern ( "" IIDDD "" ) NEW_LINE PrintMinNumberForPattern ( "" DDIDDIID "" ) NEW_LINE DEDENT","T ] def minNumber ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE last_entry = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT noOfNextD = ( current_max - last_entry ) NEW_LINE if ( i == 0 ) : NEW_LINE INDENT for j in range ( 1 , current_max + 1 ) : NEW_LINE INDENT print ( j , end = "" "" ) NEW_LINE DEDENT DEDENT current_max += 1 NEW_LINE last_entry = current_max NEW_LINE DEDENT DEDENT elif ( arr [ i ] == ' D ' ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT noOfNextD = current_max - last_entry - 1 NEW_LINE DEDENT else : NEW_LINE INDENT noOfNextD = last_entry - 1 NEW_LINE DEDENT print ( current_max - noOfNextD , end = "" "" ) NEW_LINE print ( current_max - noOfNextD , end = "" "" ) NEW_LINE last_entry = current_max - noOfNextD NEW_LINE DEDENT DEDENT DEDENT 1 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ ' I ' , ' D ' , ' D ' , ' D ' , ' I ' , ' D ' ] NEW_LINE minNumber ( arr , len ( arr ) ) NEW_LINE DEDENT 2 NEW_LINE DEDENT 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE",0.3668606849716468,0.278955619280472,0.29358942570842034,0.4962962962962963,0.3986013986013986
74,"def printLeast ( arr ) : NEW_LINE INDENT min_avail = 1 NEW_LINE pos_of_I = 0 NEW_LINE v = [ ] NEW_LINE if ( arr [ 0 ] == ' I ' ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( 2 ) NEW_LINE v . append ( 1 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 0 NEW_LINE DEDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT v . append ( min_avail ) NEW_LINE min_avail += 1 NEW_LINE pos_of_I = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE for j in range ( pos_of_I , i + 1 ) : NEW_LINE INDENT v [ j ] += 1 NEW_LINE DEDENT min_avail += 1 NEW_LINE DEDENT DEDENT print ( * v , sep = ' ▁ ' ) NEW_LINE DEDENT printLeast ( "" IDID "" ) NEW_LINE printLeast ( "" I "" ) NEW_LINE printLeast ( "" DD "" ) NEW_LINE printLeast ( "" II "" ) NEW_LINE printLeast ( "" DIDI "" ) NEW_LINE printLeast ( "" IIDDD "" ) NEW_LINE printLeast ( "" DDIDDIID "" ) NEW_LINE","] \n def printMinimumNumber ( s , n ) : NEW_LINE INDENT min_avail = 0 NEW_LINE pos_of_I = - 1 NEW_LINE output = [ ] NEW_LINE if ( s [ 0 ] == ' I ' ) : NEW_LINE INDENT output . append ( 1 ) NEW_LINE min_avail = 1 NEW_LINE DEDENT else : NEW_LINE INDENT output . append ( 0 ) NEW_LINE min_avail = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' I ' ) : NEW_LINE INDENT output . append ( min_avail + 1 ) NEW_LINE min_avail = min_avail + 1 NEW_LINE pos_of_I = i NEW_LINE DEDENT else : NEW_LINE INDENT output . append ( min_avail ) NEW_LINE min_avail = min_avail + 1 NEW_LINE DEDENT DEDENT print ( * output ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" DDDIDID "" NEW_LINE n = len ( s ) NEW_LINE printMinimumNumber ( s , n ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38",0.2982850935557357,0.38293752023074246,0.3973607940913168,0.37362637362637363,0.0392156862745098
75,"def PrintMinNumberForPattern ( Strr ) : NEW_LINE INDENT res = ' ' NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( Strr ) + 1 ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if ( i == len ( Strr ) or Strr [ i ] == ' I ' ) : NEW_LINE INDENT while len ( stack ) > 0 : NEW_LINE INDENT res += str ( stack . pop ( ) ) NEW_LINE res += ' ▁ ' NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT PrintMinNumberForPattern ( "" IDID "" ) NEW_LINE PrintMinNumberForPattern ( "" I "" ) NEW_LINE PrintMinNumberForPattern ( "" DD "" ) NEW_LINE PrintMinNumberForPattern ( "" II "" ) NEW_LINE PrintMinNumberForPattern ( "" DIDI "" ) NEW_LINE PrintMinNumberForPattern ( "" IIDDD "" ) NEW_LINE PrintMinNumberForPattern ( "" DDIDDIID "" ) NEW_LINE","] def decode ( s ) : NEW_LINE INDENT result = "" "" NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT stack . append ( int ( s [ i ] ) + 1 ) NEW_LINE DEDENT while ( len ( stack ) > 0 ) : NEW_LINE INDENT result += str ( stack [ - 1 ] ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = ""1001"" NEW_LINE print ( decode ( s ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 2 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0",0.3776498668300209,0.1847608469349783,0.31387053527872233,0.4375,0.574468085106383
76,"def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return "" - 1"" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inputs = [ "" IDID "" , "" I "" , "" DD "" , "" II "" , "" DIDI "" , "" IIDDD "" , "" DDIDDIID "" ] NEW_LINE for Input in inputs : NEW_LINE INDENT print ( * ( getMinNumberForPattern ( Input ) ) ) NEW_LINE DEDENT DEDENT","] \n def minimumNumber ( arr , n ) : NEW_LINE INDENT rank = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT rank [ i ] = i + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT rank [ ord ( arr [ i ] ) - ord ( '0' ) ] = i + 2 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res * 10 + rank [ ord ( arr [ i ] ) - ord ( '0' ) ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ '1' , '2' , '3' , '4' , '5' ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumNumber ( arr , n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE",0.24449692814839552,0.11557909656453447,0.14417526695016247,0.3561643835616438,0.3620689655172414
77,"import math as mt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findMinNum ( arr , n ) : NEW_LINE INDENT first , last = 0 , 0 NEW_LINE Hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( "" Minimum ▁ number : ▁ "" , end = "" "" ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = "" "" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT num = first * 10 + last NEW_LINE rev = last * 10 + first NEW_LINE print ( "" Prime ▁ combinations : ▁ "" , end = "" "" ) NEW_LINE if ( isPrime ( num ) and isPrime ( rev ) ) : NEW_LINE INDENT print ( num , "" ▁ "" , rev ) NEW_LINE DEDENT elif ( isPrime ( num ) ) : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT elif ( isPrime ( rev ) ) : NEW_LINE INDENT print ( rev ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ combinations ▁ exist "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 7 , 8 ] NEW_LINE findMinNum ( arr , 5 ) NEW_LINE","] NEW_LINE def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i * i > n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def smallestNumber ( arr , n ) : NEW_LINE INDENT Hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT res = "" "" NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT while ( Hash [ i ] > 0 ) : NEW_LINE INDENT res += str ( i ) NEW_LINE Hash [ i ] -= 1 NEW_LINE DEDENT DEDENT first = res [ 0 ] NEW_LINE last = res [ len ( res ) - 1 ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( isPrime ( int ( first + i + last ) ) ) : NEW_LINE INDENT print ( first + i + last ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE smallestNumber ( arr , n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE ",0.39032755278399867,0.3659076056711069,0.37327035175368684,0.4298245614035088,0.3923076923076923
78,"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) ; NEW_LINE DEDENT def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , R + 1 ) : NEW_LINE INDENT if ( coprime ( a , b ) and coprime ( b , c ) and coprime ( a , c ) == False ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = a ; NEW_LINE possibleB = b ; NEW_LINE possibleC = c ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( "" ( "" , possibleA , "" , "" , possibleB , "" , "" , possibleC , "" ) ▁ is ▁ one ▁ such "" , "" possible ▁ triplet ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ Such ▁ Triplet ▁ exists ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE","] def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def isCoprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) NEW_LINE DEDENT def findTriplet ( L , R ) : NEW_LINE INDENT flag = False NEW_LINE for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( L , R + 1 ) : NEW_LINE INDENT if ( isCoprime ( a , b ) ) : NEW_LINE INDENT for c in range ( L , R + 1 ) : NEW_LINE INDENT if ( not isCoprime ( b , c ) ) : NEW_LINE INDENT if ( not isCoprime ( a , c ) ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return flag NEW_LINE DEDENT L = 2 NEW_LINE R = 10 NEW_LINE if ( findTriplet ( L , R ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT L = 23 NEW_LINE R = 46 NEW_LINE if ( findTriplet ( L , R ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE ",0.5249922419566623,0.483839763974153,0.48880824894533426,0.4807692307692308,0.646551724137931
79,"import numpy as np NEW_LINE def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 60 NEW_LINE B = 450 NEW_LINE if ( possibleToReach ( A , B ) ) : NEW_LINE INDENT print ( "" yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" no "" ) NEW_LINE DEDENT DEDENT","] \n import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT cube = int ( math . cbrt ( a * b ) ) NEW_LINE if ( a % cube == 0 and b % cube == 0 ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT a = 10 NEW_LINE b = 100 NEW_LINE check ( a , b ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE ",0.46056505559345423,0.1796386727584272,0.2855723692875209,0.3770491803278688,0.0
80,"def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = ""1212121"" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def isUndulating ( n ) : NEW_LINE INDENT num = str ( n ) NEW_LINE len = len ( num ) NEW_LINE if ( len < 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , len - 1 , 2 ) : NEW_LINE INDENT if ( num [ i ] != num [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 1212 NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 12 NEW_LINE 1212 NEW_LINE 121212 NEW_LINE 12121212 NEW_LINE 1212121212 NEW_LINE 121212121212 NEW_LINE 12121212121212 NEW_LINE 1212121212121212 NEW_LINE 121212121212121212 NEW_LINE 12121212121212121212 NEW_LINE 1212121212121212121212 NEW_LINE 121212121212121212121212 NEW_LINE 12121212121212121212121212 NEW_LINE 1212121212121212121212121212 NEW_LINE 121212121212121212121212121212 NEW_LINE 1212121212121212",0.6243049318775271,0.506679458361954,0.7655402691481543,0.625,0.6
81,"def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT n = 3 NEW_LINE res = Series ( n ) NEW_LINE print ( res ) NEW_LINE","] def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 [/INST] 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_LINE 4 NEW_LINE 9 NEW_LINE 16 NEW_LINE 25 NEW_LINE 36 2 NEW_",0.38586657177252065,0.13835325590178352,0.5295149450638973,0.45454545454545453,0.42105263157894735
82,"import math NEW_LINE def counLastDigitK ( low , high , k ) : NEW_LINE INDENT mlow = 10 * math . ceil ( low / 10.0 ) NEW_LINE mhigh = 10 * int ( high / 10.0 ) NEW_LINE count = ( mhigh - mlow ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 <= k and ( low % 10 ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE","] \n def countWithLastDigit ( n , k ) : NEW_LINE INDENT return ( n // 10 ) * ( ( k - 1 ) + 1 ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( countWithLastDigit ( n , k ) ) NEW_LINE 1 , 9 NEW_LINE 2 , 8 NEW_LINE 3 , 7 NEW_LINE 4 , 6 NEW_LINE 5 , 5 NEW_LINE 6 , 4 NEW_LINE 7 , 3 NEW_LINE 8 , 2 NEW_LINE 9 , 1 NEW_LINE 10 , 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE ",0.16866141480044344,0.07048785766697789,0.13082446820146257,0.14,0.3333333333333333
83,"sdef sumDivisible ( L , R ) : NEW_LINE INDENT p = int ( R / 6 ) NEW_LINE q = int ( ( L - 1 ) / 6 ) NEW_LINE sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE return sumR - sumL NEW_LINE DEDENT L = 1 NEW_LINE R = 20 NEW_LINE print ( sumDivisible ( L , R ) ) NEW_LINE","] \n def sumDivisible ( l , r ) : NEW_LINE INDENT n = ( r // 6 ) + 1 NEW_LINE m = ( ( l - 1 ) // 6 ) NEW_LINE sum1 = ( n * ( n + 1 ) // 2 ) * 6 NEW_LINE sum2 = ( m * ( m + 1 ) // 2 ) * 6 NEW_LINE return sum1 - sum2 NEW_LINE DEDENT l = 1 NEW_LINE r = 10 NEW_LINE print ( sumDivisible ( l , r ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW",0.278053199189489,0.07210983496605625,0.19010296179189975,0.5,0.35
84,"import sys NEW_LINE def prevNum ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if int ( string [ i ] ) > int ( string [ i + 1 ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT smallGreatDgt = - 1 NEW_LINE for i in range ( n - 1 , index , - 1 ) : NEW_LINE INDENT if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT DEDENT if index == - 1 : NEW_LINE INDENT return "" "" . join ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT ( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] ) NEW_LINE DEDENT return "" "" . join ( string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n_str = ""34125"" NEW_LINE ans = prevNum ( list ( n_str ) , len ( n_str ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT","] \n def findLargest ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for index in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( index > 0 and str [ index ] > str [ index - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return str NEW_LINE DEDENT for i in range ( index + 1 , n ) : NEW_LINE INDENT if ( str [ index ] > str [ i ] ) : NEW_LINE INDENT swap ( str , index , i ) NEW_LINE return str NEW_LINE DEDENT DEDENT DEDENT def swap ( str , i , j ) : NEW_LINE INDENT temp = str [ i ] NEW_LINE str [ i ] = str [ j ] NEW_LINE str [ j ] = temp NEW_LINE DEDENT str = ""123456"" NEW_LINE print ( findLargest ( str ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW",0.4054507824610056,0.25529674037086314,0.2584212830901804,0.46808510638297873,0.64
85,"def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = ( result * x + poly [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def findSign ( poly , n , x ) : NEW_LINE INDENT result = horner ( poly , n , x ) ; NEW_LINE if ( result > 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( result < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT poly = [ 2 , - 6 , 2 , - 1 ] ; NEW_LINE x = 3 ; NEW_LINE n = len ( poly ) ; NEW_LINE print ( "" Sign ▁ of ▁ polynomial ▁ is ▁ "" , findSign ( poly , n , x ) ) ; NEW_LINE","] def horner ( poly , n ) : NEW_LINE INDENT res = poly [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT res = res * x + poly [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def sign ( poly , n ) : NEW_LINE INDENT return ( horner ( poly , n ) > 0 ) NEW_LINE DEDENT x = 3 NEW_LINE poly = [ 2 , - 6 , 2 , - 1 ] NEW_LINE n = len ( poly ) NEW_LINE if ( sign ( poly , n ) ) : NEW_LINE INDENT print ( "" + "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" - "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54",0.3348363950493507,0.27261509307387427,0.4040320744251159,0.2698412698412698,0.39285714285714285
86,"isPrime = [ 1 ] * 100005 NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE","] \n import math NEW_LINE def sieveOfEratostheneses ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT return prime NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT prime = sieveOfEratostheneses ( 100000 ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( prime [ sum ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = sum + 1 NEW_LINE while ( not prime [ num ] ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT return num - sum NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0",0.3227063010594105,0.2940064171996377,0.39597148550917755,0.4098360655737705,0.19101123595505617
87,"def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Sum ▁ of ▁ SubArray ▁ : "" , SubArraySum ( arr , n ) ) NEW_LINE","] \n def subarraySum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT print ( "" Sum   of   subarray   from   "" , i , "" to   "" , j , "" is   "" , sum ) NEW_LINE sum = 0 NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE subarraySum ( arr , n ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 10 NEW_LINE Sum   of   subarray   from   2   to   4   is   100 NEW_LINE Sum   of   subarray   from   0   to   0   is   0 NEW_LINE Sum   of   subarray   from   0   to   1   is   10 NEW_LINE Sum   of   subarray   from   0   to   2   is   30 NEW_LINE Sum   of   subarray   from   0   to   3   is   70 NEW_LINE Sum   of   subarray   from   0   to   4   is   120 NEW_LINE Sum   of   subarray   from   0   to   5   is   170 NEW_LINE Sum   of   subarray   from   1   to   4   is   140 NEW_LINE Sum   of   subarray   from   1   to   5   is   220 NEW_LINE Sum   of   subarray   from   2   to   5   is   250 NEW_LINE Sum   of   subarray   from   3   to   5   is   210 NEW_LINE Sum   of   subarray   from   4   to   5   is   50 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 10 NEW_LINE 14 NEW_LINE 22 NEW_LINE 25 NEW_LINE 21 NEW_LINE 50 NEW_LINE 2",0.40558704350742514,0.21869504630524378,0.5528640315982014,0.4117647058823529,0.43902439024390244
88,"import math NEW_LINE def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE",] def highestPowerOfTwo ( n ) : NEW_LINE INDENT return ( 1 << ( int ) ( ( ( n + 1 ) / 2 ) ) ) NEW_LINE DEDENT n = 10 NEW_LINE print ( highestPowerOfTwo ( n ) ) NEW_LINE 2 NEW_LINE 20 NEW_LINE 10 NEW_LINE 1 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE,0.19306624205801598,0.06595823286348192,0.27746423062474895,0.1935483870967742,0.23529411764705882
89,"' NEW_LINE def aModM ( s , mod ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT number = ( number * 10 + int ( s [ i ] ) ) NEW_LINE number = number % m NEW_LINE DEDENT return number NEW_LINE DEDENT def ApowBmodM ( a , b , m ) : NEW_LINE INDENT ans = aModM ( a , m ) NEW_LINE mul = ans NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT ans = ( ans * mul ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT a = ""987584345091051645734583954832576"" NEW_LINE b , m = 3 , 11 NEW_LINE print ApowBmodM ( a , b , m ) NEW_LINE","] def mod ( a , m ) : NEW_LINE INDENT while ( a > 0 ) : NEW_LINE INDENT if ( a % m < 0 ) : NEW_LINE INDENT a = a + m NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT def power ( a , b , m ) : NEW_LINE INDENT ans = 1 NEW_LINE a = mod ( a , m ) NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT ans = ( ans * a ) % m NEW_LINE DEDENT a = ( a * a ) % m NEW_LINE b = b // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = ""10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",0.3719125297243058,0.36551674077695945,0.36134906439477343,0.29411764705882354,0.4666666666666667
90,"class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def interpolate ( f : list , xi : int , n : int ) -> float : NEW_LINE INDENT result = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT term = f [ i ] . y NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) NEW_LINE DEDENT DEDENT result += term NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT f = [ Data ( 0 , 2 ) , Data ( 1 , 3 ) , Data ( 2 , 12 ) , Data ( 5 , 147 ) ] NEW_LINE print ( "" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : "" , interpolate ( f , 3 , 4 ) ) NEW_LINE DEDENT","] NEW_LINE class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def interpolate ( x , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT term = 1 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT term *= ( x - x [ j ] ) / ( x [ i ] - x [ j ] ) NEW_LINE DEDENT DEDENT res += term * x [ i ] . y NEW_LINE DEDENT return res NEW_LINE DEDENT x = [ 0 , 1 , 2 , 3 ] NEW_LINE y = [ 0 , 1 , 1 , 2 ] NEW_LINE print ( interpolate ( 3 , 4 ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_",0.44279974928120325,0.34061061042813834,0.418940414306683,0.45901639344262296,0.5526315789473685
91,"def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 1 ) / 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = "" ▁ "" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE","] def printPrimes ( n ) : NEW_LINE INDENT n = n - 1 NEW_LINE marked = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = i * 2 NEW_LINE while ( j <= n ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE j += i * 2 NEW_LINE DEDENT DEDENT print ( ""2   "" , end = "" "" ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT print ( i , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT n = 10 NEW_LINE printPrimes ( n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 11 NEW_LINE 13 NEW_LINE 17 NEW_LINE 19 NEW_LINE 23 NEW_LINE 29 NEW_LINE 31 NEW_LINE 37 NEW_LINE 41 NEW_LINE 43 NEW_LINE 47 NEW_LINE 49 NEW_LINE 53 NEW_LINE 59 NEW_LINE 61 NEW_LINE 67 NEW_LINE 71 NEW_LINE 73 NEW_LINE 79 NEW_LINE 83 NEW_LINE 89 NEW_LINE 97 NEW_LINE 101 NEW_LINE 103 NEW_LINE 107 NEW_LINE 109 NEW_LINE 113 NEW_LINE 127 NEW_LINE 131 NEW_LINE 137 NEW_LINE 139 NEW_LINE 149 NEW_LINE 151 NEW_LINE 157 NEW_LINE 163 NEW_LINE 167 NEW_LINE 173 NEW_LINE 179 NEW_LINE 181 NEW_LINE 191 NEW_LINE 193 NEW_LINE 197 NEW_LINE 199 NEW_LINE 211 NEW_LINE 223",0.36712826838370294,0.3151014479012024,0.41172763394961764,0.33783783783783783,0.40384615384615385
92,"def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N ; NEW_LINE totalXOR = A [ 0 ] ^ K ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 13 , 14 , 10 , 6 ] ; NEW_LINE K = 2 ; NEW_LINE N = len ( A ) ; NEW_LINE constructArray ( A , N , K ) ; NEW_LINE DEDENT","] def reconstructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N NEW_LINE X = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT X ^= A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT B [ i ] = X ^ A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 5 , 6 , 7 , 10 ] NEW_LINE N = len ( A ) NEW_LINE K = 11 NEW_LINE reconstructArray ( A , N , K ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE",0.5414605328788726,0.37151130849304215,0.6851708799754622,0.5581395348837209,0.5510204081632653
93,"def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT A = [ 10 , 15 , 5 ] ; NEW_LINE B = [ 10 , 100 , 15 , 5 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( extraElement ( A , B , n ) ) ; NEW_LINE","] \n def findExtra ( A , B , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= A [ i ] NEW_LINE res ^= B [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT A = [ 1 , 3 , 5 , 7 ] NEW_LINE B = [ 1 , 3 , 5 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( findExtra ( A , B , n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW",0.31035950702724924,0.2208492072316785,0.4553714295729706,0.45652173913043476,0.10869565217391304
94,"def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 9 NEW_LINE n2 = 14 NEW_LINE print ( hammingDistance ( 9 , 14 ) ) NEW_LINE DEDENT","] def hammingDistance ( a , b ) : NEW_LINE INDENT return bin ( a ^ b ) . count ( '1' ) NEW_LINE DEDENT a = 4 NEW_LINE b = 15 NEW_LINE print ( hammingDistance ( a , b ) ) NEW_LINE 1 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 72 NEW_LINE 73 NEW_LINE 74 NEW_LINE ",0.3379818922755911,0.055326253180489574,0.14275516207572106,0.15384615384615385,0.0
95,"def printSubsets ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n & i ) == i ) : NEW_LINE INDENT print ( i , "" ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT n = 9 NEW_LINE printSubsets ( n ) NEW_LINE",] \n def findBitwiseAND ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N ) : NEW_LINE INDENT ans = ans | N NEW_LINE N = N & ( N - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT N = 10 NEW_LINE findBitwiseAND ( N ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 7,0.2581344104661728,0.03948956780149681,0.12995283596795637,0.23809523809523808,0.625
96,"import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 1 << k NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE",] \n def findMSB ( n ) : NEW_LINE INDENT k = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE k += 1 NEW_LINE DEDENT return ( 1 << ( k - 1 ) ) NEW_LINE DEDENT n = 12 NEW_LINE print ( findMSB ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 128 NEW_LINE 256 NEW_LINE 512 NEW_LINE 1024 NEW_LINE 2048 NEW_LINE 4096 NEW_LINE 8192 NEW_LINE 16384 NEW_LINE 32768 NEW_LINE 65536 NEW_LINE 131072 NEW_LINE 262144 NEW_LINE 524288 NEW_LINE 1048576 NEW_LINE 2097152 NEW_LINE 4194304 NEW_LINE 8388608 NEW_LINE 16777216 NEW_LINE 33554432 NEW_LINE 67108864 NEW_LINE 134217728 NEW_LINE 268435456 NEW_LINE 536870912 NEW_LINE 1073741824 NEW_LINE 2147483648 NEW_LINE 4294967296 NEW_LINE 8589934592 NEW_LINE 17179869184 NEW_LINE 34359738368 NEW_LINE 68719476736 NEW_LINE 137438953472 NEW_LINE 274877906944 NEW_LINE 54975581388,0.25920103889595003,0.11945925668994535,0.38734489889385487,0.28,0.25
97,"def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( subset ( ar , n ) ) NEW_LINE","] def countDistinctSubsets ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT repetition = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT repetition += 1 NEW_LINE DEDENT DEDENT res += ( 1 << repetition ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinctSubsets ( arr , n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 20 NEW_LINE 24 NEW_LINE 28 NEW_LINE 32 NEW_LINE 36 NEW_LINE 40 NEW_LINE 44 NEW_LINE 48 NEW_LINE 52 NEW_LINE 56 NEW_LINE 60 NEW_LINE 64 NEW_LINE 68 NEW_LINE 72 NEW_LINE 76 NEW_LINE 80 NEW_LINE 84 NEW_LINE 88 NEW_LINE 92 NEW_LINE 96 NEW_LINE 100 NEW_LINE 104 NEW_LINE 108 NEW_LINE 112 NEW_LINE 116 NEW_LINE 120 NEW_LINE 124 NEW_LINE 128 NEW_LINE 132 NEW_LINE 136 NEW_LINE 140 NEW_LINE 144 NEW_LINE 148 NEW_LINE 152 NEW_LINE 156 NEW_LINE 160 NEW_LINE 164 NEW_LINE 168 NEW_LINE 172 NEW_LINE 176 NEW_LINE 180 NEW_LINE 184 NEW_LINE 188 NEW_LINE 192 NEW_LINE 196 NEW_LINE ",0.3659280851158742,0.2616433039052748,0.4584792929684785,0.41025641025641024,0.3333333333333333
98,"def subset ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subset ( arr , n ) ) NEW_LINE DEDENT","] def countSubsets ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxi = 0 NEW_LINE for i in mp : NEW_LINE INDENT maxi = max ( maxi , mp [ i ] ) NEW_LINE DEDENT return ( 1 << maxi ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubsets ( arr , n ) ) NEW_LINE DEDENT 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE",0.4230608755417165,0.2931922570749274,0.5735193301983215,0.4,0.425531914893617
99,"psquare = [ ] NEW_LINE def calcPsquare ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT psquare . append ( i * i ) NEW_LINE DEDENT DEDENT def countWays ( index , target ) : NEW_LINE INDENT if ( target == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( index < 0 or target < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT inc = countWays ( index , target - psquare [ index ] ) NEW_LINE exc = countWays ( index - 1 , target ) NEW_LINE return inc + exc NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE calcPsquare ( N ) NEW_LINE print ( countWays ( len ( psquare ) - 1 , N ) ) NEW_LINE DEDENT","] \n dp = [ [ 0 for i in range ( 100000 ) ] for j in range ( 100000 ) ] NEW_LINE def preCalculate ( ) : NEW_LINE INDENT for i in range ( 1 , 100000 ) : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , 100000 ) : NEW_LINE INDENT for j in range ( i , 100000 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - i ] + dp [ i ] [ i ] NEW_LINE DEDENT DEDENT DEDENT def countWays ( N ) : NEW_LINE INDENT if ( N == 0 or N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT if ( N == 4 ) : NEW_LINE INDENT return 7 NEW_LINE DEDENT if ( N == 5 ) : NEW_LINE INDENT return 11 NEW_LINE DEDENT if ( N == 6 ) : NEW_LINE INDENT return 15 NEW_LINE DEDENT if ( N == 7 ) : NEW_LINE INDENT return 20 NEW_LINE DEDENT if ( N == 8 ) : NEW_LINE INDENT return 26 NEW_LINE DEDENT if ( N == 9 ) : NEW_LINE INDENT return 33 NEW_LINE DEDENT if ( N == 10 ) : NEW_LINE INDENT return 41 NEW_LINE DEDENT if ( N == 11 ) : NEW_LINE INDENT return 50 NEW_LINE DEDENT if ( N == 12 ) : NEW_LINE INDENT return 60 NEW_LINE DEDENT if ( N == 13 ) : NEW_LINE INDENT return 71 NEW_LINE DEDENT",0.35002331082956767,0.16822347687389422,0.3161152059136966,0.28888888888888886,0.6268656716417911
100,"sum = 0 NEW_LINE class TreeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . size = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def sumofsubtree ( root ) : NEW_LINE INDENT p = [ 1 , 0 ] NEW_LINE if ( root . left ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . left ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . right ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT root . size = p [ 0 ] NEW_LINE return p NEW_LINE DEDENT def distance ( root , target , distancesum , n ) : NEW_LINE INDENT global sum NEW_LINE if ( root . data == target ) : NEW_LINE INDENT sum = distancesum NEW_LINE DEDENT if ( root . left ) : NEW_LINE INDENT tempsum = ( distancesum - root . left . size + ( n - root . left . size ) ) NEW_LINE distance ( root . left , target , tempsum , n ) NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT tempsum = ( distancesum - root . right . size + ( n - root . right . size ) ) NEW_LINE distance ( root . right , target , tempsum , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 1 ) NEW_LINE root . left = TreeNode ( 2 ) NEW_LINE root . right = TreeNode ( 3 ) NEW_LINE root . left . left = TreeNode ( 4 ) NEW_LINE root . left . right = TreeNode ( 5 ) NEW_LINE root . right . left = TreeNode ( 6 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE root . left . left . left = TreeNode ( 8 ) NEW_LINE root . left . left . right = TreeNode ( 9 ) NEW_LINE target = 3 NEW_LINE p = sumofsubtree ( root ) NEW_LINE totalnodes = p [ 0 ] NEW_LINE distance ( root , target , p [ 1 ] , totalnodes ) NEW_LINE print ( sum ) NEW_LINE DEDENT","] \n sum = 0 NEW_LINE def findDistance ( root , target ) : NEW_LINE INDENT global sum NEW_LINE size = [ 0 , 0 ] NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT size [ 0 ] += 1 NEW_LINE findDistance ( root . left , target ) NEW_LINE size [ 0 ] += 1 NEW_LINE findDistance ( root . right , target ) NEW_LINE DEDENT def countDistances ( root , target ) : NEW_LINE INDENT global sum NEW_LINE if ( root == target ) : NEW_LINE INDENT sum += size [ 0 ] NEW_LINE return NEW_LINE DEDENT if ( root . left != None ) : NEW_LINE INDENT sum += size [ 0 ] - size [ 1 ] NEW_LINE countDistances ( root . left , target ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT countDistances ( root . right , target ) NEW_LINE sum += size [ 0 ] - size [ 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = [ 10 , 5 , 1 , 7 , None , 12 , None ] NEW_LINE target = 10 NEW_LINE findDistance ( root , target ) NEW_LINE print ( sum ) NEW_LINE DEDENT 1 NEW_LINE 5 NEW_LINE 1 NEW_LINE 7 NEW_LINE None NEW_LINE 12 NEW_LINE 10 NEW_LINE 20 NEW_LINE 15 NEW_LINE 25 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 6 NEW_LINE 7 NEW_LINE 9 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 1",0.3333258618812646,0.24160433503821416,0.2711425894589442,0.39416058394160586,0.4263959390862944
101,"def rearrangeArray ( A , B , N , K ) : NEW_LINE INDENT B . sort ( reverse = True ) NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ i ] > K ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE K = 5 ; NEW_LINE rearrangeArray ( A , B , N , K ) NEW_LINE DEDENT","] def rearrange ( a , b , n , k ) : NEW_LINE INDENT b . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] > k ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE return NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 8 NEW_LINE rearrange ( a , b , n , k ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE - 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW",0.5242897497011472,0.29660008216801836,0.44925172709408684,0.7777777777777778,0.5735294117647058
102,"def countRows ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE totalSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT totalSum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT currSum = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT currSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( currSum > totalSum - currSum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 2 , - 1 , 5 ] , [ - 3 , 0 , - 2 ] , [ 5 , 1 , 2 ] ] NEW_LINE countRows ( mat ) NEW_LINE DEDENT","] def countRows ( mat , N , M ) : NEW_LINE INDENT row = N NEW_LINE col = M NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT sum_of_row = 0 NEW_LINE for j in range ( col ) : NEW_LINE INDENT sum_of_row += mat [ i ] [ j ] NEW_LINE DEDENT if ( sum_of_row > sum - sum_of_row ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT mat = [ [ 2 , 3 , 4 ] , [ 1 , 2 , 3 ] , [ 1 , 2 , 3 ] ] NEW_LINE N = 3 NEW_LINE M = 3 NEW_LINE countRows ( mat , N , M ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE",0.5015267114375057,0.375420805893598,0.5897386291779825,0.6792452830188679,0.3617021276595745
103,"def areElementsContiguous ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( "" Yes "" ) NEW_LINE else : print ( "" No "" ) NEW_LINE","] def checkContiguous ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] and arr [ i ] != arr [ i - 1 ] + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 5 , 6 , 7 , 8 , 9 , 9 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkContiguous ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 9 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW",0.683396543949331,0.32467366119800967,0.742245847932648,0.6666666666666666,1.0
104,"def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def areContiguous ( arr , n ) : NEW_LINE INDENT m = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > m ) : NEW_LINE INDENT m = arr [ i ] NEW_LINE DEDENT DEDENT M = arr [ n - 1 ] NEW_LINE if ( M - m < n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * ( M + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ arr [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areContiguous ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 6 NEW_LINE 6 NEW_LINE 7 NEW_LINE 7 NEW_LINE 8 NEW_LINE 8 NEW_LINE 9 NEW_LINE 9 NEW_LINE 10 NEW_LINE 10 NEW_LINE 11 NEW_LINE 11 NEW_LINE 12 NEW_LINE 12 NEW_LINE 13 NEW_LINE 13 NEW_LINE 14 NEW_LINE 14 NEW_LINE 15 NEW_LINE 15 NEW_LINE 16 NEW_LINE 16 NEW_LINE 17 NEW_LINE 17 NEW_LINE 18 NEW_LINE 18 NEW_LINE 19 NEW_LINE 19 NEW",0.6073149609432615,0.41979102589273753,0.6795114618035498,0.4642857142857143,0.8656716417910447
105,"def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( "" Yes "" ) NEW_LINE else : print ( "" No "" ) NEW_LINE","] \n def checkContiguous ( arr , n ) : NEW_LINE INDENT us = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us [ arr [ i ] ] = 1 NEW_LINE DEDENT if ( us [ 0 ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for curr_ele in range ( arr [ 0 ] - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( us [ curr_ele ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE while ( us [ curr_ele + count ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT us [ curr_ele ] = count NEW_LINE DEDENT for curr_ele in range ( arr [ 0 ] + 1 , n + 1 ) : NEW_LINE INDENT if ( us [ curr_ele ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE while ( us [ curr_ele + count ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT us [ curr_ele ] = count NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( us [ i ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 2 , 1 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkContiguous ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE 5 NEW_LINE 2 NEW_LINE 0 NEW_LINE ",0.37227580753533973,0.19532233958535866,0.4618720586471681,0.37037037037037035,0.46153846153846156
106,"import collections NEW_LINE def longest ( a , n , k ) : NEW_LINE INDENT freq = collections . defaultdict ( int ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE longest ( a , n , k ) NEW_LINE DEDENT","] \n def longestSubArray ( arr , n , k ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE count = 0 NEW_LINE length = 0 NEW_LINE best = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count > k ) : NEW_LINE INDENT count = k NEW_LINE DEDENT visited [ i ] = 1 NEW_LINE length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT visited [ i ] += 1 NEW_LINE if ( visited [ i ] == 1 ) : NEW_LINE INDENT length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( length > best ) : NEW_LINE INDENT best = length NEW_LINE DEDENT DEDENT print ( "" The   length   of   longest   sub - array   is   "" , best ) NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE longestSubArray ( arr , n , k ) NEW_LINE 1 , 1 , 1 , 2 , 2 , 3 , 3 , 3 [/INST] 2 NEW_LINE 10 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW",0.35974088232416596,0.3136426238044922,0.37380575397702015,0.3181818181818182,0.43333333333333335
107,"def kOverlap ( pairs : list , k ) : NEW_LINE INDENT vec = list ( ) NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE INDENT vec . append ( ( pairs [ 0 ] , - 1 ) ) NEW_LINE vec . append ( ( pairs [ 1 ] , 1 ) ) NEW_LINE DEDENT vec . sort ( key = lambda a : a [ 0 ] ) NEW_LINE st = list ( ) NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT cur = vec [ i ] NEW_LINE if cur [ 1 ] == - 1 : NEW_LINE INDENT st . append ( cur ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT if len ( st ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT pairs = list ( ) NEW_LINE pairs . append ( ( 1 , 3 ) ) NEW_LINE pairs . append ( ( 2 , 4 ) ) NEW_LINE pairs . append ( ( 3 , 5 ) ) NEW_LINE pairs . append ( ( 7 , 10 ) ) NEW_LINE n = len ( pairs ) NEW_LINE k = 3 NEW_LINE if kOverlap ( pairs , k ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] def checkOverlap ( arr , N , K ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT v . append ( [ arr [ i ] , arr [ i ] % 2 ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] [ 1 ] == - 1 ) : NEW_LINE INDENT st . append ( v [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT top = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE if ( v [ i ] [ 0 ] - top <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 4 , 5 , 6 ] NEW_LINE K = 2 NEW_LINE if ( checkOverlap ( arr , 6 , K ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE ",0.5209923865922421,0.40023313612641803,0.456447615615474,0.35772357723577236,0.8695652173913043
108,"N = 5 NEW_LINE ptr = [ 0 for i in range ( 501 ) ] NEW_LINE def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT minrange = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE INDENT minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( "" The ▁ smallest ▁ range ▁ is ▁ [ "" , minel , maxel , "" ] "" ) NEW_LINE DEDENT arr = [ [ 4 , 7 , 9 , 12 , 15 ] , [ 0 , 8 , 10 , 14 , 20 ] , [ 6 , 12 , 16 , 30 , 50 ] ] NEW_LINE k = len ( arr ) NEW_LINE findSmallestRange ( arr , N , k ) NEW_LINE","] \n import sys NEW_LINE ptr = [ 0 for i in range ( 100 ) ] NEW_LINE def findMinRange ( arr , n , k ) : NEW_LINE INDENT ptr [ 0 ] = 0 NEW_LINE minrange = sys . maxsize NEW_LINE min_index = - 1 NEW_LINE max_index = - 1 NEW_LINE while ( min_index != k ) : NEW_LINE INDENT min_index = - 1 NEW_LINE max_index = - 1 NEW_LINE min_val = sys . maxsize NEW_LINE max_val = - sys . maxsize - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == len ( arr [ i ] ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( min_val > arr [ i ] [ ptr [ i ] ] ) : NEW_LINE INDENT min_val = arr [ i ] [ ptr [ i ] ] NEW_LINE min_index = i NEW_LINE DEDENT if ( max_val < arr [ i ] [ ptr [ i ] ] ) : NEW_LINE INDENT max_val = arr [ i ] [ ptr [ i ] ] NEW_LINE max_index = i NEW_LINE DEDENT DEDENT minrange = min ( minrange , max_val - min_val ) NEW_LINE ptr [ min_index ] += 1 NEW_LINE DEDENT return minrange NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 7 , 9 ] , [ 2 , 4 , 6 , 8 , 10 ] , [ 1 , 3 , 5 , 7 , 9 ] ] NEW_LINE k = 3 NEW_LINE print ( findMinRange ( arr , k , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW",0.42983577342012225,0.38916328254584154,0.39107219958609085,0.4666666666666667,0.47244094488188976
109,"def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT S = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( S ) NEW_LINE ans = findLargestd ( S , n ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( "" No ▁ Solution "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + "" , "" c ▁ = ▁ d ▁ is "" , ans ) NEW_LINE DEDENT","] def findLargestD ( S , N ) : NEW_LINE INDENT S . sort ( ) NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = i NEW_LINE k = i - 1 NEW_LINE l = i - 2 NEW_LINE while ( j >= 0 and k >= 0 and l >= 0 ) : NEW_LINE INDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT return S [ i ] NEW_LINE DEDENT j -= 1 NEW_LINE k -= 1 NEW_LINE l -= 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findLargestD ( arr , N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_",0.2634011922275077,0.29753679413679185,0.30162541676531585,0.3684210526315789,0.08602150537634409
110,"def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if abs_diff in mp . keys ( ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE res = findFourElements ( arr , n ) NEW_LINE if ( res == - 10 ** 9 ) : NEW_LINE INDENT print ( "" No ▁ Solution . "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT","] def findFourElements ( arr , n , sum ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( ( sum - arr [ i ] - arr [ j ] - arr [ k ] - arr [ l ] ) in mp . keys ( ) ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] , arr [ k ] , arr [ l ] ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 4 , 45 , 6 , 10 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 22 NEW_LINE findFourElements ( arr , n , sum ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 45 NEW_LINE 6 NEW_LINE 10 NEW_LINE 8 NEW_LINE 22 NEW_LINE 2 / 3 NEW_LINE 4 / 3 NEW_LINE 6 / 3 NEW_LINE 10 / 3 NEW_LINE 8 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 / 3 NEW_LINE 22 /",0.46114137257903576,0.40858628341241193,0.4907752624841884,0.33695652173913043,0.6082474226804123
111,"def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE","] def maxCount ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( maxCount ( arr , n , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW",0.43959065160770394,0.28222034604082974,0.6918599829240679,0.5517241379310345,0.23255813953488372
112,"def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( "" % ▁ d "" % arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE","] def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE i = 0 NEW_LINE while i < d : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT arr [ j - 1 ] = arr [ j ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def leftRotate1 ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotate ( arr , 1 , n ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE d = 2 NEW_LINE leftRotate1 ( arr , d , n ) NEW_LINE printArray ( arr , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 1 NEW_LINE 2 NEW_",0.6657176155608632,0.41570876823456476,0.7373577724402606,0.5098039215686274,0.0
113,"def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT","] def sortInRange ( arr , a , b ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE start = a NEW_LINE end = b NEW_LINE temp = [ 0 ] * ( end - start + 1 ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT temp [ i - start ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i - start ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 4 , 3 , 2 , 10 , 9 ] NEW_LINE a = 1 NEW_LINE b = 5 NEW_LINE sortInRange ( arr , a , b ) NEW_LINE DEDENT 1 NEW_LINE 5 NEW_LINE 4 NEW_LINE 3 NEW_LINE 2 NEW_LINE 10 NEW_LINE 9 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 1 NEW_LINE 5 NEW_LINE 4 NEW_LINE 3 NEW_LINE 2 NEW_LINE 10 NEW_LINE 9 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 1 NEW_LINE 5 NEW_LINE 4 NEW_LINE 3 NEW_LINE 2 NEW_LINE 10 NEW_LINE 9 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 1 NEW_LINE 5 NEW_LINE 4 NEW_LINE 3 NEW_LINE 2 NEW_LINE 10 NEW_LINE 9 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 1 NEW_LINE 5 NEW_LINE 4 NEW_LINE 3 NEW_LINE 2 NEW_LINE 10 NEW_LINE 9 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE",0.5573796205395022,0.4073628647147152,0.5298479251356011,0.2923076923076923,0.0
114,"MAX_SIZE = 10 NEW_LINE def sortByRow ( mat , n , descending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( descending == True ) : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT DEDENT def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mat [ i ] [ j ] , mat [ j ] [ i ] = mat [ j ] [ i ] , mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n , True ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n , False ) NEW_LINE transpose ( mat , n ) ; NEW_LINE DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( "" Original ▁ Matrix : ▁ "" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( "" Matrix ▁ After ▁ Sorting : "" ) NEW_LINE printMat ( mat , n ) NEW_LINE DEDENT","] \n import sys NEW_LINE def sortRows ( mat , n , descending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if ( descending [ i ] [ j ] < descending [ i ] [ j + 1 ] ) : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ i ] [ j + 1 ] NEW_LINE mat [ i ] [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT def getTranspose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = temp NEW_LINE DEDENT DEDENT DEDENT def sortMatrix ( mat , n , descending ) : NEW_LINE INDENT sortRows ( mat , n , descending ) NEW_LINE getTranspose ( mat , n ) NEW_LINE sortRows ( mat , n , descending ) NEW_LINE getTranspose ( mat , n ) NEW_LINE DEDENT def printMatrix ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = ""   "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE descending = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE sortMatrix ( mat , n , descending ) NEW_LINE printMatrix ( mat , n ) NEW_LINE 2",0.5302868807741267,0.5296616062016253,0.5777768536808677,0.4752475247524752,0.5384615384615384
115,"def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( "" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : "" ) NEW_LINE print ( arr ) NEW_LINE","] def moveZeroes ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT arr = [ 1 , 0 , 2 , 0 , 3 , 0 , 4 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE moveZeroes ( arr , n ) NEW_LINE print ( arr ) NEW_LINE 1 , 0 , 2 , 0 , 3 , 0 , 4 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST] 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 [/INST]",0.3652597464482242,0.26634230462182873,0.5995747299515557,0.4,0.1951219512195122
116,"def moveZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Original ▁ array : "" , end = "" ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE moveZerosToEnd ( arr , n ) NEW_LINE print ( "" Modified array : "" , ▁ end = ""   "" ) NEW_LINE printArray ( arr , n ) NEW_LINE","] def moveZeroes ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE ( arr [ i ] , arr [ count ] ) = ( arr [ count ] , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT def printArr ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 0 , 3 , 0 , 4 , 5 , 0 ] NEW_LINE moveZeroes ( arr ) NEW_LINE printArr ( arr ) NEW_LINE 1 , 2 , 3 , 4 , 5 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW_LINE 2 , 3 , 4 , 5 , 0 , 0 , 0 , 0 NEW",0.47276456142597134,0.29041989813639174,0.4981973711769374,0.49019607843137253,0.6122448979591837
117,"def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT def modifyAndRearrangeArr ( ar , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] = 2 * arr [ i ] NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZerosToEnd ( arr , n ) NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Original ▁ array : "" , end = "" ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE modifyAndRearrangeArr ( arr , n ) NEW_LINE print ( "" Modified array : "" , end = ""   "" ) NEW_LINE printArray ( arr , n ) NEW_LINE","T ] def pushZero ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT def rearrange ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * 2 NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZero ( arr , n ) NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 0 , 2 , 0 , 3 , 0 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 3 NEW_LINE 0 NEW_LINE 4 NEW_LINE 0 NEW_LINE 5 NEW_LINE 0 NEW_LINE 6 NEW_LINE 7 NEW_LINE 0 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 10 NEW_LINE 0 NEW_LINE 11 NEW_LINE 12 NEW_LINE 0 NEW_LINE 13 NEW_LINE 14 NEW_LINE 0 NEW_LINE 15 NEW_LINE 16 NEW_LINE 0 NEW_LINE 17 NEW_LINE ",0.6413665100909635,0.6621827091953124,0.6666166645018752,0.6666666666666666,0.57
118,"def shiftAllZeroToLeft ( arr , n ) : NEW_LINE INDENT lastSeenNonZero = 0 NEW_LINE for index in range ( 0 , n ) : NEW_LINE INDENT if ( array [ index ] != 0 ) : NEW_LINE INDENT array [ index ] , array [ lastSeenNonZero ] = array [ lastSeenNonZero ] , array [ index ] NEW_LINE lastSeenNonZero += 1 NEW_LINE DEDENT DEDENT DEDENT","] \n def shiftZeroesToLeft ( arr , n ) : NEW_LINE INDENT lastSeen = n - 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] , arr [ lastSeen ] = arr [ lastSeen ] , arr [ i ] NEW_LINE lastSeen -= 1 NEW_LINE DEDENT DEDENT DEDENT 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 3 NEW_LINE 0 NEW_LINE 5 NEW_LINE 0 NEW_LINE 7 NEW_LINE 0 NEW_LINE 9 NEW_LINE 0 NEW_LINE 11 NEW_LINE 0 NEW_LINE 13 NEW_LINE 0 NEW_LINE 15 NEW_LINE 0 NEW_LINE 17 NEW_LINE 0 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67",0.46508860412559616,0.12212133323515122,0.4048997499339002,0.5555555555555556,0.7777777777777778
119,"def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if ( key > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT","] def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT def rearrange ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ j - 1 ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT printArr ( arr , n ) NEW_LINE DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW",0.46072095924613504,0.3891733733972071,0.5765174811311926,0.4605263157894737,0.4166666666666667
120,"def printArray ( A , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( A [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def reverse ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE l , r = l + 1 , r - 1 NEW_LINE reverse ( arr , l , r ) NEW_LINE DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE while i <= m and arr [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j <= r and arr [ j ] < 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT reverse ( arr , i , m ) NEW_LINE reverse ( arr , m + 1 , j - 1 ) NEW_LINE reverse ( arr , i , j - 1 ) NEW_LINE DEDENT def RearrangePosNeg ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE RearrangePosNeg ( arr , l , m ) NEW_LINE RearrangePosNeg ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE RearrangePosNeg ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT","] def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT def reverse ( arr , l , r ) : NEW_LINE INDENT while ( l < r ) : NEW_LINE INDENT temp = arr [ l ] NEW_LINE arr [ l ] = arr [ r ] NEW_LINE arr [ r ] = temp NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE k = l NEW_LINE while ( i <= m and j <= r ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ j ] < 0 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while ( i <= m ) : NEW_LINE INDENT arr [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= r ) : NEW_LINE INDENT arr [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT def rearrange ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE if ( m == l ) : NEW_LINE INDENT m += 1 NEW_LINE DEDENT if ( arr [ m ] < 0 ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT merge ( arr",0.3946900320075853,0.4351309087594787,0.44657632819062926,0.4742268041237113,0.22282608695652173
121,"def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( arr [ i ] < 0 and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE print ( * arr ) NEW_LINE","] def rearrange ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j and arr [ i ] < 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i < j and arr [ j ] > 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , - 2 , - 1 , 3 , 2 , - 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE - 3 NEW_LINE - 2 NEW_LINE 5 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_",0.4002642271462808,0.3435672490578112,0.614632516670169,0.39285714285714285,0.25
122,"def winner ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( "" A "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" B "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 24 , 45 , 45 , 24 ] NEW_LINE N = len ( arr ) NEW_LINE winner ( arr , N ) NEW_LINE DEDENT","] def findWinner ( arr , n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT print ( "" A "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" B "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 6 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE findWinner ( arr , N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE",0.6821517221887418,0.24959883666292254,0.7218866128116846,0.8260869565217391,0.9310344827586207
123,"import math NEW_LINE sz = 20 NEW_LINE sqr = int ( math . sqrt ( sz ) ) + 1 NEW_LINE def precomputeExpressionForAllVal ( arr , N , dp ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( i + j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def querySum ( arr , N , Q , M ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( sz ) ] for x in range ( sqr ) ] NEW_LINE precomputeExpressionForAllVal ( arr , N , dp ) NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE if ( y <= math . sqrt ( N ) ) : NEW_LINE INDENT print ( dp [ x ] [ y ] ) NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 7 , 5 , 4 ] NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q [ 0 ] ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE","] NEW_LINE def sum ( arr , N , dp , X ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( pow ( X , 2 ) + 1 ) ) : NEW_LINE INDENT if ( i + j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + arr [ i + j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def findSum ( arr , N , Q , M , dp ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE sum = 0 NEW_LINE for j in range ( x , N , y ) : NEW_LINE INDENT sum += dp [ j ] [ y ] NEW_LINE DEDENT print ( sum , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE X = 2 NEW_LINE dp = [ [ 0 for i in range ( int ( pow ( X , 2 ) + 1 ) ) ] for i in range ( N ) ] NEW_LINE sum ( arr , N , dp , X ) NEW_LINE Q = [ [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ] NEW_LINE M = len ( Q ) NEW_LINE findSum ( arr , N , Q , M , dp ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 1 NEW",0.5868760397703637,0.560280226388078,0.6112119386903785,0.41739130434782606,0.7586206896551724
124,"def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","] \n def printGreaterElements ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 16 , 17 , 4 , 3 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printGreaterElements ( arr , n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 17 NEW_LINE 16 NEW_LINE 2 NEW_LINE 3 NEW_LINE ",0.6572717797500586,0.35803986522293846,0.7835472537772957,0.6875,0.8
125,"def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","] def printGreater ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] < arr [ i + 1 ] ) and ( arr [ i ] < arr [ i + 2 ] ) ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 4 , 5 , 6 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printGreater ( arr , n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_",0.5950594170847203,0.21992194917168095,0.7514487240933088,0.5517241379310345,0.8571428571428571
126,"import sys NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","] \n def printGreater ( arr , n ) : NEW_LINE INDENT first = - 1 NEW_LINE second = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > first and arr [ i ] < second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == first or arr [ i ] == second ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printGreater ( arr , n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE",0.6242699744441145,0.44914949287530564,0.8044239113946587,0.6363636363636364,0.6071428571428571
127,"def getMinOps ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 1 , 2 ] NEW_LINE print ( getMinOps ( arr ) ) NEW_LINE","] def minOperations ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT res += arr [ i ] - arr [ i + 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE",0.4129297595507034,0.1857094498445492,0.6445810169296929,0.32142857142857145,0.5
128,"def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Smallest ▁ missing ▁ element ▁ is "" , findFirstMissing ( arr , 0 , n - 1 ) ) NEW_LINE","] def smallestMissing ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestMissing ( arr , n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66",0.31034582395647714,0.20732877662364024,0.3026715404788639,0.10638297872340426,0.625
129,"def findFirstMissing ( arr , start , end , first ) : NEW_LINE INDENT if ( start < end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( arr [ mid ] != mid + first ) : NEW_LINE INDENT return findFirstMissing ( arr , start , mid , first ) NEW_LINE DEDENT else : NEW_LINE INDENT return findFirstMissing ( arr , mid + 1 , end , first ) NEW_LINE DEDENT DEDENT return start + first NEW_LINE DEDENT def findSmallestMissinginSortedArray ( arr ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ - 1 ] == len ( arr ) - 1 ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE return findFirstMissing ( arr , 0 , len ( arr ) - 1 , first ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" First ▁ Missing ▁ element ▁ is ▁ : "" , findSmallestMissinginSortedArray ( arr ) ) NEW_LINE","] def findMissingElement ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def smallestMissing ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != i - 1 ) : NEW_LINE INDENT return i - 1 NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestMissing ( arr , n ) ) NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 0 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 0 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 0 , 1 , 2 , 3 , 4 NEW_LINE 0 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 0 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 , 4 , 5 NEW_LINE 4 NEW_LINE 1 , 2 , 3 ,",0.37538970278565287,0.26489664734817686,0.3857849708119786,0.3508771929824561,0.5
130,"def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE INDENT new_excl = excl if excl > incl else incl NEW_LINE incl = excl + i NEW_LINE excl = new_excl NEW_LINE DEDENT return ( excl if excl > incl else incl ) NEW_LINE DEDENT arr = [ 5 , 5 , 10 , 100 , 10 , 5 ] NEW_LINE print find_max_sum ( arr ) NEW_LINE","] def maxSum ( arr , n ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT incl = max ( excl + arr [ i ] , incl ) NEW_LINE excl = max ( incl - arr [ i ] , excl ) NEW_LINE DEDENT return max ( incl , excl ) NEW_LINE DEDENT arr = [ 1 , 3 , - 1 , 2 , 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE 1 NEW_LINE 3 NEW_LINE - 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 4 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE",0.27904515638588656,0.11977867712336582,0.3761011965404812,0.35714285714285715,0.2631578947368421
131,"def countChanges ( matrix , n , m ) : NEW_LINE INDENT dist = n + m - 1 NEW_LINE freq = [ [ 0 ] * 10 for i in range ( dist ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE INDENT maximum = 0 NEW_LINE total_values = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT min_changes_sum += ( total_values - maximum ) NEW_LINE DEDENT return min_changes_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 ] , [ 3 , 5 ] ] NEW_LINE print ( countChanges ( mat , 2 , 2 ) ) NEW_LINE DEDENT","] def minChanges ( matrix ) : NEW_LINE INDENT n = len ( matrix ) NEW_LINE m = len ( matrix [ 0 ] ) NEW_LINE for i in range ( n + m - 2 ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE for j in range ( n + m - 2 ) : NEW_LINE INDENT if ( i + j < n and i + j >= 0 ) : NEW_LINE INDENT freq [ matrix [ i + j ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT max_freq = max ( freq ) NEW_LINE total_cells = ( i + 1 ) * 2 NEW_LINE ans = total_cells - freq [ max_freq ] NEW_LINE for j in range ( n + m - 2 ) : NEW_LINE INDENT if ( i + j < n and i + j >= 0 ) : NEW_LINE INDENT if ( matrix [ i + j ] [ j ] != max_freq ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT matrix = [ [ 1 , 1 , 1 ] , [ 2 , 2 , 2 ] , [ 3 , 3 , 3 ] ] NEW_LINE print ( minChanges ( matrix ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0",0.41395478055684964,0.3186168873844377,0.4241985718392978,0.32967032967032966,0.5833333333333334
132,"import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while ( i + ( 1 << j ) - 1 ) < n : NEW_LINE INDENT if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE if lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] : NEW_LINE INDENT return lookup [ L ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return lookup [ R - ( 1 << j ) + 1 ] [ j ] NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE lookup = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 4 , 7 ) ) NEW_LINE print ( query ( 7 , 8 ) ) NEW_LINE DEDENT","] \n 10 NEW_LINE def build ( lookup , arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT lookup [ i ] [ i ] = arr [ i ] NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT for i in range ( n - 2 ** j ) : NEW_LINE INDENT lookup [ i ] [ i + 2 ** j ] = min ( lookup [ i ] [ i + 2 ** ( j - 1 ) ] , lookup [ i + 2 ** ( j - 1 ) ] [ i + 2 ** j ] ) NEW_LINE DEDENT DEDENT DEDENT def query ( lookup , L , R ) : NEW_LINE INDENT j = 0 NEW_LINE while ( 1 << ( j + 1 ) <= R - L + 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT return min ( lookup [ L ] [ L + 1 << ( j - 1 ) ] , lookup [ L + 1 << ( j - 1 ) ] [ R ] ) NEW_LINE DEDENT lookup = [ [ 0 for i in range ( 10000 ) ] for j in range ( 10000 ) ] NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE build ( lookup , arr , len ( arr ) ) NEW_LINE print ( query ( lookup , 2 , 10 ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE ",0.33170706020738455,0.3748832199307518,0.37504153223059195,0.31932773109243695,0.25757575757575757
133,"import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT table [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - ( 1 << j ) : NEW_LINE INDENT table [ i ] [ j ] = math . gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE return math . gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE table = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 2 ) ) NEW_LINE print ( query ( 1 , 3 ) ) NEW_LINE print ( query ( 4 , 5 ) ) NEW_LINE DEDENT","] \n from math import gcd NEW_LINE def build ( arr , lookup , n ) : NEW_LINE INDENT lookup [ 0 ] [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = gcd ( lookup [ 0 ] [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT lookup [ j ] [ i ] = gcd ( lookup [ j - 1 ] [ i ] , lookup [ j - 1 ] [ i - ( 1 << j ) ] ) NEW_LINE DEDENT DEDENT DEDENT def RMQ ( arr , L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return arr [ L ] NEW_LINE DEDENT j = 0 NEW_LINE while ( ( 1 << ( j + 1 ) ) <= R - L + 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT return gcd ( lookup [ j ] [ R - L + 1 ] , lookup [ j ] [ L ] ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE lookup = [ [ 0 for i in range ( n ) ] for j in range ( 10 ) ] NEW_LINE build ( arr , lookup , n ) NEW_LINE L = 2 NEW_LINE R = 8 NEW_LINE print ( RMQ ( arr , L , R ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_",0.4443431579699995,0.3654526193819746,0.42896261901431426,0.42105263157894735,0.5619047619047619
134,"def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT n , k = 5 , 3 NEW_LINE arr = [ 7 , 6 , 9 , 2 , 1 ] NEW_LINE / * Function calling * / NEW_LINE minimizeWithKSwaps ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT","] \n def findMinArray ( arr , n , k ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT Minimum = min ( arr [ i + 1 ] , n ) NEW_LINE arr [ i ] , arr [ pos ] = arr [ pos ] , arr [ i ] NEW_LINE pos += Minimum NEW_LINE k -= Minimum NEW_LINE DEDENT return arr NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( * findMinArray ( arr , n , k ) ) NEW_LINE 1 , 2 , 3 , 4 , 5 [/INST] 2 , 1 , 5 , 4 , 3 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST] 1 , 2 , 3 , 4 , 5 [/INST]",0.3312492605544396,0.20638636091758067,0.3297720689321536,0.35294117647058826,0.4358974358974359
135,"def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length "" , k , "" begins ▁ at ▁ index "" , findMaxAverage ( arr , n , k ) ) NEW_LINE","] def maxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT csum [ i ] = arr [ i ] NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT csum [ i ] += csum [ i - j ] NEW_LINE DEDENT DEDENT max_sum = csum [ k - 1 ] NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( csum [ i ] - csum [ i - k ] > max_sum ) : NEW_LINE INDENT max_sum = csum [ i ] - csum [ i - k ] NEW_LINE DEDENT DEDENT return ( max_sum ) / k NEW_LINE DEDENT arr = [ 1 , 10 , 20 , 30 , 40 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( "" Maximum   average   is   % f "" % maxAverage ( arr , n , k ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 50 NEW_LINE 1 NEW_LINE 10 NEW_LINE 20 NEW_LINE 30 NEW_LINE 40 NEW_LINE 50 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 50 NEW_LINE 1 NEW_LINE 10 NEW_LINE 20 NEW_LINE 30 NEW_LINE 40 NEW_LINE 50 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 50 NEW_LINE 1 NEW_LINE 10 NEW_LINE 20 NEW_LINE 30 NEW_LINE 40 NEW_LINE 50 NEW_LINE ",0.5017415857584049,0.42178730253502666,0.568512373831926,0.5416666666666666,0.475
136,"def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length "" , k , "" begins ▁ at ▁ index "" , findMaxAverage ( arr , n , k ) ) NEW_LINE"," def findStart ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE max_sum = max ( max_sum , sum ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 10 , 20 , 30 , 40 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( findStart ( arr , n , k ) ) NEW_LINE 1 , 10 , 20 , 30 , 40 , 50 NEW_LINE k = 4 NEW_LINE print ( findStart ( arr , n , k ) ) NEW_LINE 1 , 10 , 20 , 30 , 40 , 50 NEW_LINE k = 6 NEW_LINE print ( findStart ( arr , n , k ) ) NEW_LINE 1 , 10 , 20 , 30 , 40 , 50 NEW_LINE 2 / 3 NEW_LINE 1 , 10 , 20 , 30 , 40 , 50 NEW_LINE k = 2 NEW_LINE print ( findStart ( arr , n , k ) ) NEW_LINE 1 , 10 , 20 , 30 , 40 , 50 NEW_LINE 2 / 3 NEW_LINE 1 , 10 , 20 , 30 , 40 , 50 NEW_LINE k = 1 NEW_LINE print ( findStart ( arr , n , k ) ) NEW_LINE 1 , 10 , 20 , 30 , 40 , 50 NEW_LINE 2 / 3 NEW_LINE 1 , 10 , 20 , ",0.5540850343867214,0.3522302203206655,0.580776583892887,0.4222222222222222,0.8611111111111112
137,"m = dict ( ) NEW_LINE def findMinimum ( a , n , pos , myturn ) : NEW_LINE INDENT if ( pos , myturn ) in m : NEW_LINE INDENT return m [ ( pos , myturn ) ] ; NEW_LINE DEDENT if ( pos >= n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( not myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , not myturn ) + a [ pos ] + a [ pos + 1 ] ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if ( myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) , findMinimum ( a , n , pos + 2 , not myturn ) ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT def countPenality ( arr , N ) : NEW_LINE INDENT pos = 0 ; NEW_LINE turn = False ; NEW_LINE return findMinimum ( arr , N , pos , turn ) + 1 ; NEW_LINE DEDENT def printAnswer ( arr , N ) : NEW_LINE INDENT a = countPenality ( arr , N ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printAnswer ( arr , N ) ; NEW_LINE DEDENT","] \n s = { } NEW_LINE def find_min_score ( pos , myturn , arr , n ) : NEW_LINE INDENT if ( pos , myturn ) in s : NEW_LINE INDENT return s [ ( pos , myturn ) ] NEW_LINE DEDENT if ( pos == n ) : NEW_LINE INDENT if ( myturn == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ pos - 1 ] NEW_LINE DEDENT DEDENT if ( myturn == 0 ) : NEW_LINE INDENT ans = min ( find_min_score ( pos + 1 , 1 , arr , n ) + arr [ pos - 1 ] , find_min_score ( pos + 2 , 1 , arr , n ) + arr [ pos - 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( find_min_score ( pos + 1 , 0 , arr , n ) + arr [ pos - 1 ] , find_min_score ( pos + 2 , 0 , arr , n ) + arr [ pos - 2 ] ) NEW_LINE DEDENT s [ ( pos , myturn ) ] = ans NEW_LINE return ans NEW_LINE DEDENT def find_min_penality ( arr , n ) : NEW_LINE INDENT pos = 1 NEW_LINE myturn = 0 NEW_LINE print ( find_min_score ( pos , myturn , arr , n ) ) NEW_LINE print ( n * arr [ 0 ] ) NEW_LINE print ( find_min_score ( pos , myturn , arr , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 0 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE find_min_penality ( arr , N ) NEW_LINE DEDENT 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE DEDENT 1",0.5043554924176152,0.41569025691696126,0.40880923284959125,0.45569620253164556,0.7372262773722628
138,"import math NEW_LINE MAX = 1000001 NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT def getSumUtil ( st , ss , se , qs , qe , si ) : NEW_LINE INDENT if qs <= ss and qe >= se : NEW_LINE INDENT return st [ si ] NEW_LINE DEDENT if se < qs or ss > qe : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return ( getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ) NEW_LINE DEDENT def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE INDENT if i < ss or i > se : NEW_LINE INDENT return NEW_LINE DEDENT st [ si ] = st [ si ] + diff NEW_LINE if se != ss : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT DEDENT def updateValue ( arr , st , n , i , new_val ) : NEW_LINE INDENT if i < 0 or i > n - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT diff = new_val - arr [ i ] NEW_LINE prev_val = arr [ i ] NEW_LINE arr [ i ] = new_val NEW_LINE if prime [ new_val ] or prime [ prev_val ] : NEW_LINE INDENT if not prime [ prev_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) NEW_LINE DEDENT elif not prime [ new_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT DEDENT DEDENT def getSum ( st , n , qs , qe ) : NEW_LINE INDENT if qs < 0 or qe > n - 1 or qs > qe : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ss == se : NEW_LINE INDENT if prime [ arr [ ss ] ] : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = ( constructSTUtil ( arr , ss , mid , st , 2 * si + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , 2 * si + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT def constructST ( arr , n ) : NEW_LINE INDENT x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE max_size = 2 * int ( pow ( 2 , x ) ) - 1 NEW_LINE st = [ 0 ] * max_size NEW_LINE constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE return st NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 9 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE Q = [ [ 1 , 1 , 3 ] , [ 2 , 1 , 10 ] , [ 1 , 1 , 3 ] ] NEW_LINE SieveOfEratosthenes ( ) NEW_LINE st = constructST ( arr , n ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE updateValue ( arr , st , n , 1 , 10 ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE","3 ; Update : set arr [ 2 ] = 10 and update corresponding segment tree ; Print sum of values in array from index 1 to 3 ; Update : set arr [ 1 ] = 10 and update corresponding segment tree ; Print sum of values in array from index 1 to 3 [/INST] \n MAX = 10000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def getMid ( corner1 , corner2 ) : NEW_LINE INDENT if ( corner1 == corner2 ) : NEW_LINE INDENT return corner1 NEW_LINE DEDENT return ( corner1 + corner2 ) // 2 NEW_LINE DEDENT def getSumUtil ( node , corner1 , corner2 , arr , st ) : NEW_LINE INDENT if ( corner1 == corner2 ) : NEW_LINE INDENT return arr [ corner1 ] NEW_LINE DEDENT mid = getMid ( corner1 , corner2 ) NEW_LINE lsum = getSumUtil ( 2 * node , corner1 , mid , arr , st ) NEW_LINE rsum = getSumUtil ( 2 * node + 1 , mid + 1 , corner2 , arr , st ) NEW_LINE return lsum + rsum NEW_LINE DEDENT def updateUtil ( node , corner1 , corner2 , index , value , st ) : NEW_LINE INDENT if ( corner1 == corner2 ) : NEW_LINE INDENT if ( prime [ arr [ corner1 ] ] ) : NEW_LINE INDENT arr [ corner1 ] = value NEW_LINE if ( prime [ value ] ) : NEW_LINE INDENT st [ node ] = value NEW",0.2594943684545806,0.09416681573757708,0.1750494619942083,0.44390243902439025,0.3248587570621469
139,"mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( "" adc "" ) NEW_LINE A . append ( "" aec "" ) NEW_LINE A . append ( "" erg "" ) NEW_LINE S = "" ac "" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT","] NEW_LINE def countWays ( s , i , j , dp , n , m , index , pos , idx , s , t ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ i ] [ j ] [ pos ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ pos ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for k in range ( idx , m ) : NEW_LINE INDENT if ( s [ k ] == t [ j ] ) : NEW_LINE INDENT ans += countWays ( s , i + 1 , dp , n , m , k + 1 , pos + 1 , s , t ) NEW_LINE DEDENT DEDENT dp [ i ] [ j ] [ pos ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT def countWays ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE m = len ( t ) NEW_LINE dp = [ [ [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT idx = dp [ i ] [ j ] [ 0 ] NEW_LINE dp [ i ] [ j ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT return countWays ( s , t ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" abc "" NEW_",0.4176176934204103,0.3928939991767591,0.40135299828110593,0.33076923076923076,0.5454545454545454
140,"MAX = 10005 NEW_LINE MOD = 1000000007 NEW_LINE def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE DEDENT if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = ""98765432109876543210"" NEW_LINE len1 = len ( n ) NEW_LINE k = 58 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ] NEW_LINE num = process ( n ) NEW_LINE print ( countNum ( 0 , 0 , 0 , num , len1 , k ) ) NEW_LINE DEDENT","] \n import numpy as np NEW_LINE def count ( num , k ) : NEW_LINE INDENT dp = np . zeros ( ( len ( num ) + 1 , 10 ) ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( j < int ( num [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j < int ( num [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT new_tight = ( j % k == 0 ) NEW_LINE res = 0 NEW_LINE for t in range ( 10 ) : NEW_LINE INDENT res += dp [ i + 1 ] [ t ] NEW_LINE DEDENT res += new_tight NEW_LINE dp [ i + 1 ] [ j ] = res NEW_LINE DEDENT DEDENT return dp [ len ( num ) ] [ 0 ] NEW_LINE DEDENT def process ( n ) : NEW_LINE INDENT num = list ( n ) NEW_LINE num . reverse ( ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT num [ i ] = int ( num [ i ] ) NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = ""1000"" NEW_LINE k = 2 NEW_LINE num = process ( n ) NEW_LINE print ( count ( num , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW",0.39533884504323125,0.3391307169730858,0.34116031873926816,0.4230769230769231,0.4779874213836478
141,"def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE n = len ( arr ) NEW_LINE w1 , w2 = 10 , 3 NEW_LINE print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE DEDENT","[ j ] [ k ] = True if there exists a knapsack sequence of length i , whose total weight is j and whose total profit is k [/INDENT def KnapsackDP ( w1_r , w2_r , arr , i , n , w1 , w2 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( w1_r == 0 and w2_r == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT ans1 = False NEW_LINE ans2 = False NEW_LINE ans3 = False NEW_LINE if ( w1_r >= arr [ i - 1 ] [ 0 ] and w2_r >= arr [ i - 1 ] [ 1 ] ) : NEW_LINE INDENT if ( KnapsackDP ( w1_r - arr [ i - 1 ] [ 0 ] , w2_r - arr [ i - 1 ] [ 1 ] , arr , i - 1 , n , w1 , w2 ) ) : NEW_LINE INDENT ans1 = True NEW_LINE DEDENT DEDENT if ( w1_r >= arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT if ( KnapsackDP ( w1_r - arr [ i - 1 ] [ 0 ] , w2_r , arr , i - 1 , n , w1 , w2 ) ) : NEW_LINE INDENT ans2 = True NEW_LINE DEDENT DEDENT if ( w2_r >= arr [ i - 1 ] [ 1 ] ) : NEW_LINE INDENT if ( KnapsackDP ( w1_r , w2_r - arr [ i - 1 ] [ 1 ] , arr , i - 1 , n , w1 , w2 ) ) : NEW_LINE INDENT ans3 = True NEW_LINE DEDENT DEDENT if ( ans1 or ans2 or ans3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT arr = [ [ 10 , 20 ] , [ 30 , 30 ] ,",0.27428131538825384,0.19941462952077788,0.2317686030467303,0.08333333333333333,0.5826086956521739
142,"MAX = 105 NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def dfs ( i , j , k , q , n , m ) : NEW_LINE INDENT if ( mappedMatrix [ i ] [ j ] == 0 or i > n or j > m or mark [ i ] [ j ] or q != 0 ) : NEW_LINE INDENT return q ; NEW_LINE DEDENT mark [ i ] [ j ] = 1 ; NEW_LINE ans [ k ] = [ i , j ] NEW_LINE if ( i == n and j == m ) : NEW_LINE INDENT q = k ; NEW_LINE return q ; NEW_LINE DEDENT q = dfs ( i + 1 , j + 1 , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i + 1 , j , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i , j + 1 , k + 1 , q , n , m ) ; NEW_LINE return q NEW_LINE DEDENT def lexicographicalPath ( n , m ) : NEW_LINE INDENT q = 0 ; NEW_LINE global ans , mark NEW_LINE ans = [ [ 0 , 0 ] for i in range ( MAX ) ] NEW_LINE mark = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE q = dfs ( 1 , 1 , 1 , q , n , m ) ; NEW_LINE for i in range ( 1 , q + 1 ) : NEW_LINE INDENT print ( str ( ans [ i ] [ 0 ] ) + ' ▁ ' + str ( ans [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT def countPrimePath ( n , m ) : NEW_LINE INDENT global dp NEW_LINE dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( i == 1 and j == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; NEW_LINE if ( mappedMatrix [ i ] [ j ] == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ m ] ) NEW_LINE DEDENT def preprocessMatrix ( a , n , m ) : NEW_LINE INDENT global prime NEW_LINE prime = [ 0 for i in range ( MAX ) ] NEW_LINE sieve ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( prime [ a [ i ] [ j ] ] == 0 ) : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 2 , 3 , 7 ] , [ 5 , 4 , 2 ] , [ 3 , 7 , 11 ] ] ; NEW_LINE mappedMatrix = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE preprocessMatrix ( a , n , m ) ; NEW_LINE countPrimePath ( n , m ) ; NEW_LINE lexicographicalPath ( n , m ) ; NEW_LINE DEDENT","] from math import sqrt NEW_LINE def dfs ( m , n , x , y , visited , lex , step , path , k ) : NEW_LINE INDENT if ( x < 0 or y < 0 or x >= m or y >= n or visited [ x ] [ y ] or m [ x ] [ y ] == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ x ] [ y ] = True NEW_LINE lex [ x ] [ y ] = k NEW_LINE if ( x == m - 1 and y == n - 1 ) : NEW_LINE INDENT step [ k ] += 1 NEW_LINE return 1 NEW_LINE DEDENT if ( x + 1 < m and m [ x + 1 ] [ y ] != k and lex [ x + 1 ] [ y ] != k ) : NEW_LINE INDENT if ( dfs ( m , n , x + 1 , y , visited , lex , step , path , k ) ) : NEW_LINE INDENT path [ k ] = path [ k ] + 1 NEW_LINE return 1 NEW_LINE DEDENT DEDENT if ( y + 1 < n and m [ x ] [ y + 1 ] != k and lex [ x ] [ y + 1 ] != k ) : NEW_LINE INDENT if ( dfs ( m , n , x , y + 1 , visited , lex , step , path , k ) ) : NEW_LINE INDENT path [ k ] = path [ k ] + 1 NEW_LINE return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def lexicographicalLargestPrimePath ( m , n ) : NEW_LINE INDENT visited = [ [ False for i in range ( n ) ] for i in range ( m ) ] NEW_LINE lex = [ [ - 1 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE step = [ 0 for i in range ( n ) ] NEW_LINE path = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range",0.23169331535141063,0.12598234505891295,0.1742053514776546,0.4298642533936652,0.19672131147540983
143,"def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE count = [ [ 0 for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE count [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE count [ i ] [ 0 ] = - 1 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE count [ i ] [ j ] = count [ i ] [ j - 1 ] NEW_LINE if ( i >= arr [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE if ( subset [ i ] [ j ] ) : NEW_LINE INDENT count [ i ] [ j ] = ( max ( count [ i ] [ j - 1 ] , count [ i - arr [ j - 1 ] ] [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count [ sum ] [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 10 ] NEW_LINE sum = 20 NEW_LINE n = 4 NEW_LINE print ( isSubsetSum ( arr , n , sum ) ) NEW_LINE DEDENT","] \n def maxSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ 0 ] * ( sum + 1 ) for i in range ( n + 1 ) ] NEW_LINE subset [ 0 ] [ 0 ] = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT subset [ i ] [ j ] = True NEW_LINE DEDENT elif j == arr [ i ] : NEW_LINE INDENT subset [ i ] [ j ] = True NEW_LINE DEDENT elif subset [ i - 1 ] [ j ] : NEW_LINE INDENT subset [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if subset [ i ] [ j ] : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 9 NEW_LINE print ( maxSubsetSum ( arr , n , sum ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 12 NEW_LINE 5 NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE ",0.4564551686466765,0.42444441004492395,0.43423063347382107,0.472,0.49514563106796117
144,"MAX = 100 NEW_LINE lcslen = 0 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def lcs ( str1 , str2 , len1 , len2 , i , j ) : NEW_LINE INDENT if ( i == len1 or j == len2 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ret = 0 NEW_LINE if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ret NEW_LINE return ret NEW_LINE DEDENT def printAll ( str1 , str2 , len1 , len2 , data , indx1 , indx2 , currlcs ) : NEW_LINE INDENT if ( currlcs == lcslen ) : NEW_LINE INDENT print ( "" "" . join ( data [ : currlcs ] ) ) NEW_LINE return NEW_LINE DEDENT if ( indx1 == len1 or indx2 == len2 ) : NEW_LINE INDENT return NEW_LINE DEDENT for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT done = False NEW_LINE for i in range ( indx1 , len1 ) : NEW_LINE INDENT if ( chr ( ch ) == str1 [ i ] ) : NEW_LINE for j in range ( indx2 , len2 ) : NEW_LINE INDENT if ( chr ( ch ) == str2 [ j ] and dp [ i ] [ j ] == lcslen - currlcs ) : NEW_LINE data [ currlcs ] = chr ( ch ) NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) NEW_LINE done = True NEW_LINE break NEW_LINE DEDENT if ( done ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT def prinlAllLCSSorted ( str1 , str2 ) : NEW_LINE INDENT global lcslen NEW_LINE len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) NEW_LINE data = [ ' a ' for i in range ( MAX ) ] NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = "" abcabcaa "" NEW_LINE str2 = "" acbacba "" NEW_LINE prinlAllLCSSorted ( str1 , str2 ) NEW_LINE DEDENT","] NEW_LINE def lcs ( i , j , n , m , data , lcs , lcslen ) : NEW_LINE INDENT if ( i == n or j == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT return 1 + lcs ( i + 1 , j + 1 , n , m , data , lcslen ) NEW_LINE DEDENT return max ( lcs ( i + 1 , j , n , m , data , lcslen ) , lcs ( i , j + 1 , n , m , data , lcslen ) NEW_LINE DEDENT DEDENT def printLCS ( data , lcslen , lcs ) : NEW_LINE INDENT for i in range ( lcslen ) : NEW_LINE INDENT if ( data [ i ] == lcs ) : NEW_LINE INDENT print ( lcs , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def printLCS ( str1 , str2 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE m = len ( str2 ) NEW_LINE lcslen = 0 NEW_LINE dp = [ [ [ - 1 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE data = [ ' ' for i in range ( 26 ) ] NEW_LINE lcslen = lcs ( 0 , 0 , n , m , data , lcslen ) NEW_LINE printLCS ( data , lcslen , "" "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" AGGTAB "" NEW_LINE str2 = "" GXTXYB "" NEW_LINE printLCS ( str1 , str2 ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW",0.39013740899971383,0.2999167508993792,0.3477278109287242,0.5323741007194245,0.3805309734513274
145,"def isMajority ( arr , n , x ) : NEW_LINE INDENT last_index = ( n // 2 + 1 ) if n % 2 == 0 else ( n // 2 ) NEW_LINE for i in range ( last_index ) : NEW_LINE INDENT if arr [ i ] == x and arr [ i + n // 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( "" % ▁ d ▁ appears ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] "" % ( x , n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" % ▁ d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] "" % ( x , n // 2 ) ) NEW_LINE DEDENT","] \n def isMajority ( arr , n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT last = n // 2 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT last = ( n + 1 ) // 2 - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ last ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isMajority ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW",0.4111674993957458,0.2941026515132463,0.3666583978750743,0.3877551020408163,0.5961538461538461
146,"def _binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid == 0 or x > arr [ mid - 1 ] ) and ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif x > arr [ mid ] : NEW_LINE INDENT return _binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return _binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def isMajority ( arr , n , x ) : NEW_LINE INDENT i = _binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( i + n // 2 ) <= ( n - 1 ) ) and arr [ i + n // 2 ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT","] def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == x and ( ( mid == 0 or arr [ mid - 1 ] < x ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] < x ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT return binarySearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT 1 NEW_LINE def isMajority ( arr , n , x ) : NEW_LINE INDENT index = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( index > n // 3 ) NEW_LINE DEDENT 1 NEW_LINE arr = [ 1 , 2 , 2 , 2 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW",0.5794251694550465,0.38128296866663985,0.5656241902503472,0.43103448275862066,0.9397590361445783
147,"def isMajorityElement ( arr , n , key ) : NEW_LINE INDENT if ( arr [ n // 2 ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE if ( isMajorityElement ( arr , n , x ) ) : NEW_LINE INDENT print ( x , "" ▁ appears ▁ more ▁ than ▁ "" , n // 2 , "" ▁ times ▁ in ▁ arr [ ] "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , "" ▁ does ▁ not ▁ appear ▁ more ▁ than "" , n // 2 , "" ▁ times ▁ in ▁ arr [ ] "" ) NEW_LINE DEDENT DEDENT","] \n def isMajority ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isMajority ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE ",0.41586933723140945,0.26825647045341383,0.4202208784722239,0.4,0.575
148,"INT_MIN = - 32767 NEW_LINE def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( "" Maximum ▁ Obtainable ▁ Value ▁ is ▁ "" + str ( cutRod ( arr , size ) ) ) NEW_LINE","] def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 ] * ( n + 1 ) NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val [ i ] = - 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val [ i ] = max ( val [ i ] , price [ j - 1 ] + val [ i - j ] ) NEW_LINE DEDENT DEDENT return val [ n ] NEW_LINE DEDENT 1 NEW_LINE price = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 17 , 20 ] NEW_LINE n = 7 NEW_LINE print ( "" Maximum   price   is   "" , cutRod ( price , n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 5",0.34347700884695853,0.37672868052760383,0.6045714458398116,0.2830188679245283,0.1095890410958904
149,"def isPossible ( target ) : NEW_LINE INDENT max = 0 NEW_LINE index = 0 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if ( max < target [ i ] ) : NEW_LINE max = target [ i ] NEW_LINE index = i NEW_LINE DEDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if ( i != index ) : NEW_LINE max -= target [ i ] NEW_LINE if ( max <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT target [ index ] = max NEW_LINE return isPossible ( target ) NEW_LINE DEDENT target = [ 9 , 3 , 5 ] NEW_LINE res = isPossible ( target ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT","] def check ( arr , target , n , m ) : NEW_LINE INDENT max = - 1 NEW_LINE max_index = - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( target [ i ] > max ) : NEW_LINE INDENT max = target [ i ] NEW_LINE max_index = i NEW_LINE DEDENT DEDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( i != max_index and target [ i ] > max ) : NEW_LINE INDENT max = target [ i ] NEW_LINE DEDENT DEDENT if ( max <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != max ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE target = [ 1 , 2 , 3 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( target ) NEW_LINE if ( check ( arr , target , N , M ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE ",0.5247863228028237,0.3753944417431505,0.6531125515958037,0.5106382978723404,0.56
150,"def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 NEW_LINE print ( nCr ( n + m , k ) ) NEW_LINE DEDENT","] def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n / 2 ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def sumOfProducts ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT sum += binomialCoeff ( i , j ) * binomialCoeff ( n - i , k - j ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( sumOfProducts ( n , k ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_",0.4603396712493434,0.23776851737738824,0.5758123898422076,0.5277777777777778,0.5
151,"import math NEW_LINE def Is_possible ( N ) : NEW_LINE INDENT C = 0 NEW_LINE D = 0 NEW_LINE while ( N % 10 == 0 ) : NEW_LINE INDENT N = N / 10 NEW_LINE C += 1 NEW_LINE DEDENT if ( math . log ( N , 2 ) - int ( math . log ( N , 2 ) ) == 0 ) : NEW_LINE INDENT D = int ( math . log ( N , 2 ) ) NEW_LINE if ( C >= D ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT N = 2000000000000 NEW_LINE Is_possible ( N ) NEW_LINE","] \n import math NEW_LINE def canReached ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE while ( n % 100 == 0 ) : NEW_LINE INDENT n = int ( n / 100 ) NEW_LINE count += 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE return NEW_LINE DEDENT if ( math . log2 ( n ) % 1 == 0 ) : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE return NEW_LINE DEDENT print ( "" YES "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 1000 NEW_LINE canReached ( N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_",0.39657659932351685,0.252094799619842,0.4374454285199964,0.31343283582089554,0.5833333333333334
152,def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE,] \n def centralPolygonal ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) ) // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( centralPolygonal ( n ) ) NEW_LINE 1 NEW_LINE 6 NEW_LINE 15 NEW_LINE 28 NEW_LINE 45 NEW_LINE 66 NEW_LINE 91 NEW_LINE 120 NEW_LINE 153 NEW_LINE 190 NEW_LINE 231 NEW_LINE 276 NEW_LINE 325 NEW_LINE 378 NEW_LINE 435 NEW_LINE 496 NEW_LINE 561 NEW_LINE 630 NEW_LINE 703 NEW_LINE 780 NEW_LINE 861 NEW_LINE 946 NEW_LINE 1035 NEW_LINE 1128 NEW_LINE 1225 NEW_LINE 1326 NEW_LINE 1431 NEW_LINE 1540 NEW_LINE 1653 NEW_LINE 1770 NEW_LINE 1891 NEW_LINE 2016 NEW_LINE 2145 NEW_LINE 2278 NEW_LINE 2415 NEW_LINE 2556 NEW_LINE 2701 NEW_LINE 2850 NEW_LINE 3003 NEW_LINE 3160 NEW_LINE 3321 NEW_LINE 3486 NEW_LINE 3655 NEW_LINE 3828 NEW_LINE 4005 NEW_LINE 4186 NEW_LINE 4371 NEW_LINE 4559 NEW_LINE 4751 NEW_LINE 4947 NEW_LINE 5147 NEW_LINE 5351 NEW_LINE 5559 NEW_LINE 5771 NEW_LINE 5987 NEW_LINE 6207 NEW_LINE 6431 NEW_LINE 6659 NEW_LINE 6891 NEW_LINE 7127 NEW_,0.2483601518712077,0.06437958955057739,0.3695372084104438,0.14285714285714285,0.4166666666666667
153,"def printSeries ( n , a , b , c ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( a , end = "" ▁ "" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( a , b , end = "" ▁ "" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( a , b , c , end = "" ▁ "" ) ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = a + b + c ; NEW_LINE print ( d , end = "" ▁ "" ) ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE c = d ; NEW_LINE DEDENT DEDENT N = 7 ; a = 1 ; b = 3 ; NEW_LINE c = 4 ; NEW_LINE printSeries ( N , a , b , c ) ; NEW_LINE","] def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * ( i + 1 ) , end = ""   "" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE printSeries ( n ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 8 NEW_LINE 15 NEW_LINE 27 NEW_LINE 50 NEW_LINE 92 NEW_LINE 169 NEW_LINE 298 NEW_LINE 531 NEW_LINE 968 NEW_LINE 1776 NEW_LINE 3312 NEW_LINE 6355 NEW_LINE 12476 NEW_LINE 24577 NEW_LINE 49152 NEW_LINE 98304 NEW_LINE 196608 NEW_LINE 393216 NEW_LINE 786432 NEW_LINE 1572864 NEW_LINE 3145728 NEW_LINE 6291456 NEW_LINE 12582912 NEW_LINE 25165824 NEW_LINE 49327680 NEW_LINE 98655360 NEW_LINE 197310720 NEW_LINE 394621440 NEW_LINE 789242880 NEW_LINE 1578485760 NEW_LINE 3156971520 NEW_LINE 6313943040 NEW_LINE 12627886080 NEW_LINE 25255776160 NEW_LINE 49511546304 NEW_LINE 99023092640 NEW_LINE 198046185280 NEW_LINE 396092370560 NEW_LINE 792184741",0.13911337270703267,0.1505426739459795,0.15486039671408397,0.16176470588235295,0.08928571428571429
154,"def diameter ( n ) : NEW_LINE INDENT L , H , templen = 0 , 0 , 0 ; NEW_LINE L = 1 ; NEW_LINE H = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT while ( L * 2 <= n ) : NEW_LINE INDENT L *= 2 ; NEW_LINE H += 1 ; NEW_LINE DEDENT if ( n >= L * 2 - 1 ) : NEW_LINE INDENT return 2 * H + 1 ; NEW_LINE DEDENT elif ( n >= L + ( L / 2 ) - 1 ) : NEW_LINE INDENT return 2 * H ; NEW_LINE DEDENT return 2 * H - 1 ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( diameter ( n ) ) ; NEW_LINE","] def diameter ( L , H ) : NEW_LINE INDENT if ( L == 1 ) : NEW_LINE INDENT return H NEW_LINE DEDENT if ( H == 1 ) : NEW_LINE INDENT return L NEW_LINE DEDENT if ( H == 2 ) : NEW_LINE INDENT return L + 1 NEW_LINE DEDENT if ( H == 3 ) : NEW_LINE INDENT return 2 * L + 1 NEW_LINE DEDENT if ( H == 4 ) : NEW_LINE INDENT return 3 * L + 1 NEW_LINE DEDENT if ( H == 5 ) : NEW_LINE INDENT return 4 * L + 1 NEW_LINE DEDENT return diameter ( L >> 1 , H - 1 ) + diameter ( L >> 1 , H - 2 ) + 2 * ( L >> 1 ) NEW_LINE DEDENT N = 16 NEW_LINE print ( diameter ( N , 5 ) ) NEW_LINE 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 [/INST] 1 NEW_LINE 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 [/INST] 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 [/INST] 4 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 [/INST] 5 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 [/INST] 6 , 1 , 1 , 1",0.31042347482768784,0.17444712655866798,0.34371996725806464,0.2972972972972973,0.4262295081967213
155,"import math NEW_LINE def compareValues ( a , b , c , d ) : NEW_LINE INDENT log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE if num1 > num2 : NEW_LINE INDENT print ( a , ' ^ ' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , ' ^ ' , d ) NEW_LINE DEDENT DEDENT a = 8 NEW_LINE b = 29 NEW_LINE c = 60 NEW_LINE d = 59 NEW_LINE compareValues ( a , b , c , d ) NEW_LINE","] \n import math NEW_LINE def findLarger ( a , b , c , d ) : NEW_LINE INDENT a = math . pow ( a , b ) NEW_LINE c = math . pow ( c , d ) NEW_LINE ans = a * math . log ( a ) NEW_LINE ans2 = c * math . log ( c ) NEW_LINE if ( ans > ans2 ) : NEW_LINE INDENT print ( "" a ^ b   is   greater "" ) NEW_LINE DEDENT elif ( ans < ans2 ) : NEW_LINE INDENT print ( "" c ^ d   is   greater "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Both   are   equal "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 10 NEW_LINE d = 2 NEW_LINE findLarger ( a , b , c , d ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 10 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE ",0.46723750585544677,0.20272617865553275,0.4995571780995877,0.5,0.6666666666666666
156,"MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a // 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE","] NEW_LINE def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def isOddPrime ( num ) : NEW_LINE INDENT while ( num > 0 ) : NEW_LINE INDENT rem = num % 10 NEW_LINE if ( rem == 1 or rem == 3 or rem == 7 or rem == 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT return False NEW_LINE DEDENT def sumPrime ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True and isOddPrime ( i ) == False ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 1000 NEW_LINE print ( sumPrime ( n ) ) NEW_LINE DEDENT 1 , 2 , 3 , 5 , 7 , 9 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 ,",0.45275352463531016,0.43502823500791377,0.43938299271992964,0.5681818181818182,0.3684210526315789
157,"def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT","] def countPrimes ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def prefixSum ( arr , n ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix [ i + 1 ] = prefix [ i ] + arr [ i ] NEW_LINE DEDENT return prefix NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 3 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE prefix = prefixSum ( arr , n ) NEW_LINE print ( countPrimes ( prefix , n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW",0.5610656117855453,0.565363720624474,0.6732964856213485,0.47619047619047616,0.5294117647058824
158,"import math NEW_LINE def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT n = 10 ; x = 2 ; y = 40 NEW_LINE print ( minValue ( n , x , y ) ) NEW_LINE","] \n import math NEW_LINE def minValue ( n , x , y ) : NEW_LINE INDENT ans = ( ( 100 - y ) * n ) // 100 NEW_LINE ans += x NEW_LINE if ( ans >= y * n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10000 NEW_LINE x = 1000 NEW_LINE y = 25 NEW_LINE print ( minValue ( n , x , y ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65",0.44389123429473554,0.19174501760976867,0.5296403530057059,0.2647058823529412,0.7894736842105263
159,"from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] \n from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT if ( n == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 10 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_",0.6971057003972486,0.7175486511242163,0.8153185949092228,0.7777777777777778,0.4777777777777778
160,"n = 5 NEW_LINE fac1 = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE DEDENT fac2 = fac1 * n NEW_LINE totalWays = fac1 * fac2 NEW_LINE print ( totalWays ) NEW_LINE","] def findWays ( n ) : NEW_LINE INDENT fac1 = 1 NEW_LINE fac2 = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac1 *= i NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fac2 *= i NEW_LINE DEDENT print ( fac1 * fac2 // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE findWays ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66",0.30326389154986516,0.11610156975036862,0.5552873297824252,0.375,0.16666666666666666
161,"MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT","] = 10000000000 NEW_LINE def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT prime . append ( 2 ) NEW_LINE p = 3 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 2 NEW_LINE DEDENT DEDENT def isEuclid ( prime , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] and ( prime [ n - i ] ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "" No "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT prime = [ ] NEW_LINE n = 14 NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE isEuclid ( prime , n ) NEW_LINE n = 18 NEW_LINE isEuclid ( prime , n ) NEW_LINE DEDENT 1 : NEW_LINE INDENT INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 1 : NEW_LINE INDENT INDENT print ( "" Yes "" ) NEW_LINE DEDENT 1 : NEW_LINE INDENT INDENT print ( "" No "" ) NEW_LINE DEDENT 1 : NEW_LINE INDENT INDENT print ( "" Yes "" ) NEW_LINE DEDENT 1 : NEW_LINE INDENT INDENT print ( "" No "" ) NEW_LINE DEDENT 1 : NEW_LINE INDENT INDENT print ( "" Yes "" ) NEW_LINE DEDENT 1 : NEW_LINE INDENT INDENT print ( "" Yes "" ) NEW_LINE DEDENT 1 : NEW_LINE",0.4683632481882117,0.46202692001649626,0.49967519142025174,0.33783783783783783,0.5739130434782609
162,"from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT","] \n def nextCube ( n ) : NEW_LINE INDENT return ( int ( pow ( n , 1.5 ) + 1 ) * int ( pow ( n , 1.5 ) ) ) NEW_LINE DEDENT n = 5 NEW_LINE print ( nextCube ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 8 NEW_LINE 13 NEW_LINE 21 NEW_LINE 32 NEW_LINE 49 NEW_LINE 72 NEW_LINE 100 NEW_LINE 137 NEW_LINE 184 NEW_LINE 250 NEW_LINE 327 NEW_LINE 416 NEW_LINE 521 NEW_LINE 646 NEW_LINE 791 NEW_LINE 964 NEW_LINE 1169 NEW_LINE 1404 NEW_LINE 1681 NEW_LINE 2000 NEW_LINE 2361 NEW_LINE 2772 NEW_LINE 3232 NEW_LINE 3748 NEW_LINE 4328 NEW_LINE 5072 NEW_LINE 5984 NEW_LINE 6096 NEW_LINE 6396 NEW_LINE 6896 NEW_LINE 7596 NEW_LINE 8496 NEW_LINE 9596 NEW_LINE 10896 NEW_LINE 12396 NEW_LINE 14096 NEW_LINE 15996 NEW_LINE 18096 NEW_LINE 20496 NEW_LINE 23196 NEW_LINE 26196 NEW_LINE 29596 NEW_LINE 33396 NEW_LINE 37696 NEW_LINE 42496 NEW_LINE 47796 NEW_LINE 53596 NEW_LINE 59996 NEW_LINE 67996 NEW_LINE 77596 NEW_LINE 88896 NEW_LINE 101896 NEW_LINE 11689",0.21291987196410833,0.06955382327153395,0.18490344236267722,0.20833333333333334,0.3888888888888889
163,"import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE root_n = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root_n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( int ) ( n / i ) and isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT if ( isPrime ( ( int ) ( n / i ) ) ) : NEW_LINE INDENT Sum += ( int ) ( n / i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT n = 60 NEW_LINE print ( "" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is "" , SumOfPrimeDivisors ( n ) ) NEW_LINE","] \n import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def primeDivisorsSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT sum = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i == n ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += i NEW_LINE sum += n / i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT n = 12 NEW_LINE print ( primeDivisorsSum ( n ) ) NEW_LINE 2 NEW_LINE 12 NEW_LINE 14 NEW_LINE 20 NEW_LINE 16 NEW_LINE 30 NEW_LINE 42 NEW_LINE 60 NEW_LINE 46 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 11 NEW_LINE 13 NEW_LINE 17 NEW_LINE 19 NEW_LINE 23 NEW_LINE 29 NEW_LINE 31 NEW_LINE 37 NEW_LINE 41 NEW_LINE 43 NEW_LINE 47 NEW_",0.5767135652910409,0.5858124425958329,0.6116287510157282,0.6046511627906976,0.5047619047619047
164,"def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT n = ""777"" NEW_LINE print ( findpos ( n ) ) NEW_LINE",] def getPosition ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n % 10 == 2 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT if ( n % 10 == 3 ) : NEW_LINE INDENT pos += 2 NEW_LINE DEDENT if ( n % 10 == 5 ) : NEW_LINE INDENT pos += 3 NEW_LINE DEDENT if ( n % 10 == 7 ) : NEW_LINE INDENT pos += 4 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return pos NEW_LINE DEDENT n = 12357 NEW_LINE print ( getPosition ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 1 NEW_LINE 4 NEW_LINE 6 NEW_LINE 0 NEW_LINE 8 NEW_LINE 9 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE,0.3158626344793002,0.15394551493176903,0.3546030622011181,0.2549019607843137,0.5
165,"def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( "" ( "" , possibleA , "" , "" , possibleB , "" , "" , possibleC , "" ) ▁ is ▁ one ▁ such "" , "" possible ▁ triplet ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ Such ▁ Triplet ▁ exists ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE","] \n def check ( L , R ) : NEW_LINE INDENT if ( R - L + 1 < 3 ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT elif ( R - L + 1 == 3 ) : NEW_LINE INDENT print ( "" ( 2 , 3 , 4 )"" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" ( 2 k , 2 k + 1 , 2 k + 2 )"" ) NEW_LINE DEDENT DEDENT L = 2 NEW_LINE R = 10 NEW_LINE check ( L , R ) NEW_LINE L = 23 NEW_LINE R = 46 NEW_LINE check ( L , R ) NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 , 24 , 25 NEW_LINE 45 , 46 , 47 NEW_LINE 1 , 2 , 3 NEW_LINE 23 ,",0.3019704617843738,0.2174827896257209,0.2121958174528643,0.3142857142857143,0.4639175257731959
166,"mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE","] \n def digitNumber ( digit , n , digit_excluding ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT if ( digit_excluding == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return 8 NEW_LINE DEDENT DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT if ( digit_excluding == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return 8 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( digit_excluding == 0 ) : NEW_LINE INDENT return digitNumber ( digit , n - 1 , 9 ) * digitNumber ( digit , n / 2 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return digitNumber ( digit , n - 1 , 8 ) * digitNumber ( digit , n / 2 , 0 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 3 NEW_LINE digit = 10 NEW_LINE digit_excluding = 4 NEW_LINE print ( digitNumber ( digit , n , digit_excluding ) ) NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 3",0.4159373788368588,0.3003981752062046,0.42296932200501597,0.323943661971831,0.6164383561643836
167,"def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return isPrime ( rev ) NEW_LINE DEDENT n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT r = 0 NEW_LINE temp = n NEW_LINE while ( temp ) : NEW_LINE INDENT r = r * 10 + temp % 10 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( isPrime ( r ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 23 NEW_LINE if ( isEmirp ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW",0.6359136607359663,0.3979595255987853,0.645866879626083,0.6829268292682927,0.8169014084507042
168,"def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT radian = 5 NEW_LINE print ( "" degree ▁ = "" , ( Convert ( radian ) ) ) NEW_LINE",] def convertDegree ( radian ) : NEW_LINE INDENT degree = ( radian * 180 ) / 3.14159265 NEW_LINE return degree NEW_LINE DEDENT radian = 30 NEW_LINE print ( convertDegree ( radian ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 72 NEW_LINE 73 NEW_LINE 74,0.26671852441446037,0.08898861623572452,0.36677437031100585,0.16666666666666666,0.4444444444444444
169,"def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE rowmajorSum = sn ( n , an ) ; NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE","] def sum_of_first_n_term ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) ) // 2 ) NEW_LINE DEDENT def trace ( n , a , b ) : NEW_LINE INDENT row_major_sum = sum_of_first_n_term ( n ) NEW_LINE row_major_sum += sum_of_first_n_term ( n - 1 ) NEW_LINE column_major_sum = sum_of_first_n_term ( n ) NEW_LINE column_major_sum += sum_of_first_n_term ( n - 1 ) NEW_LINE return ( row_major_sum + column_major_sum ) NEW_LINE DEDENT n = 3 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( trace ( n , a , b ) ) NEW_LINE 1 , 4 , 7 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5 , 8 NEW_LINE 3 , 6 , 9 NEW_LINE 2 , 5",0.3036769841659311,0.13509150356661365,0.30621024001878655,0.26229508196721313,0.5111111111111111
170,"def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( "" Not ▁ possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE m = 4 NEW_LINE k = 1 NEW_LINE max_area ( n , m , k ) NEW_LINE","] \n def maxArea ( l , b , k ) : NEW_LINE INDENT if ( k <= l ) : NEW_LINE INDENT print ( ( k * ( k - 1 ) ) // 2 , end = ""   "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( k - l ) * ( k - l - 1 ) ) // 2 , end = ""   "" ) NEW_LINE DEDENT print ( l * b , end = ""   "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT l , b , k = 2 , 3 , 2 NEW_LINE maxArea ( l , b , k ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE ",0.302786248200784,0.1455762634705272,0.2580638560382618,0.42592592592592593,0.3815789473684211
171,def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT side = 4 NEW_LINE area = area_fun ( side ) NEW_LINE print ( area ) NEW_LINE,"] def area ( side ) : NEW_LINE INDENT return side * side NEW_LINE DEDENT side = 5 NEW_LINE print ( "" Area   of   square   is   = "" , area ( side ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 12 NEW_LINE 14 NEW_LINE 16 NEW_LINE 18 NEW_LINE 20 NEW_LINE 22 NEW_LINE 24 NEW_LINE 26 NEW_LINE 28 NEW_LINE 30 NEW_LINE 32 NEW_LINE 34 NEW_LINE 36 NEW_LINE 38 NEW_LINE 40 NEW_LINE 42 NEW_LINE 44 NEW_LINE 46 NEW_LINE 48 NEW_LINE 50 NEW_LINE 52 NEW_LINE 54 NEW_LINE 56 NEW_LINE 58 NEW_LINE 60 NEW_LINE 62 NEW_LINE 64 NEW_LINE 66 NEW_LINE 68 NEW_LINE 70 NEW_LINE 72 NEW_LINE 74 NEW_LINE 76 NEW_LINE 78 NEW_LINE 80 NEW_LINE 82 NEW_LINE 84 NEW_LINE 86 NEW_LINE 88 NEW_LINE 90 NEW_LINE 92 NEW_LINE 94 NEW_LINE 96 NEW_LINE 98 NEW_LINE 100 NEW_LINE 102 NEW_LINE 104 NEW_LINE 106 NEW_LINE 108 NEW_LINE 110 NEW_LINE 112 NEW_LINE 114 NEW_LINE 116 NEW_LINE 118 NEW_LINE 120 NEW_LINE 122 NEW_LINE 124 NEW_LINE 126 NEW_LINE 128 NEW_LINE 130 NEW_LINE 132 NEW_LINE 134 NEW_LINE 136 NEW_LINE 138 NEW_LINE 140 NEW_LINE 142 NEW_LINE 144 NEW_LINE 14",0.28441701147500054,0.07019796618936602,0.38889865113920763,0.42857142857142855,0.25
172,def countConsecutive ( N ) : NEW_LINE INDENT count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT N = 15 NEW_LINE print countConsecutive ( N ) NEW_LINE N = 10 NEW_LINE print countConsecutive ( N ) NEW_LINE,"] def countWays ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += N // ( 2 * i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 5 NEW_LINE print ( countWays ( N ) ) NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 72 NEW_LINE 73 NEW_LINE",0.17006897117290826,0.08759034894458118,0.16351886908038513,0.22916666666666666,0.2
173,"def isAutomorphic ( N ) : NEW_LINE INDENT sq = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N /= 10 NEW_LINE sq /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print "" Automorphic "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" Not ▁ Automorphic "" NEW_LINE DEDENT","] \n def isAutomorphic ( N ) : NEW_LINE INDENT square = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != square % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = N // 10 NEW_LINE square = square // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 16 NEW_LINE if ( isAutomorphic ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 6",0.47086418279775016,0.2626618993617606,0.6911245021589104,0.3142857142857143,0.6153846153846154
174,"def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ True ] * ( N + 5 ) ; NEW_LINE i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE","] \n def maxPrimeFactors ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT answer = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT n = 10 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_",0.2579035656802519,0.17286338263697845,0.23328349329549575,0.39655172413793105,0.2289156626506024
175,"def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def squareRoot ( n , p ) : NEW_LINE INDENT if ( p % 4 != 3 ) : NEW_LINE INDENT print ( "" Invalid ▁ Input "" ) NEW_LINE return NEW_LINE DEDENT n = n % p NEW_LINE x = power ( n , ( p + 1 ) // 4 , p ) NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "" Square ▁ root ▁ is ▁ "" , x ) NEW_LINE return NEW_LINE DEDENT x = p - x NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "" Square ▁ root ▁ is ▁ "" , x ) NEW_LINE return NEW_LINE DEDENT print ( "" Square ▁ root ▁ doesn ' t ▁ exist ▁ "" ) NEW_LINE DEDENT p = 7 NEW_LINE n = 2 NEW_LINE squareRoot ( n , p ) NEW_LINE","] def power ( x , y , p ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( x == 0 and y % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT temp = power ( x , y // 2 , p ) NEW_LINE temp = ( temp * temp ) % p NEW_LINE if ( y & 1 ) : NEW_LINE INDENT temp = ( x * temp ) % p NEW_LINE DEDENT return temp NEW_LINE DEDENT def isSquareRootExists ( n , p ) : NEW_LINE INDENT if ( p % 4 == 3 ) : NEW_LINE INDENT if ( power ( n , ( p + 1 ) // 4 , p ) % p == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( power ( n , ( p + 1 ) // 4 ) % p == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT return False NEW_LINE DEDENT n = 13 NEW_LINE p = 25 NEW_LINE if ( isSquareRootExists ( n , p ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE",0.48879578456029293,0.35803903447604496,0.4619083717552012,0.5967741935483871,0.5384615384615384
176,"import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def miillerTest ( d , n ) : NEW_LINE INDENT a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT k = 4 ; NEW_LINE print ( "" All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ "" ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT","DENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT x = p - 1 NEW_LINE DEDENT if ( x == p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def isProbablePrime ( n , k ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n > 1 NEW_LINE DEDENT d = 0 NEW_LINE while ( True ) : NEW_LINE INDENT d += 1 NEW_LINE if ( power ( 2 , d , n ) == n - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT a = randint ( 2 , n - 2 ) NEW_LINE x = power ( a , d , n ) NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT while ( power ( x , d , n ) != 1 ) : NEW_LINE INDENT if ( power ( x , d , n ) != n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d *= 2 NEW_LINE x = power ( x * x , d , n ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 1000 NEW_LINE print ( isProbablePrime ( n , 10 ) ) NEW_LINE 1 : NEW_LINE INDENT n = 101 NEW_LINE print ( isProbablePrime ( n , 10 ) ) NEW_LINE DEDENT",0.45017404191020005,0.5009289018636595,0.49869199695993643,0.3333333333333333,0.46774193548387094
177,def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE,] def maxLen ( x ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT res += 1 NEW_LINE x = ( x - 1 ) & x NEW_LINE DEDENT return res NEW_LINE DEDENT x = 12 NEW_LINE print ( maxLen ( x ) ) NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE ,0.24423668078466793,0.09187006103039749,0.3480396250712372,0.14814814814814814,0.3888888888888889
178,"def subtract ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT borrow = ( ~ x ) & y NEW_LINE x = x ^ y NEW_LINE y = borrow << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( "" x ▁ - ▁ y ▁ is "" , subtract ( x , y ) ) NEW_LINE","] \n def subtract ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE result = [ 0 ] * n NEW_LINE carry = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT borrow = ( ( y [ i ] if i < len ( y ) else 0 ) & ( ( 1 << ( i + 1 ) ) - 1 ) ) NEW_LINE result [ i ] = ( x [ i ] ^ borrow ) NEW_LINE carry = ( carry + ( x [ i ] & borrow ) ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT result [ i ] += carry NEW_LINE carry = 0 NEW_LINE DEDENT return result NEW_LINE DEDENT x = ""10101010"" NEW_LINE y = ""1110001"" NEW_LINE result = subtract ( x , y ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT print ( result [ i ] , end = "" "" ) NEW_LINE DEDENT 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW",0.22253393872069788,0.10177324514781481,0.3962807728256536,0.20689655172413793,0.18518518518518517
179,"def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( "" x ▁ - ▁ y ▁ is "" , subtract ( x , y ) ) NEW_LINE","] \n def subtract ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( b % 2 == 0 ) : NEW_LINE INDENT return subtract ( a + a , b // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return subtract ( a + a , ( b - 1 ) // 2 ) NEW_LINE DEDENT DEDENT a = 10 NEW_LINE b = 5 NEW_LINE print ( "" Result   = "" , subtract ( a , b ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE",0.4670681180236864,0.09954639253540726,0.3224102900856543,0.5263157894736842,0.92
180,"def addEdge ( v , x , y ) : NEW_LINE INDENT v [ x ] . append ( y ) NEW_LINE v [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( tree , temp , ancestor , u , parent , k ) : NEW_LINE INDENT temp . append ( u ) NEW_LINE for i in tree [ u ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( tree , temp , ancestor , i , u , k ) NEW_LINE DEDENT temp . pop ( ) NEW_LINE if ( len ( temp ) < k ) : NEW_LINE INDENT ancestor [ u ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ancestor [ u ] = temp [ len ( temp ) - k ] NEW_LINE DEDENT DEDENT def KthAncestor ( N , K , E , edges ) : NEW_LINE INDENT tree = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT temp = [ ] NEW_LINE ancestor = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( tree , temp , ancestor , 1 , 0 , K ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ancestor [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE K = 2 NEW_LINE E = 8 NEW_LINE edges = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 7 ] , [ 3 , 8 ] , [ 3 , 9 ] ] NEW_LINE KthAncestor ( N , K , E , edges ) NEW_LINE DEDENT","] def addEdge ( n , m , g , x , y ) : NEW_LINE INDENT g [ x ] . append ( y ) NEW_LINE g [ y ] . append ( x ) NEW_LINE DEDENT def findKthAncestor ( n , m , g , K ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( i ) NEW_LINE for j in g [ i ] : NEW_LINE INDENT if ( len ( v ) < K ) : NEW_LINE INDENT v . append ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v [ - 1 ] ) NEW_LINE DEDENT DEDENT ans [ i ] = v [ - 1 ] NEW_LINE DEDENT DEDENT def printAncestors ( n , m , g , ans ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 6 NEW_LINE K = 2 NEW_LINE m = 5 NEW_LINE g = [ [ ] for i in range ( n + 1 ) ] NEW_LINE addEdge ( n , m , g , 1 , 2 ) NEW_LINE addEdge ( n , m , g , 2 , 3 ) NEW_LINE addEdge ( n , m , g , 3 , 4 ) NEW_LINE addEdge ( n , m , g , 4 , 5 ) NEW_LINE addEdge ( n , m , g , 5 , 6 ) NEW_LINE addEdge ( n , m , g , 6 , 1 ) NEW_LINE ans = [ 0 for i in range ( n + 1 ) ] NEW_LINE findKthAncestor ( n , m , g , K ) NEW_LINE printAncestors ( n , m , g , ans ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4",0.4307564443909986,0.3686091514856721,0.37195252932851125,0.5306122448979592,0.45185185185185184
181,"def build ( sum , a , l , r , rt ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT sum [ rt ] = a [ l - 1 ] NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE build ( sum , a , l , m , rt << 1 ) NEW_LINE build ( sum , a , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT def pushDown ( sum , add , rt , ln , rn ) : NEW_LINE INDENT if ( add [ rt ] ) : NEW_LINE INDENT add [ rt << 1 ] += add [ rt ] NEW_LINE add [ rt << 1 1 ] += add [ rt ] NEW_LINE sum [ rt << 1 ] += add [ rt ] * ln NEW_LINE sum [ rt << 1 1 ] += add [ rt ] * rn NEW_LINE add [ rt ] = 0 NEW_LINE DEDENT DEDENT def update ( sum , add , L , R , C , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT sum [ rt ] += C * ( r - l + 1 ) NEW_LINE add [ rt ] += C NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE if ( L <= m ) : NEW_LINE INDENT update ( sum , add , L , R , C , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT DEDENT def queryy ( sum , add , L , R , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT return sum [ rt ] NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE ans = 0 NEW_LINE if ( L <= m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , m + 1 , r , ( rt << 1 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def sequenceMaintenance ( n , q , a , b , m ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE sum = [ 0 ] * ( 4 * n ) NEW_LINE add = [ 0 ] * ( 4 * n ) NEW_LINE ans = [ ] NEW_LINE build ( sum , a , 1 , n , 1 ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE pos = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( queryy ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) : NEW_LINE INDENT r = m - 1 NEW_LINE pos = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n - pos + 1 ) NEW_LINE update ( sum , add , pos , n , - m , 1 , n , 1 ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE Q = 3 NEW_LINE M = 1 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE query = [ 4 , 3 , 1 ] NEW_LINE sequenceMaintenance ( N , Q , arr , query , M ) NEW_LINE DEDENT","] def build ( arr , v , seg , node , l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT v [ node ] = arr [ l ] NEW_LINE return NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE build ( arr , v , seg , 2 * node , l , mid ) NEW_LINE build ( arr , v , seg , 2 * node + 1 , mid + 1 , r ) NEW_LINE v [ node ] = v [ 2 * node ] + v [ 2 * node + 1 ] NEW_LINE DEDENT def push ( v , seg , node , l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE push ( v , seg , 2 * node , l , mid ) NEW_LINE push ( v , seg , 2 * node + 1 , mid + 1 , r ) NEW_LINE v [ node ] = v [ 2 * node ] + v [ 2 * node + 1 ] NEW_LINE DEDENT def update ( v , seg , node , l , r , index , val ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT v [ node ] += val NEW_LINE return NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE push ( v , seg , node , l , r ) NEW_LINE if ( index <= mid ) : NEW_LINE INDENT update ( v , seg , 2 * node , l , mid , index , val ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( v , seg , 2 * node + 1 , mid + 1 , r , index , val ) NEW_LINE DEDENT v [ node ] = v [ 2 * node ] + v [ 2 * node + 1 ] NEW_LINE DEDENT def query ( v , seg , node , l , r , queryy ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return v [ node ] NEW_LINE DEDENT mid = ( l",0.2483126083402935,0.11868824395946337,0.16212832696784824,0.3142857142857143,0.39814814814814814
182,"import math NEW_LINE def hasCoprimePair ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( math . gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE arr = [ 6 , 9 , 15 ] NEW_LINE if ( hasCoprimePair ( arr , n ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT","] from math import gcd NEW_LINE def minArrayLength ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( minArrayLength ( arr , n ) ) : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 6 NEW_LINE 5 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE",0.6837857838652804,0.40205823917975353,0.7573273205237925,0.5757575757575758,1.0
183,"def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT n = 15 NEW_LINE print ( Numberofways ( n ) ) NEW_LINE","] def countWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT for b in range ( 1 , n + 1 ) : NEW_LINE INDENT for c in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( a + b > c and b + c > a and c + a > b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_",0.47039910568062404,0.24294994016976307,0.6171411062086471,0.3548387096774194,0.6666666666666666
184,"def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count // 2 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( N , arr ) NEW_LINE DEDENT","] def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE countPairs ( arr , n ) NEW_LINE DEDENT 2 NEW_LINE 5 NEW_LINE 6 NEW_LINE 4 NEW_LINE 3 NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 4 NEW_LINE 3 NEW_LINE 2 NEW_LINE 0 NEW_LINE 5 NEW_LINE 1 NEW_LINE 6 NEW_LINE 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 3 NEW_LINE 0 NEW_LINE 5 NEW_LINE 2 NEW_LINE 4 NEW_LINE 0 NEW_LINE 2 NEW_LINE 3 NEW_LINE 1 NEW_LINE 4 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE ",0.4223167933627931,0.2504663825235835,0.6263007909275888,0.3125,0.5
185,"def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE while y in S : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT","] \n def maxLen ( arr , n ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] = 1 NEW_LINE DEDENT maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hash : NEW_LINE INDENT if ( arr [ i ] + arr [ i - 1 ] in hash ) : NEW_LINE INDENT maxLen = max ( maxLen , hash [ arr [ i ] + arr [ i - 1 ] ] ) NEW_LINE DEDENT if ( arr [ i ] + arr [ i - 2 ] in hash ) : NEW_LINE INDENT maxLen = max ( maxLen , hash [ arr [ i ] + arr [ i - 2 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT arr = [ 3 , 10 , 10 , 11 , 12 , 13 , 14 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLen ( arr , n ) ) NEW_LINE 2 NEW_LINE 6 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE ",0.33164448560218535,0.1995957366374419,0.32162325733853914,0.3488372093023256,0.45652173913043476
186,"def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE","] def maxElements ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 9 NEW_LINE print ( maxElements ( arr , n , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE ",0.4460105279618358,0.3040251191939686,0.6957347151874564,0.5517241379310345,0.23255813953488372
187,"def num_candyTypes ( candies ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( candies ) ) : NEW_LINE INDENT s . add ( candies [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def distribute_candies ( candies ) : NEW_LINE INDENT allowed = len ( candies ) / 2 NEW_LINE types = num_candyTypes ( candies ) NEW_LINE if ( types < allowed ) : NEW_LINE INDENT print ( int ( types ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( allowed ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT candies = [ 4 , 4 , 5 , 5 , 3 , 3 ] NEW_LINE distribute_candies ( candies ) NEW_LINE DEDENT","] \n def findCandies ( arr , N ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def maxCandies ( arr , N ) : NEW_LINE INDENT candies = N // 2 NEW_LINE candy_types = findCandies ( arr , N ) NEW_LINE return min ( candies , candy_types ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( maxCandies ( arr , N ) ) NEW_LINE DEDENT 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2",0.3829396276589139,0.224160851438466,0.4162933113711026,0.391304347826087,0.5
188,"import math NEW_LINE def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT A = 6 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonals ( A , theta ) NEW_LINE print ( round ( ans [ 0 ] , 2 ) , round ( ans [ 1 ] , 2 ) ) NEW_LINE","] \n import math NEW_LINE def diagonalLength ( a , b , theta ) : NEW_LINE INDENT c = ( a * math . cos ( math . radians ( theta ) ) ) NEW_LINE d = ( a * math . sin ( math . radians ( theta ) ) ) NEW_LINE print ( "" Diagonal  1   =   "" , int ( math . sqrt ( c * c + d * d ) ) ) NEW_LINE print ( "" Diagonal  2   =   "" , int ( math . sqrt ( ( a * a ) - ( c * c ) ) ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 5 NEW_LINE b = 6 NEW_LINE theta = 45 NEW_LINE diagonalLength ( a , b , theta ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW",0.5121252733829602,0.21528848474248818,0.46782799340473746,0.36538461538461536,0.0
189,"def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT y = bin ( K ) . count ( '1' ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT print ( "" Even ▁ = "" , odd , "" , ▁ Odd ▁ = "" , even ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Even ▁ = "" , even , "" , ▁ Odd ▁ = "" , odd ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE countEvenOdd ( arr , n , K ) ; NEW_LINE DEDENT","] def countEvenOdd ( arr , n , k ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) [ 2 : ] NEW_LINE y = len ( x ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT y = bin ( k ) [ 2 : ] NEW_LINE y = len ( y ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT even = odd NEW_LINE odd = even NEW_LINE DEDENT print ( "" Even   =   "" , even , "" Odd   =   "" , odd ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 12 NEW_LINE countEvenOdd ( arr , n , k ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 12 NEW_LINE Even = 2 Odd = 3 [/INST] 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 12 NEW_LINE 12 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 12 NEW_LINE 12 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 12 NEW_LINE 12 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 12 NEW_LINE 12 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 12 NEW_LINE 12 NEW_LINE",0.39312010751242343,0.38307056187814226,0.5176149963766796,0.5692307692307692,0.10256410256410256
190,N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE,] \n def countPairs ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43 NEW_LINE 44 NEW_LINE 45 NEW_LINE 46 NEW_LINE 47 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW_LINE 57 NEW_LINE 58 NEW_LINE 59 NEW_LINE 60 NEW_LINE 61 NEW_LINE 62 NEW_LINE 63 NEW_LINE 64 NEW_LINE 65 NEW_LINE 66 NEW_LINE 67 NEW_LINE 68 NEW_LINE 69 NEW_LINE 70 NEW_LINE 71 NEW_LINE 72 NEW_LINE 73 NEW_LINE 74 NEW_LINE 75 NEW_LINE 76 NEW_LINE 77 NEW_LINE 78 NEW_LINE,0.159420411932075,0.010444526686915865,0.0887755825798457,0.23076923076923078,0.3076923076923077
191,"import sys NEW_LINE def longestSubSequence ( A , N , ind = 0 , lastf = - sys . maxsize - 1 , lasts = sys . maxsize ) : NEW_LINE INDENT if ( ind == N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) NEW_LINE if ( A [ ind ] [ 0 ] > lastf and A [ ind ] [ 1 ] < lasts ) : NEW_LINE INDENT ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT / * Function * / NEW_LINE public static int longestSubSequence ( int [ , ] A , int N ) NEW_LINE { return longestSubSequence ( A , N , 0 , 0 , 0 ) ; } NEW_LINE if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE print ( longestSubSequence ( A , N ) ) NEW_LINE DEDENT","] \n import sys NEW_LINE def lcs ( a , i , j , n , dp ) : NEW_LINE INDENT if ( i == n or j == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT notIncl = lcs ( a , i + 1 , j , n , dp ) NEW_LINE incl = lcs ( a , i , j - 1 , n , dp ) + 1 NEW_LINE dp [ i ] [ j ] = max ( incl , notIncl ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 2 ] , [ 2 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] ] NEW_LINE n = len ( arr ) NEW_LINE dp = [ [ - 1 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE print ( lcs ( arr , 0 , n - 1 , n , dp ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2",0.3708918340651305,0.19502992254550788,0.2737370242310804,0.36923076923076925,0.6455696202531646
192,"def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 2 , 1 , 3 ] ; NEW_LINE print ( countTriplets ( A ) ) ; NEW_LINE DEDENT","] def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT a = A [ i ] & A [ j ] NEW_LINE if a in mp : NEW_LINE INDENT mp [ a ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT a = A [ i ] & A [ j ] NEW_LINE if a == 0 : NEW_LINE INDENT cnt += mp [ a ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( countTriplets ( A , N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 0 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 0 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 0 NEW_LINE 2 NEW_LINE 3 NEW_LINE ",0.3868183367757754,0.2131450478739727,0.4066906575057727,0.24489795918367346,0.6825396825396826
193,"def CountWays ( n ) : NEW_LINE INDENT noOfWays = [ 0 ] * ( n + 3 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] NEW_LINE DEDENT return noOfWays [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT","] \n def countWays ( n ) : NEW_LINE INDENT noOfWays = [ 0 ] * ( n + 2 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 2 NEW_LINE noOfWays [ 2 ] = 3 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT noOfWays [ i ] = ( noOfWays [ i - 1 ] + noOfWays [ i - 2 ] ) NEW_LINE DEDENT return noOfWays [ n ] NEW_LINE DEDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE 3 NEW_LINE 5 NEW_LINE 10 NEW_LINE 20 NEW_LINE 30 NEW_LINE 40 NEW_LINE 50 NEW_LINE 60 NEW_LINE 70 NEW_LINE 80 NEW_LINE 90 NEW_LINE 100 NEW_LINE 110 NEW_LINE 120 NEW_LINE 130 NEW_LINE 140 NEW_LINE 150 NEW_LINE 160 NEW_LINE 170 NEW_LINE 180 NEW_LINE 190 NEW_LINE 200 NEW_LINE 210 NEW_LINE 220 NEW_LINE 230 NEW_LINE 240 NEW_LINE 250 NEW_LINE 260 NEW_LINE 270 NEW_LINE 280 NEW_LINE 290 NEW_LINE 300 NEW_LINE 310 NEW_LINE 320 NEW_LINE 330 NEW_LINE 340 NEW_LINE 350 NEW_LINE 360 NEW_LINE 370 NEW_LINE 380 NEW_LINE 390 NEW_LINE 400 NEW_LINE 410 NEW_LINE 420 NEW_LINE 430 NEW_LINE 440 NEW_LINE 450 NEW_LINE 460 NEW_LINE 470 NEW_LINE 480 NEW_LINE 4",0.5031859925837305,0.3785614332946395,0.6882365910943365,0.6756756756756757,0.2702702702702703
194,"import sys NEW_LINE def findWinner ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT c = 0 NEW_LINE DEDENT DEDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE return NEW_LINE DEDENT if ( len ( v ) == 1 ) : NEW_LINE INDENT if ( ( v [ 0 ] & 1 ) != 0 ) : NEW_LINE INDENT print ( "" Player ▁ A "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE DEDENT return NEW_LINE DEDENT first = sys . minsize NEW_LINE second = sys . minsize NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT DEDENT if ( ( ( first & 1 ) != 0 ) and ( first + 1 ) // 2 > second ) : NEW_LINE INDENT print ( "" Player ▁ A "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE DEDENT DEDENT S = ""1100011"" NEW_LINE N = len ( S ) NEW_LINE findWinner ( S , N ) NEW_LINE","] \n import sys NEW_LINE def playerA ( s , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( "" Player   A "" ) NEW_LINE DEDENT elif ( len ( v ) == 1 ) : NEW_LINE INDENT print ( "" Player   B "" ) NEW_LINE DEDENT else : NEW_LINE INDENT first = - sys . maxsize - 1 NEW_LINE second = - sys . maxsize - 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = v [ i ] NEW_LINE DEDENT elif ( v [ i ] > second ) : NEW_LINE INDENT second = v [ i ] NEW_LINE DEDENT DEDENT if ( first - second == 1 ) : NEW_LINE INDENT print ( "" Player   A "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Player   B "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = ""00110000110000000011000011000000001100001100000000110000110000000011000011000000001100001100000000110000110000000011000011000000001100001100",0.4866357521372968,0.4696747990958517,0.5056206461005089,0.5175438596491229,0.4537037037037037
195,"def can_Construct ( S , K ) : NEW_LINE INDENT m = dict ( ) NEW_LINE p = 0 NEW_LINE if ( len ( S ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in S : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT if ( K > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for h in m : NEW_LINE INDENT if ( m [ h ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if ( K < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" annabelle "" NEW_LINE K = 4 NEW_LINE if ( can_Construct ( S , K ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] def isKpalindrome ( S , k ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] in mp : NEW_LINE INDENT mp [ S [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ S [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( k == len ( S ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( k > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT odd = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( k < odd ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT S = "" abab "" NEW_LINE k = 2 NEW_LINE if ( isKpalindrome ( S , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38",0.5286249165850475,0.3586914954017202,0.5231037684227468,0.5660377358490566,0.6666666666666666
196,"def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . lower ( ) ; NEW_LINE str2 = str2 . lower ( ) ; NEW_LINE x = str1 == str2 ; NEW_LINE return x ; NEW_LINE DEDENT def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( "" Same "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Same "" ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" Geeks "" ; NEW_LINE str2 = "" geeks "" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = "" Geek "" ; NEW_LINE str2 = "" geeksforgeeks "" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT","] def compare ( s1 , s2 ) : NEW_LINE INDENT s1 = s1 . lower ( ) NEW_LINE s2 = s2 . lower ( ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def printSameOrNot ( s1 , s2 ) : NEW_LINE INDENT if ( compare ( s1 , s2 ) ) : NEW_LINE INDENT print ( "" Same "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not   same "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s1 = "" Geeks "" NEW_LINE s2 = "" geeks "" NEW_LINE printSameOrNot ( s1 , s2 ) NEW_LINE DEDENT 2 NEW_LINE DEDENT 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2",0.424130569617597,0.21984454568691164,0.36052388662963003,0.5961538461538461,0.52
197,"import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( "" * "" , end = "" "" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = "" GeeksForGeeks "" NEW_LINE print ( "" String : ▁ "" , string ) NEW_LINE print ( "" Max ▁ Length ▁ of ▁ Steps : ▁ "" , n ) NEW_LINE steps ( string , n ) NEW_LINE","] \n def printSteps ( s , n ) : NEW_LINE INDENT x = 0 NEW_LINE flag = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' x ' ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT x = n NEW_LINE DEDENT elif ( x == n - 1 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT DEDENT print ( x * s [ i ] , end = "" "" ) NEW_LINE DEDENT DEDENT s = ""10101010"" NEW_LINE n = 5 NEW_LINE printSteps ( s , n ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE 0",0.37993216209391645,0.24536589559892716,0.3499183083322942,0.48,0.4444444444444444
198,"def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT a = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE","] \n def countFrequencies ( arr , n ) : NEW_LINE INDENT visited = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT count = 1 NEW_LINE j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE count += 1 NEW_LINE DEDENT print ( arr [ i ] , ""   "" , count ) NEW_LINE visited [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE countFrequencies ( arr , n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 5 NEW_LINE 5 NEW_LINE 5 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 2",0.33836932082532023,0.2665081977304588,0.5292767778785145,0.3076923076923077,0.25
199,"def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT str1 = ""10101100"" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT str2 = ""111010100"" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def checkDivisible ( binary , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT binary = ""101000"" NEW_LINE k = 3 NEW_LINE if ( checkDivisible ( binary , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT binary = ""1101100"" NEW_LINE k = 4 NEW_LINE if ( checkDivisible ( binary , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 38 NEW_LINE 39 NEW_LINE 40 NEW_LINE 41 NEW_LINE 42 NEW_LINE 43",0.5648788494616139,0.3665529490690488,0.6231211789361369,0.5555555555555556,0.7142857142857143
