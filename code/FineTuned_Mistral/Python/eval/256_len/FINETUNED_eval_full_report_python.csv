,value,value,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
0,"def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( ' inf ' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE","] def minSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for it in mp : NEW_LINE INDENT sum += it * mp [ it ] NEW_LINE DEDENT ans = sum NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT ans -= ( it * ( mp [ it ] - 1 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 4 , 5 , 5 , 5 , 5 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE 1 NEW_",0.511213679426534,0.5577362577961092,0.6746184599100267,0.4791666666666667,0.3333333333333333
1,"def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE maxi = - 1 * float ( ' inf ' ) NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE prev = arr [ j ] NEW_LINE DEDENT res . append ( maxi ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE","] def maxAdjacentDiff ( arr , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_diff = - 10 ** 9 NEW_LINE prev = - 10 ** 9 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT max_diff = max ( max_diff , arr [ j ] - arr [ i ] ) NEW_LINE prev = max ( prev , arr [ j ] ) NEW_LINE DEDENT ans . append ( max_diff ) NEW_LINE arr [ i ] = prev NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacentDiff ( arr , N ) NEW_LINE DEDENT 1 NEW_LINE 2",0.30829838831621004,0.3902249913942121,0.4083280389948111,0.3235294117647059,0.1111111111111111
2,"def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( CountOnes ( N , L , R ) ) NEW_LINE DEDENT","] def findSize ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return findSize ( N // 2 ) + findSize ( N // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findSize ( N // 2 ) + 1 + findSize ( N // 2 ) NEW_LINE DEDENT DEDENT def countOnes ( arr , N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT Siz_M = findSize ( N ) NEW_LINE if ( R > Siz_M ) : NEW_LINE INDENT R = Siz_M NEW_LINE DEDENT L -= Siz_M + 1 NEW_LINE if ( L < 1 ) : NEW_LINE INDENT L = 1 NEW_LINE DEDENT return ( ( R - L + 1 ) * arr [ L",0.4316380464131966,0.3440830174043403,0.3881834539627317,0.4142857142857143,0.58
3,"def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 4 NEW_LINE minDivisior ( N ) NEW_LINE","W_LINE INDENT def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPair ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) == False ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n // i NEW_LINE b = n // i * ( n - 1 ) NEW_LINE print ( a , b ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 10 NEW_LINE findPair ( n ) NEW_LINE",0.5881257563720077,0.5781985224418745,0.5813545958105347,0.5306122448979592,0.6623376623376623
4,"import sys NEW_LINE Landau = - sys . maxsize - 1 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT N = 4 NEW_LINE Landau_function ( N ) NEW_LINE","] NEW_LINE max_lcm = 0 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def max_lcm ( n ) : NEW_LINE INDENT global max_lcm NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i * i > n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT max_lcm = max ( max_lcm , lcm ( i , n // i ) ) NEW_LINE DEDENT DEDENT return max_lcm NEW_LINE DEDENT def find_representation ( n , sum , prev ,",0.37736464341899734,0.34919431372956977,0.40109128382527803,0.3235294117647059,0.43564356435643564
5,"def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE DEDENT def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT","] \n def isPrime ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( N ** 0.5 ) + 1 , 6 ) : NEW_LINE INDENT if ( N % i == 0 or N % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( N ) : NEW_LINE INDENT if ( isPrime ( N - 1 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _",0.6475478791717169,0.5629024791516942,0.5772890375351734,0.6346153846153846,0.8153846153846154
6,"def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] \n def splitArray ( arr , n , k ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE if ( splitArray ( arr , n , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE ",0.648995227927539,0.7099837090692404,0.7297707875465765,0.39622641509433965,0.76
7,"from math import * NEW_LINE def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT","] from collections import defaultdict NEW_LINE def sumOfDivision ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT maxi = 0 NEW_LINE for it in mp : NEW_LINE INDENT maxi = max ( maxi , mp [ it ] ) NEW_LINE DEDENT freq = [ 0 ] * ( maxi + 1 ) NEW_LINE for it in mp : NEW_LINE INDENT freq [ mp [ it ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT ans += ( ( i * freq [ i ] ) * ( i + 1 ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW",0.24719137169875688,0.21518690386676442,0.2587044410518329,0.30434782608695654,0.21052631578947367
8,"def insert_element ( a , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE print ( 2 ) NEW_LINE print ( num1 , num2 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT","] \n def minimumInsertions ( arr , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= arr [ i ] NEW_LINE Sum += arr [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( Sum > 2 * Xor ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum - 2 * Xor ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( Xor ) NEW_LINE print ( Sum + Xor ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE minimumInsertions ( arr , N ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE ",0.7022919691031482,0.6077736270257952,0.6420722154884924,0.559322033898305,0.0
9,"def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE","] \n def checkRoots ( a , b , c ) : NEW_LINE INDENT if ( a != 0 ) : NEW_LINE INDENT D = b * b - 4 * a * c NEW_LINE if ( D > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( D == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE if ( checkRoots ( a , b , c ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE ",0.5208838537395248,0.29465594682279606,0.6403383540769478,0.3793103448275862,0.7692307692307693
10,"from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE checkSunnyNumber ( N ) NEW_LINE DEDENT","] NEW_LINE import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr * sr == x ) ) NEW_LINE DEDENT def isSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE if ( isSunnyNumber ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE ",0.6892789136021396,0.57167157291255,0.7736375381105174,0.6486486486486487,0.7631578947368421
11,"def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT","] \n def countNumbers ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i - 1 ) % n == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 3 NEW_LINE print ( countNumbers ( N ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 5 NEW_LINE 7 NEW_LINE 8 NEW_LINE 10 NEW_LINE 15 NEW_LINE 20 NEW_LINE 30 NEW_LINE 100 NEW_LINE 1000 NEW_LINE 10000 NEW_LINE 100000 NEW_LINE 1000000 NEW_LINE 10000000 NEW_LINE 100000000 NEW_LINE ",0.43491064161259174,0.40744479935911815,0.4110212965030136,0.4411764705882353,0.48
12,"def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT","] \n def printNumbers ( N , K ) : NEW_LINE INDENT for i in range ( 1 , K ) : NEW_LINE INDENT print ( i , end = ""   "" ) NEW_LINE DEDENT print ( N - K + 1 , end = ""   "" ) NEW_LINE DEDENT N = 10 NEW_LINE K = 4 NEW_LINE printNumbers ( N , K ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3",0.33930941340222803,0.29112995772953953,0.47380000357168034,0.4,0.19230769230769232
13,"def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE DEDENT",] def getNthSteppingNumber ( N ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( 1 ) NEW_LINE q . append ( 2 ) NEW_LINE q . append ( 3 ) NEW_LINE q . append ( 4 ) NEW_LINE q . append ( 5 ) NEW_LINE q . append ( 6 ) NEW_LINE q . append ( 7 ) NEW_LINE q . append ( 8 ) NEW_LINE q . append ( 9 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT x = q [ 0 ] NEW_LINE del q [ 0 ] NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT if ( x % 10 != 9 ) : NEW_LINE INDENT q . append ( 10 * x + ( x % 10 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( 10 * x + ( x % 10 ) - 1 ) NEW_LINE DEDENT DEDENT,0.40802079492622834,0.38133997659361285,0.3803728327409303,0.37037037037037035,0.5
14,"from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT","] \n import math NEW_LINE def getNearest ( N ) : NEW_LINE INDENT x = math . sqrt ( N ) NEW_LINE x = math . floor ( x ) NEW_LINE x = math . pow ( x , 2 ) NEW_LINE y = math . ceil ( x ) NEW_LINE y = math . pow ( y , 2 ) NEW_LINE if ( abs ( N - x ) < abs ( N - y ) ) : NEW_LINE INDENT return ( N - x ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( y - N ) NEW_LINE DEDENT DEDENT N = 15 NEW_LINE print ( getNearest ( N ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW",0.1519735684061275,0.05551306909361591,0.06197716412685368,0.4722222222222222,0.01818181818181818
15,"from math import acos NEW_LINE def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 43 ; NEW_LINE printValueOfPi ( N ) ; NEW_LINE DEDENT",", 0.5 ] NEW_LINE def pi_value ( N ) : NEW_LINE INDENT pi = 4 * ( 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798096734694 ) NEW_LINE print ( pi ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 50 NEW_LINE pi_value ( N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW",0.25160851689432184,0.2959320158784407,0.2950866362834311,0.3783783783783784,0.037037037037037035
16,"import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE","] \n from math import log2 NEW_LINE def binary ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a . append ( n % 2 ) NEW_LINE n //= 2 NEW_LINE DEDENT return a NEW_LINE DEDENT def decimal ( arr ) : NEW_LINE INDENT n = 0 NEW_LINE for i in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT n += arr [ i ] * pow ( 2 , len ( arr ) - i - 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT def concatenate ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE a = binary ( a ) NEW_LINE b = binary ( b ) NEW_LINE if ( n < k ) : NEW_LINE INDENT a . append ( 0 ) NEW_LINE for i in range ( k - n ) : NEW_LINE INDENT a",0.3760918941740226,0.2886111545834907,0.3054929247844257,0.35802469135802467,0.5522388059701493
17,"MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE","] \n MAX = 100000 NEW_LINE res = [ 0 ] * MAX NEW_LINE def precompute ( ) : NEW_LINE INDENT res [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * i NEW_LINE DEDENT DEDENT def performQueries ( n ) : NEW_LINE INDENT precompute ( ) NEW_LINE q = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 2 ] , [ 4 , 3 ] ] NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT print ( res [ q [ i ] [ 1 ] ] // res [ q [ i ] [ 0 ] ] ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE performQueries ( n ) NEW_LINE 1 , 2 NEW_LINE 2 , 2 NEW_LINE 3 , 2 NEW_LINE 4 , 3 NEW_LINE 5 ,",0.3008125758651641,0.35043004834802954,0.35282025511262705,0.34615384615384615,0.15384615384615385
18,"import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE","] \n from math import gcd NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def countDivisibles ( a , b , c , num ) : NEW_LINE INDENT return ( ( num // a ) + ( num // b ) + ( num // c ) - ( num // gcd ( a , b ) ) - ( num // gcd ( b , c ) ) - ( num // gcd ( a , c ) ) ) NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 NEW_LINE high = 10 ** 18 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( countDivisibles ( a , b , c , mid ) < n ) : NEW_LINE INDENT",0.4249288566250388,0.35220196883902355,0.41362916014047063,0.3884297520661157,0.5454545454545454
19,"def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE","] \n def checkAngle ( n , i , j , k ) : NEW_LINE INDENT x = abs ( j - i ) NEW_LINE y = abs ( k - j ) NEW_LINE if ( x >= n or y >= n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x > y ) : NEW_LINE INDENT angle = ( 360 * x ) / n NEW_LINE DEDENT else : NEW_LINE INDENT angle = ( 360 * y ) / n NEW_LINE DEDENT if ( angle >= 180 ) : NEW_LINE INDENT angle = 360 - angle NEW_LINE DEDENT if ( angle >= 180 - ( 180 / 360 ) * ( j - i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 10 NEW_LINE i = 2 NEW_LINE j = 4 NEW_LINE k = 7 NEW_LINE if ( checkAngle ( n",0.3614643170658255,0.29090930315463687,0.3261395186531598,0.43137254901960786,0.3974358974358974
20,"def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( "" Loss ▁ = "" , round ( loss , 3 ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT","] def findLoss ( x , y ) : NEW_LINE INDENT return x - y NEW_LINE DEDENT x = 50 NEW_LINE y = 40 NEW_LINE print ( findLoss ( x , y ) ) NEW_LINE 2 NEW_LINE 5 NEW_LINE 10 NEW_LINE 15 NEW_LINE 20 NEW_LINE 25 NEW_LINE 30 NEW_LINE 35 NEW_LINE 40 NEW_LINE 45 NEW_LINE 50 NEW_LINE 55 NEW_LINE 60 NEW_LINE 65 NEW_LINE 70 NEW_LINE 75 NEW_LINE 80 NEW_LINE 85 NEW_LINE 90 NEW_LINE 95 NEW_LINE 100 NEW_LINE 105 NEW_LINE 110 NEW_LINE 115 NEW_LINE 120 NEW_LINE 125 NEW_LINE 130 NEW_LINE 135 NEW_LINE 140 NEW_LINE 145 NEW_LINE ",0.12592881508234932,0.0591613946685204,0.06793048903750032,0.09090909090909091,0.2857142857142857
21,"MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","NEW_LINE MAXN = 100000 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE hash = { } NEW_LINE def Sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN + 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN + 1 , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN + 1 , 2 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN + 1 , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def storePrimeFactors ( ) : NEW_",0.20623781797675717,0.14130451094773086,0.263268893213009,0.22807017543859648,0.19230769230769232
22,"def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT",] \n def noOfWays ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE ans *= ( 2 * n - 1 ) NEW_LINE ans *= ( 2 * n - 3 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( noOfWays ( n ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 6 NEW_LINE 10 NEW_LINE 15 NEW_LINE 21 NEW_LINE 28 NEW_LINE 36 NEW_LINE 45 NEW_LINE 55 NEW_LINE 66 NEW_LINE 78 NEW_LINE 91 NEW_LINE 105 NEW_LINE 120 NEW_LINE 136 NEW_LINE 153 NEW_LINE 171 NEW_LINE 190 NEW_LINE 210 NEW_LINE 231 NEW_LINE 253 NEW_LINE 276 NEW_LINE 300,0.3080355482115209,0.23758406239641786,0.3531788201048381,0.2413793103448276,0.4
23,"l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE","] \n N = 10 NEW_LINE mat = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE mat [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT mat [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i - 1 ] [ j - 1 ] + mat [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return mat [ n ] [ r ] NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE 1 NEW_LINE ",0.4791020807554893,0.6073908071482398,0.7092265022896003,0.4482758620689655,0.15151515151515152
24,"def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT",] def minDiff ( n ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT n = 10 NEW_LINE print ( minDiff ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_,0.19065210361212837,0.12481129489788402,0.18830217005567995,0.2222222222222222,0.22727272727272727
25,"def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def check ( n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last = n % 10 NEW_LINE count [ last ] += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT n = 123 NEW_LINE check ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE ",0.48616362549086084,0.4795095240343545,0.5276449779290889,0.4375,0.5
26,"def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT","] \n def printNlines ( K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( i + 1 , end = ""   "" ) NEW_LINE print ( i + 2 , end = ""   "" ) NEW_LINE print ( i + 3 , end = ""   "" ) NEW_LINE print ( i + 4 , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 1 NEW_LINE printNlines ( K ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE",0.3605196691613717,0.226063376058751,0.33170157509653964,0.11764705882352941,0.7666666666666667
27,"def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( "" Sum ▁ = "" , calculateSum ( n ) ) NEW_LINE","] \n def sumOfSeries ( n ) : NEW_LINE INDENT return ( n * ( 4 * n * n + 6 * n - 1 ) ) / 3 NEW_LINE DEDENT n = 5 NEW_LINE print ( "" Sum   of   n   terms   is   :   "" , sumOfSeries ( n ) ) NEW_LINE 1 , 3 , 5 , 9 , 17 , 33 , 65 , 129 , 257 , 513 , 1025 [/INST] 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 , 22 , 24 [/INST] 3 , 6 , 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 [/INST] 4 , 8 , 12 , 16 , 20 , 24 , 28 , 32 ,",0.44546375160911467,0.13522483756015138,0.45615397840011707,0.3333333333333333,0.8571428571428571
28,"mod = 1000000007 NEW_LINE def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE DEDENT","] \n MAX = 100 NEW_LINE def countSpecialStrings ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( MAX ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] + fib [ i - 2 ] ) NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE print ( countSpecialStrings ( n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 5 NEW_LINE 8 NEW_LINE 13 NEW_LINE 21 NEW_LINE 34 NEW_LINE 55 NEW_LINE 89 NEW_LINE 144 NEW_LINE 233 NEW_LINE 377 NEW_LINE 610 NEW_LINE 987 NEW_LINE 1",0.5890749268636217,0.6356472210350682,0.7554215575143849,0.5609756097560976,0.40425531914893614
29,"mod = 1e9 + 7 ; NEW_LINE def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT","] \n def countPaths ( arr , i , j , m , n ) : NEW_LINE INDENT if ( i == m - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( i >= m or j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( countPaths ( arr , i + arr [ i ] [ j ] , j + arr [ i ] [ j ] , m , n ) + countPaths ( arr , i + 1 , j , m , n ) + countPaths ( arr , i , j + 1 , m , n ) ) NEW_LINE DEDENT arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( countPaths ( arr , 0 , 0 , 3 , 3 ) ) NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE",0.3016496072637132,0.23910900333419954,0.2765803348115623,0.09090909090909091,0.6
30,"mod = 10 ** 9 + 7 NEW_LINE def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE","] \n def countPaths ( arr , n , k ) : NEW_LINE INDENT if ( arr [ n - 1 ] == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( i + j > n ) : NEW_LINE INDENT break NEW_LINE DEDENT dp [ i ] += dp [ i + j ] NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( countPaths ( arr , n , k ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE ",0.40629813307989227,0.4563767704467094,0.4780300072092079,0.3114754098360656,0.3793103448275862
31,"def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT DEDENT return ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( "" EvenSum ▁ = ▁ "" , count_even , "" ▁ OddSum ▁ = ▁ "" , count_odd ) NEW_LINE","] \n def countOddEven ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return ( count_even * count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countOddEven ( arr , n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 2 NEW_",0.3877172331348271,0.41985833954422985,0.4340408960253814,0.3333333333333333,0.36363636363636365
32,"MAX = 10 NEW_LINE def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE return digit NEW_LINE DEDENT def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( B < len ( digit ) ) : NEW_LINE INDENT if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE DEDENT return dp [ B ] NEW_LINE DEDENT DEDENT A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE","] \n import numpy as np NEW_LINE def toVector ( N ) : NEW_LINE INDENT digits = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digits . append ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT if ( N == 0 ) : NEW_LINE INDENT digits . append ( 0 ) NEW_LINE DEDENT digits . reverse ( ) NEW_LINE return digits NEW_LINE DEDENT def countNumbers ( A , B , C ) : NEW_LINE INDENT digit = toVector ( C ) NEW_LINE if ( len ( digit ) < B ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( digit ) == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT lower = np . zeros ( B + 1 ) NEW_LINE lower [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT if ( digit [ i - 1 ]",0.255058339218053,0.11164951161789362,0.23602452052108053,0.463768115942029,0.2087912087912088
33,"import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT","] import math NEW_LINE def countPaths ( wt , n , M ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT used = False NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( wt - i >= 0 ) : NEW_LINE INDENT used = True NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return countPaths ( wt - M , n , M ) + countPaths ( wt - n , n , M ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 3 NEW_LINE M = 2 NEW_LINE W = 10 NEW_LINE print ( countPaths ( W , N , M ) ) NEW_LINE DEDENT 1 NEW_LINE 2",0.37047481633554696,0.3513057703709271,0.3905466565637667,0.3114754098360656,0.42857142857142855
34,"def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT",] \n def countPartitions ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT return countPartitions ( n - 1 ) + countPartitions ( n - 2 ) + countPartitions ( n - 3 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( countPartitions ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE ,0.21484190357683175,0.09829180844894073,0.1045644557986492,0.1935483870967742,0.46296296296296297
35,"MAX = 20 NEW_LINE def LIP ( dp , mat , n , m , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE DEDENT return dp [ x ] [ y ] NEW_LINE DEDENT def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE","] \n import numpy as np NEW_LINE def longestIncreasingPath ( matrix , m , n , dp ) : NEW_LINE INDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( m == 0 and n == ( n - 1 ) ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == 0 and n == n ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == m and n == 0 ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == m and n == ( n - 1 ) ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == ( m - 1 ) and n == 0",0.2195697120521696,0.12905085877548161,0.17477872817512372,0.3146067415730337,0.25984251968503935
36,"def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( "" ▁ Number ▁ of ▁ Paths ▁ "" , countPaths ( n , m ) ) NEW_LINE","] def countPaths ( x , y ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( x == 0 ) : NEW_LINE INDENT return countPaths ( y - 1 , y ) NEW_LINE DEDENT elif ( y == 0 ) : NEW_LINE INDENT return countPaths ( x - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( countPaths ( x - 1 , y ) + countPaths ( x , y - 1 ) ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE y = 3 NEW_LINE print ( countPaths ( x , y ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE",0.5729163957821555,0.21329669673770302,0.3965507045727371,0.6818181818181818,1.0
37,"MAX = 100 NEW_LINE def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE","] \n def goldMine ( grid , n , m ) : NEW_LINE INDENT goldMineTable = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT goldMineTable [ i ] [ 0 ] = grid [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT goldMineTable [ 0 ] [ i ] = max ( grid [ 0 ] [ i ] , goldMineTable [ 0 ] [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT goldMineTable [ i ] [ j ] = max ( grid [ i ] [ j ] + max ( goldMineTable [ i - 1 ] [ j - 1 ] , goldMineTable [ i - 1 ] [ j ] , goldMineTable [ i - 1",0.3630345785275744,0.21252924262517228,0.26137310355843574,0.422680412371134,0.5555555555555556
38,"M = 100 NEW_LINE def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( "" Minimum ▁ adjustment ▁ cost ▁ is "" , minAdjustmentCost ( arr , n , target ) , sep = ' ▁ ' ) NEW_LINE","] NEW_LINE import sys NEW_LINE def minAdjustmentCost ( A , M , N , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = sys . maxsize NEW_LINE DEDENT dp [ 0 ] [ A [ 0 ] ] = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - k ) ) NEW_LINE DEDENT DEDENT D",0.42695605370157924,0.48513517058302796,0.5310626352055756,0.5434782608695652,0.14814814814814814
39,"def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT","] def countTriplets ( L , R ) : NEW_LINE INDENT total = 0 NEW_LINE diff = R - L NEW_LINE if ( diff % 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT total = ( diff // 3 ) * ( diff // 3 + 1 ) // 2 NEW_LINE return total NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT L = 1 NEW_LINE R = 10 NEW_LINE print ( countTriplets ( L , R ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 12 NEW_LINE 14 NEW_LINE 16 NEW_LINE 18 NEW_LINE 20 NEW_LINE 22 NEW_LINE 24 NEW_LINE 26 NEW_LINE 28 NEW_LINE 30 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE",0.5402439559394608,0.34590684118042997,0.4850441686816319,0.4838709677419355,0.8461538461538461
40,"def printArrays ( n ) : NEW_LINE INDENT A , B = [ ] , [ ] ; NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT DEDENT print ( "" { ▁ "" , end = "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = "" "" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( "" , ▁ "" , end = "" "" ) ; NEW_LINE DEDENT DEDENT print ( "" } "" ) ; NEW_LINE print ( "" { ▁ "" , end = "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = "" "" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( "" , "" , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT print ( "" ▁ } "" , end = "" "" ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE printArrays ( N ) ; NEW_LINE DEDENT","] def constructArrays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( 2 * n ) NEW_LINE B = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT A [ i - 1 ] = i NEW_LINE B [ i - 1 ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = ""   "" ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE constructArrays ( N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW",0.41687736121762,0.31111501616009524,0.3491480518987904,0.5434782608695652,0.463768115942029
41,"def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT","] \n def flipCommonBits ( A , B ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A & ( ~ ( 1 << i ) ) NEW_LINE B = B & ( ~ ( 1 << i ) ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 10 NEW_LINE B = 15 NEW_LINE flipCommonBits ( A , B ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE",0.8018820612888165,0.6066062117069222,0.8294934620197721,0.7714285714285715,1.0
42,def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE,"NT def countDistinctSum ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += a [ i ] + b [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE b = [ 5 , 6 , 7 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( countDistinctSum ( a , b , n ) ) NEW_LINE 1 NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW",0.3124707487429013,0.04056771054208672,0.19951136286089108,0.17647058823529413,0.8333333333333334
43,"def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT count += i NEW_LINE DEDENT return count NEW_LINE DEDENT str = ""00021"" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE","] def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT freq [ 0 ] += 1 NEW_LINE DEDENT elif ( str [ i ] == '1' ) : NEW_LINE INDENT freq [ 1 ] += 1 NEW_LINE DEDENT elif ( str [ i ] == '2' ) : NEW_LINE INDENT freq [ 2 ] += 1 NEW_LINE DEDENT DEDENT if ( freq [ 0 ] and freq [ 1 ] and freq [ 2 ] ) : NEW_LINE INDENT count = ( freq [ 0 ] * freq [ 1 ] * freq [ 2 ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = ""10022",0.35667985915481887,0.4011289567499365,0.47735058417181614,0.3559322033898305,0.19230769230769232
44,"def minFlips ( st ) : NEW_LINE INDENT count = 0 NEW_LINE if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( st ) - 2 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = ""0011101"" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT","] def minOperations ( s ) : NEW_LINE INDENT count = 0 NEW_LINE n = len ( s ) NEW_LINE if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] and s [ i + 1 ] == s [ i + 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = ""10010100"" NEW_LINE print ( minOperations ( s ) ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE",0.5573628084584088,0.42419802363708536,0.459538924482264,0.56,0.7857142857142857
45,"def convertToHex ( num ) : NEW_LINE INDENT temp = "" "" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num // 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT def encryptString ( S , N ) : NEW_LINE INDENT ans = "" "" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE while ( i < N and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE hex = convertToHex ( count ) NEW_LINE ans += ch NEW_LINE ans += hex NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" abc "" NEW_LINE N = len ( S ) NEW_LINE print ( encryptString ( S , N ) ) NEW_LINE DEDENT","] \n def convertToHex ( n ) : NEW_LINE INDENT return "" { 0 : X } "" . format ( n ) NEW_LINE DEDENT def encryptString ( S ) : NEW_LINE INDENT ans = "" "" NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT count = 1 NEW_LINE ch = S [ i ] NEW_LINE while ( i < len ( S ) and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE ans += ch NEW_LINE ans += convertToHex ( count ) NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = "" aabbbc "" NEW_LINE print ( encryptString ( S ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6",0.39720606675085435,0.4677388025790017,0.48927456698851823,0.3974358974358974,0.234375
46,"def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countOfString ( N ) : NEW_LINE INDENT Stotal = pow ( 2 , N ) NEW_LINE Sequal = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N // 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) // 2 NEW_LINE return S1 NEW_LINE DEDENT N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE","] def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countStrings ( N ) : NEW_LINE INDENT total = binomialCoeff ( 2 , N ) NEW_LINE equal = binomialCoeff ( 2 , N // 2 ) NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT return total - equal NEW_LINE DEDENT else : NEW_LINE INDENT return total NEW_LINE DEDENT DEDENT N = 5 NEW_LINE print ( countStrings ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE",0.5728935325984278,0.6779601840411654,0.7398411553287028,0.7608695652173914,0.11290322580645161
47,"def removeCharRecursive ( str , X ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return "" "" NEW_LINE DEDENT if ( str [ 0 ] == X ) : NEW_LINE INDENT return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT str = "" geeksforgeeks "" NEW_LINE X = ' e ' NEW_LINE str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE","] \n def removeChar ( str , ch ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return "" "" NEW_LINE DEDENT if ( str [ 0 ] == ch ) : NEW_LINE INDENT return removeChar ( str [ 1 : ] , ch ) NEW_LINE DEDENT else : NEW_LINE INDENT return str [ 0 ] + removeChar ( str [ 1 : ] , ch ) NEW_LINE DEDENT DEDENT str = "" geeksforgeeks "" NEW_LINE ch = ' e ' NEW_LINE print ( removeChar ( str , ch ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE ",0.7159142646412394,0.4591197094434658,0.6536412917738217,0.8064516129032258,0.9444444444444444
48,"def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE DEDENT if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = "" : "" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( ""0"" , hh , end = "" : "" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( ""0"" , mm ) NEW_LINE DEDENT DEDENT def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i // 10 NEW_LINE if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j // 10 NEW_LINE if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT timeValue = "" ? ? : ? ? "" NEW_LINE L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE",] \n def isValidTime ( s ) : NEW_LINE INDENT if ( s [ 0 ] == ' ? ' or s [ 1 ] == ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s [ 2 ] == ' ? ' or s [ 3 ] == ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s [ 0 ] == '2' and s [ 1 ] == '3' and s [ 2 ] == '5' and s [ 3 ] == '9' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def checkDifference ( s ) : NEW_LINE INDENT if ( abs ( ( ord ( s [ 0 ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ 1 ] ) - ord ( '0' ) ) - ( ord ( s [ 2 ] ) - ord ( '0' ) ) * 10 - ( ord ( s [ 3 ] ) - ord ( '0' ),0.10291919556678637,0.0548658761002715,0.11212660167085063,0.18032786885245902,0.06435643564356436
49,"def check ( s , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT str = "" aanncddc "" ; NEW_LINE n = len ( str ) NEW_LINE if ( check ( str , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","NT def check ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) : NEW_LINE INDENT if ( len ( st ) > 0 and st [ - 1 ] == str [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT str = "" abab "" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE str = "" abac "" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE str = "" aba "" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE str = "" abac "" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE 2 NEW_LINE ",0.6283827907743572,0.5890486599213299,0.6122492172586027,0.36486486486486486,0.9473684210526315
50,"from collections import defaultdict NEW_LINE def findNumOfValidWords ( w , p ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE res = [ ] NEW_LINE for s in w : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT m [ val ] += 1 NEW_LINE DEDENT for s in p : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT temp = val NEW_LINE first = ord ( s [ 0 ] ) - ord ( ' a ' ) NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT if ( ( ( temp >> first ) & 1 ) == 1 ) : NEW_LINE INDENT if ( temp in m ) : NEW_LINE INDENT count += m [ temp ] NEW_LINE DEDENT DEDENT temp = ( temp - 1 ) & val NEW_LINE DEDENT res . append ( count ) NEW_LINE DEDENT for it in res : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr1 = [ "" aaaa "" , "" asas "" , "" able "" , "" ability "" , "" actt "" , "" actor "" , "" access "" ] NEW_LINE arr2 = [ "" aboveyz "" , "" abrodyz "" , "" absolute "" , "" absoryz "" , "" actresz "" , "" gaswxyz "" ] NEW_LINE findNumOfValidWords ( arr1 , arr2 ) NEW_LINE DEDENT","] NEW_LINE from collections import defaultdict NEW_LINE def countStrings ( arr1 , arr2 , n , m ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE res = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = arr1 [ i ] NEW_LINE temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) < 26 ) : NEW_LINE INDENT temp += 1 << ( ord ( s [ j ] ) - ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT freq [ temp ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT s = arr2 [ i ] NEW_LINE temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) < 2",0.30968259426369127,0.2216467284195255,0.266998527763602,0.42424242424242425,0.3258426966292135
51,"def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT while ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE i += 1 NEW_LINE DEDENT s = ' ' . join ( map ( str , s ) ) NEW_LINE return s NEW_LINE DEDENT DEDENT DEDENT s = ""100010001"" NEW_LINE print ( flip ( s ) ) NEW_LINE","] def printBinary ( s , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count = 0 NEW_LINE while ( i < n and s [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT s = list ( s ) NEW_LINE s [ i - count + j ] = '1' NEW_LINE s = ' ' . join ( s ) NEW_LINE DEDENT print ( s ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = ""1010001"" NEW_LINE n = len ( s ) NEW_LINE printBinary ( s , n ) NEW_LINE DEDENT 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE ",0.40859359773630655,0.373216974335925,0.6004431308950154,0.4107142857142857,0.25
52,"def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = "" "" ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( "" ▁ "" , s [ i ] . lower ( ) , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = "" "" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT s = "" ILoveGeeksForGeeks "" NEW_LINE getOrgString ( s ) NEW_LINE","] def camelToSentence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( s [ i ] , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ord ( s [ i ] ) >= 65 and ord ( s [ i ] ) <= 90 ) : NEW_LINE INDENT print ( ""   "" , end = "" "" ) NEW_LINE print ( chr ( ord ( s [ i ] ) + 32 ) , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" GeeksForGeeks "" NEW_LINE camelToSentence ( s ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5",0.6091044704328769,0.4936322641010725,0.6273094271542441,0.48214285714285715,0.8333333333333334
53,"' NEW_LINE def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = "" abcac "" NEW_LINE print ( countChar ( str , ' a ' ) ) NEW_LINE","] \n def countOccurrences ( n , k , s ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % len ( s ) != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n // len ( s ) ) * ( len ( s ) - 1 ) + 1 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 6 NEW_LINE k = 2 NEW_LINE s = "" aa "" NEW_LINE print ( countOccurrences ( n , k , s ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE DEDENT 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE",0.4474413798873543,0.18462015179148936,0.20514536775792777,0.4,0.0
54,"def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 10 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE","] def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT for j in range ( count [ i ] ) : NEW_LINE INDENT print ( i , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 6 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 1 NEW_",0.5300414665404969,0.6417515564069705,0.7537766285955967,0.391304347826087,0.3333333333333333
55,"def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = ""001001"" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( "" YES "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) ; NEW_LINE DEDENT","] def check ( s , m ) : NEW_LINE INDENT n = len ( s ) NEW_LINE zeros = 0 NEW_LINE ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros >= m ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ones >= m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = ""000011111"" NEW_LINE m = 4 NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE ",0.4678779150142052,0.5065076129508546,0.5162645513076473,0.45588235294117646,0.39285714285714285
56,"def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" NEW_LINE k = 2 NEW_LINE print ( productAtKthLevel ( tree , k ) ) NEW_LINE","] def productOfDigits ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE level = 1 NEW_LINE while ( level < k ) : NEW_LINE INDENT level += 1 NEW_LINE ans *= n NEW_LINE n = n // 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT ans *= n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 1234 NEW_LINE k = 2 NEW_LINE print ( productOfDigits ( n , k ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 24 NEW_LINE 32 NEW_LINE 48 NEW_LINE 64 NEW_LINE 123 NEW_LINE 246 NEW_LINE 492 NEW_LINE 984 NEW_LINE 1968 NEW_LINE 3936 NEW_LINE 78",0.1943396204143667,0.17360004437236423,0.18134464418165425,0.1724137931034483,0.25
57,"def findDuplicates ( a , n , m ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if i != k and a [ i ] [ j ] == a [ k ] [ j ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT for k in range ( m ) : NEW_LINE INDENT if j != k and a [ i ] [ j ] == a [ i ] [ k ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if not isPresent [ i ] [ j ] : NEW_LINE INDENT print ( a [ i ] [ j ] , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE a = [ "" zx "" , "" xz "" ] NEW_LINE findDuplicates ( a , n , m ) NEW_LINE DEDENT","] def removeDuplicates ( a , n ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( isPresent [ i ] [ j ] == False ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if ( a [ i ] [ k ] == a [ i ] [ j ] ) : NEW_LINE INDENT isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT if ( a [ k ] [ j ] == a [ i ] [ j ] ) : NEW_LINE INDENT isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT if ( isPresent [ i ] [ j ] == False and isPresent [ j ] [ i ] == False ) : NEW_LINE INDENT print ( a [ i ] [",0.5739977289692826,0.5331351427615042,0.5697201596260303,0.6621621621621622,0.5309734513274337
58,"def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = ""007462542X "" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Invalid "" ) NEW_LINE DEDENT","] \n def isValidISBN ( ISBN ) : NEW_LINE INDENT if ( len ( ISBN ) != 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , 9 ) : NEW_LINE INDENT sum += ( ( ord ( ISBN [ i ] ) - ord ( '0' ) ) * ( 10 - i ) ) NEW_LINE DEDENT if ( ( sum % 11 == 0 and ISBN [ 9 ] == 'X' ) or ( sum % 11 == 10 and ISBN [ 9 ] == '0' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT ISBN = "" 9780131423950 "" NEW_LINE if ( isValidISBN ( ISBN ) ) : NEW_LINE INDENT print ( "" Valid "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Invalid "" ) NEW_LINE DEDENT",0.4007732505173386,0.42384880231526767,0.4292441997540867,0.5666666666666667,0.18333333333333332
59,"def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" hello ▁ world "" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT","] def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def reverseVowels ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE vowels = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT vowels . append ( str [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT str [ i ] = vowels [ - 1 ] NEW_LINE vowels . pop ( ) NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" geeksfor",0.5394278940196212,0.40195445724856943,0.4241228896053247,0.6265060240963856,0.7051282051282052
60,"def firstLetterWord ( str ) : NEW_LINE INDENT result = "" "" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" geeks ▁ for ▁ geeks "" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT","] \n def findString ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE v = False NEW_LINE output = "" "" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '   ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( v == True ) : NEW_LINE INDENT output += s [ i ] NEW_LINE v = False NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" Geeks   for   Geeks "" NEW_LINE print ( findString ( s ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW",0.5722413471254516,0.4307484908896933,0.5198330592282747,0.6111111111111112,0.7272727272727273
61,"def dfs ( i , j , grid , vis , ans , z , z_count ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE vis [ i ] [ j ] = 1 NEW_LINE if ( grid [ i ] [ j ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT if ( grid [ i ] [ j ] == 2 ) : NEW_LINE INDENT if ( z == z_count ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT if ( i >= 1 and not vis [ i - 1 ] [ j ] and grid [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i - 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( i < n - 1 and not vis [ i + 1 ] [ j ] and grid [ i + 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i + 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j >= 1 and not vis [ i ] [ j - 1 ] and grid [ i ] [ j - 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j - 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j < m - 1 and not vis [ i ] [ j + 1 ] and grid [ i ] [ j + 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j + 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT def uniquePaths ( grid ) : NEW_LINE INDENT z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT x = i NEW_LINE y = j NEW_LINE DEDENT DEDENT DEDENT grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] NEW_LINE print ( uniquePaths ( grid ) ) NEW_LINE DEDENT","] def dfs ( i , j , vis , ans , z , z_count , graph ) : NEW_LINE INDENT vis [ i ] [ j ] = True NEW_LINE z += 1 NEW_LINE if ( i == graph [ 0 ] [ 0 ] and j == graph [ 0 ] [ 0 ] ) : NEW_LINE INDENT ans . append ( z ) NEW_LINE return NEW_LINE DEDENT if ( z == z_count ) : NEW_LINE INDENT ans . append ( z ) NEW_LINE return NEW_LINE DEDENT if ( i > 0 and graph [ i - 1 ] [ j ] and not vis [ i - 1 ] [ j ] ) : NEW_LINE INDENT dfs ( i - 1 , j , vis , ans , z , z_count , graph ) NEW_LINE DEDENT if ( i < graph [ 0 ] [ 0 ] and graph [ i + 1 ] [ j ] and not vis [ i + 1 ] [ j ] ) : NEW_LINE INDENT dfs ( i + 1 , j , vis , ans",0.22474925929432732,0.07584571162350777,0.20673418564672866,0.3087248322147651,0.3076923076923077
62,"def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 3 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( numPairs ( a , n ) ) NEW_LINE","] \n def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT right = n - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= 2 * arr [ right ] ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT ans += right - i NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 2 , 1 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1",0.5111490549010919,0.5253725027252231,0.5592452049264179,0.5490196078431373,0.410958904109589
63,def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE print ( areaOfSquare ( S ) ) NEW_LINE DEDENT,] \n def area_square ( side ) : NEW_LINE INDENT area = ( side * side ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT side = 5 NEW_LINE print ( area_square ( side ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_,0.6426141438365865,0.25251261374307327,0.6512772949366061,0.6666666666666666,1.0
64,"def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT x = 3 NEW_LINE y = 4 NEW_LINE print ( maxPointOfIntersection ( x , y ) ) NEW_LINE","] \n N = 3 NEW_LINE M = 2 NEW_LINE def maxPoints ( points ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT x1 , y1 = points [ i ] NEW_LINE x2 , y2 = points [ j ] NEW_LINE if ( x1 == x2 and y1 == y2 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE for m in range ( M ) : NEW_LINE INDENT x3 , y3 = points [ m ] NEW_LINE if ( ( k * x3 - y3 ) == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT return ans NEW_LINE DEDENT",0.17770230930193326,0.056143363026952844,0.15466587418078032,0.16666666666666666,0.3333333333333333
65,def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE,"] \n def icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 18 * n ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( ""5 - th   icosihenagonal   number   is   =   "" , icosihenagonal_num ( n ) ) NEW_LINE 5 - th icosihenagonal number is   =   43 NEW_LINE 2 NEW_LINE 4 NEW_LINE 7 NEW_LINE 11 NEW_LINE 16 NEW_LINE 22 NEW_LINE 30 NEW_LINE 39 NEW_LINE 49 NEW_LINE 61 NEW_LINE 75 NEW_LINE 91 NEW_LINE 109 NEW_LINE 130 NEW_LINE 154 NEW_LINE 181 NEW_LINE 211 NEW_LINE 245 NEW_LINE 283 NEW_LINE 325 NEW_LINE 372 NEW_LINE 424 NEW_LINE 482 NEW_LINE",0.49363203808020983,0.2197885451168459,0.4285747326520221,0.5483870967741935,0.7777777777777778
66,"def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( round ( ans [ 0 ] , 12 ) , ans [ 1 ] ) NEW_LINE","] \n def findCentroid ( x , y , n ) : NEW_LINE INDENT A = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT A += ( x [ i + 1 ] * y [ i ] - x [ i ] * y [ i + 1 ] ) NEW_LINE DEDENT xCentroid = A / ( 6.0 * n ) NEW_LINE yCentroid = A / ( 6.0 * n ) NEW_LINE print ( "" Centroid   =   ( "" , xCentroid , "" ,   "" , yCentroid , "" ) "" ) NEW_LINE DEDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 4 , 5 , 6 ] NEW_LINE n = len ( x ) NEW_LINE findCentroid ( x , y , n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE",0.21061140284460403,0.1465411595813065,0.16016757640179016,0.1827956989247312,0.35294117647058826
67,"d = 10 NEW_LINE a = 0.0 NEW_LINE a = ( 360 - ( 6 * d ) ) / 4 NEW_LINE print ( a , "" , "" , a + d , "" , "" , a + 2 * d , "" , "" , a + 3 * d , sep = ' ▁ ' ) NEW_LINE","] \n def angles ( a , b , c ) : NEW_LINE INDENT x = a + b + c NEW_LINE print ( "" Angles   are   : "" ) NEW_LINE print ( "" A   = "" , x / 2 ) NEW_LINE print ( "" B   = "" , x / 2 ) NEW_LINE print ( "" C   = "" , x / 2 ) NEW_LINE DEDENT a = 30 NEW_LINE b = 40 NEW_LINE c = 120 NEW_LINE angles ( a , b , c ) NEW_LINE 3 ; NEW_LINE 4 ; NEW_LINE 120 NEW_LINE 1 / 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2",0.21781589710761648,0.021631434231161078,0.04963215419930477,0.24,0.56
68,"import math NEW_LINE def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( "" Perpendicular ▁ distance ▁ is "" ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Planes ▁ are ▁ not ▁ parallel "" ) NEW_LINE DEDENT DEDENT a1 = 1 NEW_LINE b1 = 2 NEW_LINE c1 = - 1 NEW_LINE d1 = 1 NEW_LINE a2 = 3 NEW_LINE b2 = 6 NEW_LINE c2 = - 3 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) NEW_LINE","] \n import math NEW_LINE def distance ( a , b , c , d , e , f ) : NEW_LINE INDENT return ( abs ( ( a * e - b * d ) / math . sqrt ( ( a * a + b * b ) ) ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE e = 5 NEW_LINE f = 6 NEW_LINE print ( distance ( a , b , c , d , e , f ) ) NEW_LINE 1 , 2 , 3 , 4 , 5 , 6 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE ",0.2745734595465671,0.1263622474806901,0.12669349546748296,0.2916666666666667,0.5535714285714286
69,def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def numOfNecklace ( N ) : NEW_LINE INDENT ans = factorial ( N ) // ( factorial ( N // 2 ) * factorial ( N // 2 ) ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans //= 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( numOfNecklace ( N ) ) NEW_LINE DEDENT,"] def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def countWays ( N ) : NEW_LINE INDENT ans = fact ( N ) // fact ( N // 2 ) NEW_LINE ans = ans // 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE ",0.3667547724392326,0.3809576825856258,0.41128937069714044,0.5319148936170213,0.14285714285714285
70,"def isDivisibleByDivisor ( S , D ) : NEW_LINE INDENT S %= D NEW_LINE hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE INDENT S += ( S % D ) NEW_LINE S %= D NEW_LINE if ( S in hashMap ) : NEW_LINE INDENT if ( S == 0 ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT return "" No "" NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT DEDENT return "" Yes "" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 3 NEW_LINE D = 6 NEW_LINE print ( isDivisibleByDivisor ( S , D ) ) NEW_LINE DEDENT","] def check ( S , D ) : NEW_LINE INDENT V = [ 0 for i in range ( 1000005 ) ] NEW_LINE V [ 0 ] = S % D NEW_LINE for i in range ( 1 , 1000005 ) : NEW_LINE INDENT V [ i ] = ( V [ i - 1 ] + V [ i - 1 ] % D ) % D NEW_LINE if ( V [ i ] in V [ 0 : i ] ) : NEW_LINE INDENT return "" YES "" NEW_LINE DEDENT else : NEW_LINE INDENT V [ i ] = V [ i ] NEW_LINE DEDENT DEDENT return "" NO "" NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = 100 NEW_LINE D = 1000 NEW_LINE print ( check ( S , D ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE ",0.3881100111316841,0.3466792231403081,0.4168901176221074,0.38461538461538464,0.40425531914893614
71,"def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x / y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y / x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( int ( cnt ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE y = 1 NEW_LINE minimumSteps ( x , y ) NEW_LINE DEDENT","] def countSteps ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 1 and y != 1 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT count += 1 NEW_LINE x -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE y -= 1 NEW_LINE DEDENT DEDENT if ( x > 1 and y > 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 3 NEW_LINE Y = 4 NEW_LINE countSteps ( X , Y ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE",0.4788399858248998,0.46892641497208937,0.5227493178011942,0.45,0.47368421052631576
72,"def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT red_len = len ( s ) NEW_LINE n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT return ( red_len // 2 + n % 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT expr = "" } } { { "" NEW_LINE print ( countMinReversals ( expr . strip ( ) ) ) NEW_LINE DEDENT","] \n def countReversals ( expr ) : NEW_LINE INDENT m = len ( expr ) NEW_LINE if ( m % 2 != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = m // 2 NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( expr [ i ] == ' ( ' ) : NEW_LINE INDENT s . append ( ' ( ' ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( ' ) ' ) NEW_LINE DEDENT DEDENT for i in range ( n , m ) : NEW_LINE INDENT if ( expr [ i ] == ' ( ' ) : NEW_LINE INDENT s . append ( ' ( ' ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( ' ) ' ) NEW_LINE DEDENT DEDENT red_len = ( m + n ) NEW_LINE c = 0 NEW_LINE for i in range ( red_len ) : NEW_LINE INDENT if (",0.48981291170845354,0.4142814064013004,0.4241263585759734,0.38666666666666666,0.7341772151898734
73,"def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == "" I "" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == "" D "" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE print ( "" "" , curr_max , end = "" "" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == "" D "" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == "" D "" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( "" "" , curr_max , curr_max - 1 , end = "" "" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" "" , last_entry - 1 , end = "" "" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT PrintMinNumberForPattern ( "" IDID "" ) NEW_LINE PrintMinNumberForPattern ( "" I "" ) NEW_LINE PrintMinNumberForPattern ( "" DD "" ) NEW_LINE PrintMinNumberForPattern ( "" II "" ) NEW_LINE PrintMinNumberForPattern ( "" DIDI "" ) NEW_LINE PrintMinNumberForPattern ( "" IIDDD "" ) NEW_LINE PrintMinNumberForPattern ( "" DDIDDIID "" ) NEW_LINE DEDENT","] \n def minimumNumber ( input , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE last_entry = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if ( input [ i ] == ' I ' ) : NEW_LINE INDENT noOfNextD = current_max NEW_LINE DEDENT else : NEW_LINE INDENT noOfNextD = last_entry NEW_LINE DEDENT if ( input [ i ] == ' I ' and i == 0 ) : NEW_LINE INDENT current_max += 1 NEW_LINE print ( current_max , end = "" "" ) NEW_LINE DEDENT elif ( input [ i ] == ' I ' ) : NEW_LINE INDENT print ( current_max + 1 , end = "" "" ) NEW_LINE current_max += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( noOfNextD == 0 ) : NEW_LINE INDENT print ( last_entry , end = "" "" ) NEW_LINE D",0.28679459890907066,0.11522686533010111,0.20739830575295706,0.4888888888888889,0.3356643356643357
74,"def printLeast ( arr ) : NEW_LINE INDENT min_avail = 1 NEW_LINE pos_of_I = 0 NEW_LINE v = [ ] NEW_LINE if ( arr [ 0 ] == ' I ' ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( 2 ) NEW_LINE v . append ( 1 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 0 NEW_LINE DEDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT v . append ( min_avail ) NEW_LINE min_avail += 1 NEW_LINE pos_of_I = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE for j in range ( pos_of_I , i + 1 ) : NEW_LINE INDENT v [ j ] += 1 NEW_LINE DEDENT min_avail += 1 NEW_LINE DEDENT DEDENT print ( * v , sep = ' ▁ ' ) NEW_LINE DEDENT printLeast ( "" IDID "" ) NEW_LINE printLeast ( "" I "" ) NEW_LINE printLeast ( "" DD "" ) NEW_LINE printLeast ( "" II "" ) NEW_LINE printLeast ( "" DIDI "" ) NEW_LINE printLeast ( "" IIDDD "" ) NEW_LINE printLeast ( "" DDIDDIID "" ) NEW_LINE","] \n def findMinimumNumber ( str ) : NEW_LINE INDENT min_avail = 0 NEW_LINE pos_of_I = - 1 NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' I ' ) : NEW_LINE INDENT pos_of_I = i NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( min_avail ) NEW_LINE min_avail -= 1 NEW_LINE DEDENT DEDENT for i in range ( pos_of_I + 1 ) : NEW_LINE INDENT ans . append ( min_avail ) NEW_LINE min_avail -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = "" "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" DIDI "" NEW_LINE findMinimumNumber ( str",0.28210328048304484,0.2411139305269952,0.2807488789725188,0.3516483516483517,0.2549019607843137
75,"def PrintMinNumberForPattern ( Strr ) : NEW_LINE INDENT res = ' ' NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( Strr ) + 1 ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if ( i == len ( Strr ) or Strr [ i ] == ' I ' ) : NEW_LINE INDENT while len ( stack ) > 0 : NEW_LINE INDENT res += str ( stack . pop ( ) ) NEW_LINE res += ' ▁ ' NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT PrintMinNumberForPattern ( "" IDID "" ) NEW_LINE PrintMinNumberForPattern ( "" I "" ) NEW_LINE PrintMinNumberForPattern ( "" DD "" ) NEW_LINE PrintMinNumberForPattern ( "" II "" ) NEW_LINE PrintMinNumberForPattern ( "" DIDI "" ) NEW_LINE PrintMinNumberForPattern ( "" IIDDD "" ) NEW_LINE PrintMinNumberForPattern ( "" DDIDDIID "" ) NEW_LINE","] \n def decode ( seq ) : NEW_LINE INDENT result = "" "" NEW_LINE stack = [ ] NEW_LINE n = len ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if ( seq [ i ] == ' ? ' or i == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT while ( len ( stack ) != 0 ) : NEW_LINE INDENT result += str ( stack [ - 1 ] ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT seq = "" ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?",0.39344304992310963,0.23491909032012664,0.3381882157552907,0.46875,0.5319148936170213
76,"def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return "" - 1"" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inputs = [ "" IDID "" , "" I "" , "" DD "" , "" II "" , "" DIDI "" , "" IIDDD "" , "" DDIDDIID "" ] NEW_LINE for Input in inputs : NEW_LINE INDENT print ( * ( getMinNumberForPattern ( Input ) ) ) NEW_LINE DEDENT DEDENT","] \n def minNum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE rank = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT rank [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT rank [ ord ( s [ i ] ) - ord ( '0' ) ] = i + 1 NEW_LINE DEDENT ans = "" "" NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT ans += chr ( ord ( '0' ) + rank [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = ""1234567890"" NEW_LINE print ( minNum ( s ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_",0.2623236834218574,0.14450337783847828,0.15514563076628737,0.3013698630136986,0.4482758620689655
77,"import math as mt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findMinNum ( arr , n ) : NEW_LINE INDENT first , last = 0 , 0 NEW_LINE Hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( "" Minimum ▁ number : ▁ "" , end = "" "" ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = "" "" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT num = first * 10 + last NEW_LINE rev = last * 10 + first NEW_LINE print ( "" Prime ▁ combinations : ▁ "" , end = "" "" ) NEW_LINE if ( isPrime ( num ) and isPrime ( rev ) ) : NEW_LINE INDENT print ( num , "" ▁ "" , rev ) NEW_LINE DEDENT elif ( isPrime ( num ) ) : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT elif ( isPrime ( rev ) ) : NEW_LINE INDENT print ( rev ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ combinations ▁ exist "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 7 , 8 ] NEW_LINE findMinNum ( arr , 5 ) NEW_LINE","] \n def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def smallestNumber ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 0 , 10 ) :",0.22494169474298736,0.13211328332227007,0.2166413499006915,0.2894736842105263,0.26153846153846155
78,"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) ; NEW_LINE DEDENT def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , R + 1 ) : NEW_LINE INDENT if ( coprime ( a , b ) and coprime ( b , c ) and coprime ( a , c ) == False ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = a ; NEW_LINE possibleB = b ; NEW_LINE possibleC = c ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( "" ( "" , possibleA , "" , "" , possibleB , "" , "" , possibleC , "" ) ▁ is ▁ one ▁ such "" , "" possible ▁ triplet ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ Such ▁ Triplet ▁ exists ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE","T ] def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def isNonTransitive ( L , R ) : NEW_LINE INDENT for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( a , b ) == 1 ) : NEW_LINE INDENT for c in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( b , c ) == 1 and gcd ( a , c ) != 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT L = 2 NEW_LINE R = 10 NEW_LINE if ( isNon",0.38132636602486125,0.25230847368543713,0.3403046827217002,0.4326923076923077,0.5
79,"import numpy as np NEW_LINE def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 60 NEW_LINE B = 450 NEW_LINE if ( possibleToReach ( A , B ) ) : NEW_LINE INDENT print ( "" yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" no "" ) NEW_LINE DEDENT DEDENT","] import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT cuberoot = int ( math . cbrt ( a * b ) ) NEW_LINE if ( a % cuberoot == 0 and b % cuberoot == 0 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT a = 20 NEW_LINE b = 48 NEW_LINE check ( a , b ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE ",0.48708766070615217,0.28833139067143143,0.2829700718253085,0.3770491803278688,0.0
80,"def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = ""1212121"" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def isUndulating ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( rem % 2 == 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE DEDENT else : NEW_LINE INDENT rem = temp % 10 NEW_LINE DEDENT if ( rem != 0 and rem != 5 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 125 NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 25 NEW_LINE 222 NEW_LINE 111 NEW_LINE 122 NEW_LINE 222 NEW_LINE 2",0.5576107805812145,0.43794379134479866,0.5862493309800595,0.53125,0.675
81,"def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT n = 3 NEW_LINE res = Series ( n ) NEW_LINE print ( res ) NEW_LINE","] def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( "" Sum   of   the   series   is   "" , calculateSum ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28",0.40425395823008387,0.2583586185082143,0.5356907072350877,0.45454545454545453,0.3684210526315789
82,"import math NEW_LINE def counLastDigitK ( low , high , k ) : NEW_LINE INDENT mlow = 10 * math . ceil ( low / 10.0 ) NEW_LINE mhigh = 10 * int ( high / 10.0 ) NEW_LINE count = ( mhigh - mlow ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 <= k and ( low % 10 ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE","] \n def countDigit ( k , n , m ) : NEW_LINE INDENT return ( ( m - n + 1 ) - ( ( ( n - 1 ) // 10 ) - ( m // 10 ) ) ) NEW_LINE DEDENT n = 100 NEW_LINE m = 1000 NEW_LINE k = 0 NEW_LINE print ( countDigit ( k , n , m ) ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW",0.1831032084476102,0.06769260898224515,0.07138689147486232,0.26,0.3333333333333333
83,"sdef sumDivisible ( L , R ) : NEW_LINE INDENT p = int ( R / 6 ) NEW_LINE q = int ( ( L - 1 ) / 6 ) NEW_LINE sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE return sumR - sumL NEW_LINE DEDENT L = 1 NEW_LINE R = 20 NEW_LINE print ( sumDivisible ( L , R ) ) NEW_LINE","] \n def divisibleSum ( l , r ) : NEW_LINE INDENT n = ( r // 6 ) NEW_LINE m = ( l - 1 ) // 6 NEW_LINE sum1 = ( n * ( n + 1 ) * 6 ) // 2 NEW_LINE sum2 = ( m * ( m + 1 ) * 6 ) // 2 NEW_LINE return ( sum1 - sum2 ) NEW_LINE DEDENT l = 6 NEW_LINE r = 15 NEW_LINE print ( divisibleSum ( l , r ) ) NEW_LINE 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_",0.26856805134997724,0.07283045122491331,0.12644175417499562,0.375,0.5
84,"import sys NEW_LINE def prevNum ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if int ( string [ i ] ) > int ( string [ i + 1 ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT smallGreatDgt = - 1 NEW_LINE for i in range ( n - 1 , index , - 1 ) : NEW_LINE INDENT if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT DEDENT if index == - 1 : NEW_LINE INDENT return "" "" . join ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT ( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] ) NEW_LINE DEDENT return "" "" . join ( string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n_str = ""34125"" NEW_LINE ans = prevNum ( list ( n_str ) , len ( n_str ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT","] NEW_LINE def largestSmaller ( str ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( str ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return "" - 1"" NEW_LINE DEDENT str = list ( str ) NEW_LINE str [ index ] , str [ index + 1 ] = str [ index + 1 ] , str [ index ] NEW_LINE return "" "" "" . join ( str ) NEW_LINE DEDENT DEDENT str = ""12345"" NEW_LINE print ( largestSmaller ( str ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW",0.28131293684174047,0.18413777365417908,0.23366716520214448,0.4574468085106383,0.25
85,"def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = ( result * x + poly [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def findSign ( poly , n , x ) : NEW_LINE INDENT result = horner ( poly , n , x ) ; NEW_LINE if ( result > 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( result < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT poly = [ 2 , - 6 , 2 , - 1 ] ; NEW_LINE x = 3 ; NEW_LINE n = len ( poly ) ; NEW_LINE print ( "" Sign ▁ of ▁ polynomial ▁ is ▁ "" , findSign ( poly , n , x ) ) ; NEW_LINE","] def horner ( poly , n ) : NEW_LINE INDENT result = poly [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT result = result * x + poly [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT def sign ( poly , n ) : NEW_LINE INDENT return horner ( poly , n ) >= 0 NEW_LINE DEDENT x = 3 NEW_LINE poly = [ 2 , - 6 , 2 , - 1 ] NEW_LINE n = len ( poly ) NEW_LINE if ( sign ( poly , n ) ) : NEW_LINE INDENT print ( "" Positive "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Negative "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_",0.4288764043718054,0.4454892313757737,0.4426354337304954,0.23809523809523808,0.5892857142857143
86,"isPrime = [ 1 ] * 100005 NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE","] \n import math NEW_LINE def sieveOfEratostheneses ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT return prime NEW_LINE DEDENT def findMinimumNumber ( arr , n ) : NEW_LINE INDENT prime = sieveOfEratostheneses ( 1000000 ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( prime [ sum ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = sum NEW_LINE while ( not prime [ num ]",0.2973458379655316,0.2861264615446719,0.3024095887886277,0.4098360655737705,0.19101123595505617
87,"def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Sum ▁ of ▁ SubArray ▁ : "" , SubArraySum ( arr , n ) ) NEW_LINE","] \n def printSubArraySum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT sum = sum + arr [ k ] ; NEW_LINE DEDENT print ( "" Sum   of   subarray   from   "" , i , ""   to   "" , j , ""   is   "" , sum , sep = "" "" ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printSubArraySum ( arr , n ) ; NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_",0.46635285037288865,0.33172962283955143,0.5021179336017879,0.47058823529411764,0.5609756097560976
88,"import math NEW_LINE def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE",] \n def findPower ( n ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE power += 1 NEW_LINE DEDENT return power NEW_LINE DEDENT n = 15 NEW_LINE print ( findPower ( n ) ) NEW_LINE 3 NEW_LINE 5 NEW_LINE 12 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 20 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 40 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW,0.2062246642415373,0.10826474124820419,0.2232752819418538,0.25806451612903225,0.23529411764705882
89,"' NEW_LINE def aModM ( s , mod ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT number = ( number * 10 + int ( s [ i ] ) ) NEW_LINE number = number % m NEW_LINE DEDENT return number NEW_LINE DEDENT def ApowBmodM ( a , b , m ) : NEW_LINE INDENT ans = aModM ( a , m ) NEW_LINE mul = ans NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT ans = ( ans * mul ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT a = ""987584345091051645734583954832576"" NEW_LINE b , m = 3 , 11 NEW_LINE print ApowBmodM ( a , b , m ) NEW_LINE","] \n def mod ( a , m ) : NEW_LINE INDENT while ( a > m ) : NEW_LINE INDENT a -= m NEW_LINE DEDENT return a NEW_LINE DEDENT def findPower ( a , b , m ) : NEW_LINE INDENT ans = 1 NEW_LINE a = mod ( a , m ) NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT ans = ( ans * a ) % m NEW_LINE DEDENT b = b / 2 NEW_LINE a = ( a * a ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT a = ""1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",0.36684187322915807,0.36261001777360974,0.363581004554787,0.27450980392156865,0.4666666666666667
90,"class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def interpolate ( f : list , xi : int , n : int ) -> float : NEW_LINE INDENT result = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT term = f [ i ] . y NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) NEW_LINE DEDENT DEDENT result += term NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT f = [ Data ( 0 , 2 ) , Data ( 1 , 3 ) , Data ( 2 , 12 ) , Data ( 5 , 147 ) ] NEW_LINE print ( "" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : "" , interpolate ( f , 3 , 4 ) ) NEW_LINE DEDENT","] NEW_LINE class DataPoint : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def interpolate ( x , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT term = ( x - DataPoint ( 0 , 0 ) . x ) * ( DataPoint ( i , 0 ) . x ) NEW_LINE term = term / ( DataPoint ( i , 0 ) . x - x ) NEW_LINE term = term * ( DataPoint ( i , 0 ) . y ) NEW_LINE result = result + term NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT data = [ ] NEW_LINE data . append ( DataPoint ( 0 , 0 ) ) NEW_LINE data . append ( DataPoint ( 1 , 1 ) ) NEW_LINE data . append (",0.43659608161057656,0.4071099289351907,0.41261348292557987,0.29508196721311475,0.631578947368421
91,"def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 1 ) / 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = "" ▁ "" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE","] def printPrimes ( n ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE marked = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 2 * i - 1 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT print ( 2 , end = ""   "" ) NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT if ( not marked [ i ] ) : NEW_LINE INDENT print ( i , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT n = 10 NEW_LINE printPrimes ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE 11 NEW",0.3855889931179893,0.3708645187108033,0.3741941564638565,0.2972972972972973,0.5
92,"def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N ; NEW_LINE totalXOR = A [ 0 ] ^ K ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 13 , 14 , 10 , 6 ] ; NEW_LINE K = 2 ; NEW_LINE N = len ( A ) ; NEW_LINE constructArray ( A , N , K ) ; NEW_LINE DEDENT","T ] NEW_LINE def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N NEW_LINE X = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT X ^= A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT B [ i ] = X ^ A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( A ) NEW_LINE K = 1 NEW_LINE constructArray ( A , N , K ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW",0.5607390633964561,0.5526646291244054,0.6627643344756572,0.5581395348837209,0.46938775510204084
93,"def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT A = [ 10 , 15 , 5 ] ; NEW_LINE B = [ 10 , 100 , 15 , 5 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( extraElement ( A , B , n ) ) ; NEW_LINE","] def findExtra ( A , B , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = result ^ A [ i ] ^ B [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE B = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE n = len ( A ) NEW_LINE print ( findExtra ( A , B , n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 2",0.42699406660456707,0.33105347565093146,0.420401051636902,0.391304347826087,0.5652173913043478
94,"def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 9 NEW_LINE n2 = 14 NEW_LINE print ( hammingDistance ( 9 , 14 ) ) NEW_LINE DEDENT","] def hammingDistance ( a , b ) : NEW_LINE INDENT return bin ( a ^ b ) . count ( '1' ) NEW_LINE DEDENT a = 10 NEW_LINE b = 7 NEW_LINE print ( hammingDistance ( a , b ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE ",0.3478343141110738,0.09800009084488463,0.1394910117532568,0.15384615384615385,0.0
95,"def printSubsets ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n & i ) == i ) : NEW_LINE INDENT print ( i , "" ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT n = 9 NEW_LINE printSubsets ( n ) NEW_LINE",] def bitwiseAndSet ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) : NEW_LINE INDENT result = result | ( 1 << i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE print ( bitwiseAndSet ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 128 NEW_LINE 256 NEW_LINE 512 NEW_LINE 1024 NEW_LINE 2048 NEW_LINE 4096 NEW_LINE 8192 NEW_LINE 16384 NEW_LINE 32768 NEW_LINE 65536 NEW_LINE 131072 NEW_LINE 262144 NEW_LINE 524288 NEW,0.38296084986760437,0.21540886960143443,0.39083929177374493,0.23809523809523808,0.6875
96,"import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 1 << k NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE",] \n def findMSB ( n ) : NEW_LINE INDENT k = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return ( 1 << ( k - 1 ) ) NEW_LINE DEDENT n = 20 NEW_LINE print ( findMSB ( n ) ) NEW_LINE 2 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE ,0.28431913345871257,0.13659830160766212,0.38734489889385487,0.28,0.3333333333333333
97,"def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( subset ( ar , n ) ) NEW_LINE","] \n def countSubsets ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( n // arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 3 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubsets ( arr , n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW",0.36933200558793905,0.3534746296972576,0.380263649064755,0.41025641025641024,0.3333333333333333
98,"def subset ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subset ( arr , n ) ) NEW_LINE DEDENT","] def countSubsets ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 1 NEW_LINE for i in mp : NEW_LINE INDENT res *= ( mp [ i ] + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubsets ( arr , n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10",0.5037566168758872,0.4702479688982056,0.5628636049883221,0.45,0.5319148936170213
99,"psquare = [ ] NEW_LINE def calcPsquare ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT psquare . append ( i * i ) NEW_LINE DEDENT DEDENT def countWays ( index , target ) : NEW_LINE INDENT if ( target == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( index < 0 or target < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT inc = countWays ( index , target - psquare [ index ] ) NEW_LINE exc = countWays ( index - 1 , target ) NEW_LINE return inc + exc NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE calcPsquare ( N ) NEW_LINE print ( countWays ( len ( psquare ) - 1 , N ) ) NEW_LINE DEDENT","] NEW_LINE dp = [ [ 0 for i in range ( 1000000 ) ] for i in range ( 1000000 ) ] NEW_LINE def preCalculate ( ) : NEW_LINE INDENT for i in range ( 1 , 1000000 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - j * j ] [ j - 1 ] + dp [ i - j * j ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT if ( N == 4",0.31931485162834977,0.296934677081115,0.30304446409231733,0.24444444444444444,0.43283582089552236
100,"sum = 0 NEW_LINE class TreeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . size = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def sumofsubtree ( root ) : NEW_LINE INDENT p = [ 1 , 0 ] NEW_LINE if ( root . left ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . left ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . right ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT root . size = p [ 0 ] NEW_LINE return p NEW_LINE DEDENT def distance ( root , target , distancesum , n ) : NEW_LINE INDENT global sum NEW_LINE if ( root . data == target ) : NEW_LINE INDENT sum = distancesum NEW_LINE DEDENT if ( root . left ) : NEW_LINE INDENT tempsum = ( distancesum - root . left . size + ( n - root . left . size ) ) NEW_LINE distance ( root . left , target , tempsum , n ) NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT tempsum = ( distancesum - root . right . size + ( n - root . right . size ) ) NEW_LINE distance ( root . right , target , tempsum , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 1 ) NEW_LINE root . left = TreeNode ( 2 ) NEW_LINE root . right = TreeNode ( 3 ) NEW_LINE root . left . left = TreeNode ( 4 ) NEW_LINE root . left . right = TreeNode ( 5 ) NEW_LINE root . right . left = TreeNode ( 6 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE root . left . left . left = TreeNode ( 8 ) NEW_LINE root . left . left . right = TreeNode ( 9 ) NEW_LINE target = 3 NEW_LINE p = sumofsubtree ( root ) NEW_LINE totalnodes = p [ 0 ] NEW_LINE distance ( root , target , p [ 1 ] , totalnodes ) NEW_LINE print ( sum ) NEW_LINE DEDENT","] \n sum = 0 NEW_LINE def findSum ( root , target ) : NEW_LINE INDENT global sum NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT p = [ 0 , 0 ] NEW_LINE p [ 0 ] = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE findSum ( root . left , target ) NEW_LINE p [ 0 ] += 1 NEW_LINE p [ 1 ] += 1 NEW_LINE if ( root . data == target ) : NEW_LINE INDENT sum += ( p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ] - 2 * p [ 0 ] * p [ 1 ] ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT p [ 0 ] = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE findSum ( root . right , target ) NEW_LINE sum += ( p [ 0 ] * p [ 0 ] + p [ 1 ]",0.22021362493363172,0.11663711698842252,0.2079537197723003,0.34306569343065696,0.2131979695431472
101,"def rearrangeArray ( A , B , N , K ) : NEW_LINE INDENT B . sort ( reverse = True ) NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ i ] > K ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE K = 5 ; NEW_LINE rearrangeArray ( A , B , N , K ) NEW_LINE DEDENT","] def rearrange ( a , b , n , k ) : NEW_LINE INDENT b . sort ( reverse = True ) NEW_LINE if ( b [ 0 ] > k ) : NEW_LINE INDENT print ( "" Not   possible "" ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE b = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE rearrange ( a , b , n , k ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11",0.46112621321680847,0.34099992563255754,0.3368382605680098,0.6666666666666666,0.5
102,"def countRows ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE totalSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT totalSum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT currSum = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT currSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( currSum > totalSum - currSum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 2 , - 1 , 5 ] , [ - 3 , 0 , - 2 ] , [ 5 , 1 , 2 ] ] NEW_LINE countRows ( mat ) NEW_LINE DEDENT","] def countRows ( mat , n ) : NEW_LINE INDENT row = n NEW_LINE col = n NEW_LINE ans = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT sum_row = 0 NEW_LINE for j in range ( col ) : NEW_LINE INDENT sum_row += mat [ i ] [ j ] NEW_LINE DEDENT if ( sum_row > sum - sum_row ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE countRows ( mat , 3 ) NEW_LINE 2 NEW_LINE 3 NEW_LINE",0.40494466875717183,0.48213908466223204,0.4889041427550542,0.5849056603773585,0.06382978723404255
103,"def areElementsContiguous ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( "" Yes "" ) NEW_LINE else : print ( "" No "" ) NEW_LINE","] def check ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] and arr [ i ] != arr [ i - 1 ] + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( check ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE ",0.7177584150431651,0.4911340359673998,0.7132329575385941,0.6666666666666666,1.0
104,"def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def areContiguous ( arr , n ) : NEW_LINE INDENT m = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT m = m + 1 NEW_LINE l = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = min ( l , arr [ i ] ) NEW_LINE DEDENT if ( m - l < n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ arr [ i ] ] = True NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ]",0.5307352462606807,0.5270430273794696,0.5463243968956627,0.39285714285714285,0.6567164179104478
105,"def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( "" Yes "" ) NEW_LINE else : print ( "" No "" ) NEW_LINE","] \n def isContiguous ( arr , n ) : NEW_LINE INDENT us = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us [ arr [ i ] ] = 1 NEW_LINE DEDENT if ( us [ arr [ 0 ] - 1 ] == 1 ) : NEW_LINE INDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while ( us [ curr_ele ] == 1 ) : NEW_LINE INDENT if ( us [ curr_ele + 1 ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( us [ arr [ 0 ] + 1 ] == 1 ) : NEW_LINE INDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] + 1 NEW_LINE while ( us [ curr_ele ] == 1 ) :",0.3523449110401766,0.33079147200514675,0.39482748839487586,0.2222222222222222,0.46153846153846156
106,"import collections NEW_LINE def longest ( a , n , k ) : NEW_LINE INDENT freq = collections . defaultdict ( int ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE longest ( a , n , k ) NEW_LINE DEDENT","] \n def longestSubarray ( arr , n , k ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE cnt = 0 NEW_LINE ans = 0 NEW_LINE best = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE visited [ i ] = True NEW_LINE DEDENT if ( cnt > k ) : NEW_LINE INDENT cnt = k NEW_LINE DEDENT while ( cnt > 0 and i >= 0 ) : NEW_LINE INDENT if ( visited [ i ] ) : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i >= 0 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT if ( i + 1 < n ) : NEW_LINE INDENT visited [ i + 1 ] = True NEW_LINE DEDENT",0.2585168733285669,0.22592725672191927,0.25056447901659074,0.25757575757575757,0.3
107,"def kOverlap ( pairs : list , k ) : NEW_LINE INDENT vec = list ( ) NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE INDENT vec . append ( ( pairs [ 0 ] , - 1 ) ) NEW_LINE vec . append ( ( pairs [ 1 ] , 1 ) ) NEW_LINE DEDENT vec . sort ( key = lambda a : a [ 0 ] ) NEW_LINE st = list ( ) NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT cur = vec [ i ] NEW_LINE if cur [ 1 ] == - 1 : NEW_LINE INDENT st . append ( cur ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT if len ( st ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT pairs = list ( ) NEW_LINE pairs . append ( ( 1 , 3 ) ) NEW_LINE pairs . append ( ( 2 , 4 ) ) NEW_LINE pairs . append ( ( 3 , 5 ) ) NEW_LINE pairs . append ( ( 7 , 10 ) ) NEW_LINE n = len ( pairs ) NEW_LINE k = 3 NEW_LINE if kOverlap ( pairs , k ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] def checkOverlap ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( [ arr [ i ] , arr [ i ] ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ 0 ] == - 1 ) : NEW_LINE INDENT s . append ( v [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( v [ i ] [ 0 ] ) NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT if ( len ( s ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT x = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE if ( len ( s ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT y = s [",0.4042074929550079,0.22838956874811164,0.2505825027537864,0.2682926829268293,0.8695652173913043
108,"N = 5 NEW_LINE ptr = [ 0 for i in range ( 501 ) ] NEW_LINE def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT minrange = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE INDENT minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( "" The ▁ smallest ▁ range ▁ is ▁ [ "" , minel , maxel , "" ] "" ) NEW_LINE DEDENT arr = [ [ 4 , 7 , 9 , 12 , 15 ] , [ 0 , 8 , 10 , 14 , 20 ] , [ 6 , 12 , 16 , 30 , 50 ] ] NEW_LINE k = len ( arr ) NEW_LINE findSmallestRange ( arr , N , k ) NEW_LINE","] \n import sys NEW_LINE ptr = [ 0 for i in range ( 100 ) ] NEW_LINE def findRange ( list1 , n , k ) : NEW_LINE INDENT ptr = [ 0 for i in range ( k ) ] NEW_LINE index = 0 NEW_LINE while ( True ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == len ( list1 [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT min = sys . maxsize NEW_LINE max = - sys . maxsize - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT min = min ( min , list1 [ i ] [ ptr [ i ] ] ) NEW_LINE max = max ( max , list1 [ i ] [ ptr [ i ] ] ) NEW_LINE DEDENT",0.2902898323264761,0.1881993402374501,0.2727850109407202,0.32222222222222224,0.3779527559055118
109,"def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT S = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( S ) NEW_LINE ans = findLargestd ( S , n ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( "" No ▁ Solution "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + "" , "" c ▁ = ▁ d ▁ is "" , ans ) NEW_LINE DEDENT","] \n def findLargestD ( S , n ) : NEW_LINE INDENT S . sort ( ) NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT j = i + 1 NEW_LINE k = n - 1 NEW_LINE l = n - 2 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( S [ i ] == ( S [ j ] + S [ k ] + S [ l ] ) ) : NEW_LINE INDENT return S [ i ] NEW_LINE DEDENT if ( S [ i ] < ( S [ j ] + S [ k ] + S [ l ] ) ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE l -= 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT S = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( S ) NEW_LINE print (",0.36801115627032466,0.32872485854529926,0.3434329527272839,0.30526315789473685,0.4946236559139785
110,"def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if abs_diff in mp . keys ( ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE res = findFourElements ( arr , n ) NEW_LINE if ( res == - 10 ** 9 ) : NEW_LINE INDENT print ( "" No ▁ Solution . "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT","] \n def findFourElements ( arr , n , X ) : NEW_LINE INDENT s = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT s [ arr [ i ] + arr [ j ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT c = X - arr [ i ] - arr [ j ] - arr [ k ] NEW_LINE if c in s : NEW_LINE INDENT print ( "" a   = "" , arr [ i ] , "" ,   b   = "" , arr [ j ] , "" ,   c   = "" , arr [ k ] , "" ,   d   = "" , c ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 4 ,",0.41172591392410174,0.3650729105870985,0.3909746267767222,0.2826086956521739,0.6082474226804123
111,"def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE","] def countElements ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum >= k ) : NEW_LINE INDENT count += 1 NEW_LINE sum = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( countElements ( arr , n , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW",0.6233711896530356,0.41736034566571384,0.6174235308293479,0.5517241379310345,0.9069767441860465
112,"def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( "" % ▁ d "" % arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE","] def leftRotate ( arr , n , d ) : NEW_LINE INDENT temp = arr [ d ] NEW_LINE arr [ d ] = arr [ 0 ] NEW_LINE for i in range ( 1 , d ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ d ] = temp NEW_LINE DEDENT def leftRotateByD ( arr , n , d ) : NEW_LINE INDENT for i in range ( 0 , d ) : NEW_LINE INDENT leftRotate ( arr , n , 1 ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE d = 2 NEW_LINE print ( "" Before   rotation :   "" )",0.6814990794947022,0.6107243113363917,0.6642916144855546,0.45098039215686275,0.0
113,"def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT","] def sortArray ( arr , n , a , b ) : NEW_LINE INDENT start = a NEW_LINE end = b NEW_LINE temp = [ 0 ] * n NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT temp [ i - start ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i - start ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 10 , 1 , 3 , 2 , 5 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE a = 2 NEW_LINE b = 5 NEW_LINE sortArray ( arr , n , a , b ) NEW_LINE DEDENT ",0.5649871598003664,0.4641794910202583,0.47269222510428444,0.3230769230769231,0.0
114,"MAX_SIZE = 10 NEW_LINE def sortByRow ( mat , n , descending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( descending == True ) : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT DEDENT def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mat [ i ] [ j ] , mat [ j ] [ i ] = mat [ j ] [ i ] , mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n , True ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n , False ) NEW_LINE transpose ( mat , n ) ; NEW_LINE DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( "" Original ▁ Matrix : ▁ "" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( "" Matrix ▁ After ▁ Sorting : "" ) NEW_LINE printMat ( mat , n ) NEW_LINE DEDENT","] \n MAX = 100 NEW_LINE def sortRow ( mat , descending ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( descending [ i ] [ j ] < descending [ i ] [ j - 1 ] ) : NEW_LINE INDENT temp = descending [ i ] [ j ] NEW_LINE descending [ i ] [ j ] = descending [ i ] [ j - 1 ] NEW_LINE descending [ i ] [ j - 1 ] = temp NEW_LINE temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE mat [ i ] [ j - 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT def getTranspose ( mat , descending ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE",0.33832710806924104,0.2038099889438147,0.2540300503400038,0.37623762376237624,0.5192307692307693
115,"def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( "" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : "" ) NEW_LINE print ( arr ) NEW_LINE","] def moveZeroes ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] , arr [ count ] = arr [ count ] , arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT arr = [ 1 , 0 , 3 , 0 , 0 , 7 , 2 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE moveZeroes ( arr , n ) NEW_LINE print ( "" Modified   array   is   : "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT 1 NEW_LINE 0 NEW_LINE 3 NEW_LINE 0 NEW_",0.4933297869378129,0.5532960864257854,0.6517303783986369,0.5,0.2682926829268293
116,"def moveZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Original ▁ array : "" , end = "" ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE moveZerosToEnd ( arr , n ) NEW_LINE print ( "" Modified array : "" , ▁ end = ""   "" ) NEW_LINE printArray ( arr , n ) NEW_LINE","] def moveZeroes ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] , arr [ count ] = arr [ count ] , arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 0 , 0 , 3 , 0 , 2 , 0 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE moveZeroes ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 3 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 6 NEW_LINE 12 NEW_",0.6128880905380202,0.587860815529199,0.6067887855184397,0.7058823529411765,0.5510204081632653
117,"def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT def modifyAndRearrangeArr ( ar , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] = 2 * arr [ i ] NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZerosToEnd ( arr , n ) NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Original ▁ array : "" , end = "" ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE modifyAndRearrangeArr ( arr , n ) NEW_LINE print ( "" Modified array : "" , end = ""   "" ) NEW_LINE printArray ( arr , n ) NEW_LINE","] def pushZero ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT def modifyArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] *= 2 NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZero ( arr , n ) NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE IN",0.46570134737024926,0.38365331957491694,0.4806335513875616,0.5185185185185185,0.48
118,"def shiftAllZeroToLeft ( arr , n ) : NEW_LINE INDENT lastSeenNonZero = 0 NEW_LINE for index in range ( 0 , n ) : NEW_LINE INDENT if ( array [ index ] != 0 ) : NEW_LINE INDENT array [ index ] , array [ lastSeenNonZero ] = array [ lastSeenNonZero ] , array [ index ] NEW_LINE lastSeenNonZero += 1 NEW_LINE DEDENT DEDENT DEDENT","] def shiftZeroes ( arr , n ) : NEW_LINE INDENT lastSeen = n - 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] , arr [ lastSeen ] = arr [ lastSeen ] , arr [ i ] NEW_LINE lastSeen -= 1 NEW_LINE DEDENT DEDENT DEDENT 1 NEW_LINE arr = [ 1 , 0 , 0 , 0 , 1 , 0 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE shiftZeroes ( arr , n ) NEW_LINE print ( arr ) NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_",0.46818260118243293,0.18155909397960932,0.4133935329723446,0.5,0.7777777777777778
119,"def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if ( key > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT","] def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT def rearrange ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j + 1 ] , arr [ j ] = arr [ j ] , arr [ j + 1 ] NEW_LINE DEDENT arr [ i ] , arr [ - i - 1 ] = arr [ - i - 1 ] , arr [ i ] NEW_LINE DEDENT printArr ( arr , n ) NEW_LINE DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5",0.48540309379050894,0.5016505978358273,0.5057512510104191,0.4342105263157895,0.5
120,"def printArray ( A , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( A [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def reverse ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE l , r = l + 1 , r - 1 NEW_LINE reverse ( arr , l , r ) NEW_LINE DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE while i <= m and arr [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j <= r and arr [ j ] < 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT reverse ( arr , i , m ) NEW_LINE reverse ( arr , m + 1 , j - 1 ) NEW_LINE reverse ( arr , i , j - 1 ) NEW_LINE DEDENT def RearrangePosNeg ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE RearrangePosNeg ( arr , l , m ) NEW_LINE RearrangePosNeg ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE RearrangePosNeg ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT","] def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT def reverse ( arr , l , r ) : NEW_LINE INDENT while ( l < r ) : NEW_LINE INDENT temp = arr [ l ] NEW_LINE arr [ l ] = arr [ r ] NEW_LINE arr [ r ] = temp NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE k = l NEW_LINE while ( i <= m and j <= r ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT arr [ k ] = arr [ i ] NEW",0.278215426643743,0.24168762614653935,0.3272475900653668,0.3917525773195876,0.15217391304347827
121,"def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( arr [ i ] < 0 and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE print ( * arr ) NEW_LINE","] \n def rearrange ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( i < j and arr [ i ] < 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i < j and arr [ j ] > 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end",0.4759619809208618,0.583728415637558,0.6415480794744607,0.42857142857142855,0.25
122,"def winner ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( "" A "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" B "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 24 , 45 , 45 , 24 ] NEW_LINE N = len ( arr ) NEW_LINE winner ( arr , N ) NEW_LINE DEDENT","] def findWinner ( arr , n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT print ( "" A "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" B "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findWinner ( arr , N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0",0.7105893641101063,0.46217454670439656,0.7534962530643647,0.6956521739130435,0.9310344827586207
123,"import math NEW_LINE sz = 20 NEW_LINE sqr = int ( math . sqrt ( sz ) ) + 1 NEW_LINE def precomputeExpressionForAllVal ( arr , N , dp ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( i + j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def querySum ( arr , N , Q , M ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( sz ) ] for x in range ( sqr ) ] NEW_LINE precomputeExpressionForAllVal ( arr , N , dp ) NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE if ( y <= math . sqrt ( N ) ) : NEW_LINE INDENT print ( dp [ x ] [ y ] ) NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 7 , 5 , 4 ] NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q [ 0 ] ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE","] \n import math NEW_LINE def precompute ( N , arr ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N // 2 + 1 ) : NEW_LINE INDENT if ( i + j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] NEW_LINE dp [ i ] [ j ] += dp [ i + j ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumQueries ( N , arr , Q ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE precompute ( N , arr ) NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT if ( Q [ i ] [ 1 ] <= math . sqrt ( N ) ) : NEW_LINE INDENT x = Q [ i ] [ ",0.41247189296590425,0.3233039147266009,0.39165112340388264,0.45217391304347826,0.4827586206896552
124,"def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","] \n def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > 2 : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_",0.7003893857987815,0.5848949266056597,0.7916626165894666,0.625,0.8
125,"def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","] def findGreater ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] and arr [ i ] < arr [ i + 2 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 1 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findGreater ( arr , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE",0.6280745986237799,0.3745795577170707,0.7288518417041573,0.5517241379310345,0.8571428571428571
126,"import sys NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","] \n def findElements ( arr , n ) : NEW_LINE INDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( arr [ i ] < arr [ second ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ first ] or arr [ i ] == arr [ second ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( arr [ i ] < arr [ first ] or arr [ i ] < arr [ second ] ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n",0.5784333376775107,0.5346856238234023,0.6232035710424847,0.4772727272727273,0.6785714285714286
127,"def getMinOps ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 1 , 2 ] NEW_LINE print ( getMinOps ( arr ) ) NEW_LINE","] def minOperations ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT res += arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minOperations ( arr , N ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 1 NEW_LINE 5 NEW_LINE 4 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17",0.42314254736988965,0.3053064725227248,0.601549431242548,0.2857142857142857,0.5
128,"def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Smallest ▁ missing ▁ element ▁ is "" , findFirstMissing ( arr , 0 , n - 1 ) ) NEW_LINE","] def smallestMissing ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestMissing ( arr , n ) ) NEW_LINE 2 NEW_LINE 6 NEW_LINE 1 NEW_LINE 10 NEW_LINE 4 NEW_LINE 5 NEW_LINE 9 NEW_LINE 8 NEW_LINE 7 NEW_LINE 3 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 4 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE",0.35050304087448303,0.3151718748690705,0.31290411841609556,0.14893617021276595,0.625
129,"def findFirstMissing ( arr , start , end , first ) : NEW_LINE INDENT if ( start < end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( arr [ mid ] != mid + first ) : NEW_LINE INDENT return findFirstMissing ( arr , start , mid , first ) NEW_LINE DEDENT else : NEW_LINE INDENT return findFirstMissing ( arr , mid + 1 , end , first ) NEW_LINE DEDENT DEDENT return start + first NEW_LINE DEDENT def findSmallestMissinginSortedArray ( arr ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ - 1 ] == len ( arr ) - 1 ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE return findFirstMissing ( arr , 0 , len ( arr ) - 1 , first ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" First ▁ Missing ▁ element ▁ is ▁ : "" , findSmallestMissinginSortedArray ( arr ) ) NEW_LINE","] def findMissing ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def smallestMissing ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != i and arr [ i ] != i + 1 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestMissing ( arr , n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 1",0.3969661507722897,0.3467758128628067,0.36318457021686895,0.3508771929824561,0.527027027027027
130,"def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE INDENT new_excl = excl if excl > incl else incl NEW_LINE incl = excl + i NEW_LINE excl = new_excl NEW_LINE DEDENT return ( excl if excl > incl else incl ) NEW_LINE DEDENT arr = [ 5 , 5 , 10 , 100 , 10 , 5 ] NEW_LINE print find_max_sum ( arr ) NEW_LINE","] \n def maxSum ( arr , n ) : NEW_LINE INDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT incl = max ( incl , excl + arr [ i ] ) NEW_LINE excl = max ( excl , incl - arr [ i ] ) NEW_LINE DEDENT return max ( incl , excl ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 7 NEW_LINE 6 NEW_LINE 5 NEW_LINE 3 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0",0.320464683044047,0.18990655712376067,0.3513506712930289,0.21428571428571427,0.5263157894736842
131,"def countChanges ( matrix , n , m ) : NEW_LINE INDENT dist = n + m - 1 NEW_LINE freq = [ [ 0 ] * 10 for i in range ( dist ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE INDENT maximum = 0 NEW_LINE total_values = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT min_changes_sum += ( total_values - maximum ) NEW_LINE DEDENT return min_changes_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 ] , [ 3 , 5 ] ] NEW_LINE print ( countChanges ( mat , 2 , 2 ) ) NEW_LINE DEDENT",] def minChanges ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE dist = [ 0 ] * ( n + m - 2 ) NEW_LINE for i in range ( n + m - 2 ) : NEW_LINE INDENT dist [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dist [ i + j ] += 1 NEW_LINE DEDENT DEDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( n + m - 2 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT freq [ j ] += ( mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE max_val =,0.3559891092033948,0.40196738808453997,0.4203406970806877,0.3516483516483517,0.25
132,"import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while ( i + ( 1 << j ) - 1 ) < n : NEW_LINE INDENT if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE if lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] : NEW_LINE INDENT return lookup [ L ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return lookup [ R - ( 1 << j ) + 1 ] [ j ] NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE lookup = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 4 , 7 ) ) NEW_LINE print ( query ( 7 , 8 ) ) NEW_LINE DEDENT","] \n 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 NEW_LINE INDENT def fill ( lookup , arr , n ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = - 1 NEW_LINE lookup [ i ] [ n - 1 ] = - 1 NEW_LINE DEDENT for j in range ( 1 , 32 ) : NEW_LINE INDENT for i in range ( n - ( 1 << j ) + 1 ) : NEW_LINE INDENT lookup [ j ] [ i ] = lookup [ j - 1 ] [ lookup [ j - 1",0.208847055715149,0.1261705469278108,0.1996684016776285,0.3277310924369748,0.18181818181818182
133,"import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT table [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - ( 1 << j ) : NEW_LINE INDENT table [ i ] [ j ] = math . gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE return math . gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE table = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 2 ) ) NEW_LINE print ( query ( 1 , 3 ) ) NEW_LINE print ( query ( 4 , 5 ) ) NEW_LINE DEDENT","] = 10000000000000 NEW_LINE def build ( arr , lookup , n ) : NEW_LINE INDENT lookup [ 0 ] [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT lookup [ i ] [ j ] = ( lookup [ i - 1 ] [ j ] if lookup [ i - 1 ] [ j ] == INF else gcd ( lookup [ i - 1 ] [ j ] , lookup [ i - 1 ] [ j - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT def RMQ ( arr , l , r ) : NEW_LINE INDENT j = 0 NEW_LINE while ( 1 << ( j + 1 ) <= r - l + 1",0.2830680332009234,0.24578378101976722,0.29200213624507915,0.24210526315789474,0.3523809523809524
134,"def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT n , k = 5 , 3 NEW_LINE arr = [ 7 , 6 , 9 , 2 , 1 ] NEW_LINE / * Function calling * / NEW_LINE minimizeWithKSwaps ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT","] \n def lexicographicallySmallest ( arr , n , k ) : NEW_LINE INDENT pos = n - k NEW_LINE while ( k > 0 and pos >= 0 ) : NEW_LINE INDENT Min = min ( k , n ) NEW_LINE for i in range ( pos , min ( pos + k , n ) ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ pos ] NEW_LINE arr [ pos ] = temp NEW_LINE pos += 1 NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT DEDENT 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE lexicographicallySmallest ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ""   "" )",0.43185330532366334,0.3950107878267755,0.3904718150666713,0.3137254901960784,0.6282051282051282
135,"def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length "" , k , "" begins ▁ at ▁ index "" , findMaxAverage ( arr , n , k ) ) NEW_LINE","] \n def maxSubArraySum ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE start = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( max_sum < csum [ i ] - csum [ i - k ] ) : NEW_LINE INDENT max_sum = csum [ i ] - csum [ i - k ] NEW_LINE start = i - k + 1 NEW_LINE DEDENT DEDENT return start NEW_LINE DEDENT arr = [ 1 , 13 , - 3 , 2 , 3 , 1 , 1 , 1",0.6114516542331359,0.5631894389263027,0.5826171780062408,0.5,0.8
136,"def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length "" , k , "" begins ▁ at ▁ index "" , findMaxAverage ( arr , n , k ) ) NEW_LINE","] \n def maxSubarray ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum - arr [ i - k ] NEW_LINE sum = sum + arr [ i ] NEW_LINE if ( max_sum < sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE start = i - k + 1 NEW_LINE DEDENT DEDENT return start NEW_LINE DEDENT arr = [ 1 , 11 , 2 , 3 , 0 , 2 , 5 , 2 , 10 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE start = maxSubarray ( arr , n , k ) NEW_LINE if ( start ==",0.6093882491239919,0.5879113746710738,0.596863844047116,0.4888888888888889,0.7638888888888888
137,"m = dict ( ) NEW_LINE def findMinimum ( a , n , pos , myturn ) : NEW_LINE INDENT if ( pos , myturn ) in m : NEW_LINE INDENT return m [ ( pos , myturn ) ] ; NEW_LINE DEDENT if ( pos >= n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( not myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , not myturn ) + a [ pos ] + a [ pos + 1 ] ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if ( myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) , findMinimum ( a , n , pos + 2 , not myturn ) ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT def countPenality ( arr , N ) : NEW_LINE INDENT pos = 0 ; NEW_LINE turn = False ; NEW_LINE return findMinimum ( arr , N , pos , turn ) + 1 ; NEW_LINE DEDENT def printAnswer ( arr , N ) : NEW_LINE INDENT a = countPenality ( arr , N ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printAnswer ( arr , N ) ; NEW_LINE DEDENT","W_LINE INDENT mpp = { } NEW_LINE def findMinScore ( pos , myturn , arr , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( myturn == 0 ) : NEW_LINE INDENT ans = min ( findMinScore ( pos + 1 , 1 , arr , n ) + arr [ pos ] , findMinScore ( pos + 2 , 1 , arr , n ) + arr [ pos ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( findMinScore ( pos + 1 , 0 , arr , n ) + arr [ pos ] , findMinScore ( pos + 2 , 0 , arr , n ) + arr [ pos ] ) NEW_LINE DEDENT mpp [ ( pos , myturn ) ] = ans NEW_LINE return ans NEW_LINE DEDENT def findMinPenality ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE myturn = 0",0.2723830709941743,0.162018076302323,0.21883823982812087,0.3291139240506329,0.3795620437956204
138,"import math NEW_LINE MAX = 1000001 NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT def getSumUtil ( st , ss , se , qs , qe , si ) : NEW_LINE INDENT if qs <= ss and qe >= se : NEW_LINE INDENT return st [ si ] NEW_LINE DEDENT if se < qs or ss > qe : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return ( getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ) NEW_LINE DEDENT def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE INDENT if i < ss or i > se : NEW_LINE INDENT return NEW_LINE DEDENT st [ si ] = st [ si ] + diff NEW_LINE if se != ss : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT DEDENT def updateValue ( arr , st , n , i , new_val ) : NEW_LINE INDENT if i < 0 or i > n - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT diff = new_val - arr [ i ] NEW_LINE prev_val = arr [ i ] NEW_LINE arr [ i ] = new_val NEW_LINE if prime [ new_val ] or prime [ prev_val ] : NEW_LINE INDENT if not prime [ prev_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) NEW_LINE DEDENT elif not prime [ new_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT DEDENT DEDENT def getSum ( st , n , qs , qe ) : NEW_LINE INDENT if qs < 0 or qe > n - 1 or qs > qe : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ss == se : NEW_LINE INDENT if prime [ arr [ ss ] ] : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = ( constructSTUtil ( arr , ss , mid , st , 2 * si + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , 2 * si + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT def constructST ( arr , n ) : NEW_LINE INDENT x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE max_size = 2 * int ( pow ( 2 , x ) ) - 1 NEW_LINE st = [ 0 ] * max_size NEW_LINE constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE return st NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 9 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE Q = [ [ 1 , 1 , 3 ] , [ 2 , 1 , 10 ] , [ 1 , 1 , 3 ] ] NEW_LINE SieveOfEratosthenes ( ) NEW_LINE st = constructST ( arr , n ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE updateValue ( arr , st , n , 1 , 10 ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE","3 ; Driver code [/INST] \n prime = [ True ] * 1000001 NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , 1000001 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , 1000001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def getMid ( corner1 , corner2 ) : NEW_LINE INDENT if ( corner1 == corner2 ) : NEW_LINE INDENT return corner1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( corner1 + corner2 ) / 2 ) NEW_LINE DEDENT DEDENT def getSumUtil ( node , corner1 , corner2 , arr ,",0.12221672160599723,0.0027729542630021715,0.0891530474979028,0.3121951219512195,0.0847457627118644
139,"mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( "" adc "" ) NEW_LINE A . append ( "" aec "" ) NEW_LINE A . append ( "" erg "" ) NEW_LINE S = "" ac "" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT","] \n def countWays ( i , j , dp , str1 , str2 , index , index2 , n , m ) : NEW_LINE INDENT if ( i >= n or j >= m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT c = str1 [ i ] NEW_LINE ans = 0 NEW_LINE for k in range ( index , m ) : NEW_LINE INDENT if ( str2 [ k ] == c ) : NEW_LINE INDENT ans += countWays ( i + 1 , j + 1 , dp , str1 , str2 , k + 1 , index2 , n , m ) NEW_LINE DEDENT DEDENT dp [ i ] [ j ] = ans NEW_LINE return ans NEW_LINE DEDENT def countWays ( str1 , str2 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE m =",0.26849588324416496,0.137420890852761,0.19450470006595666,0.26153846153846155,0.4805194805194805
140,"MAX = 10005 NEW_LINE MOD = 1000000007 NEW_LINE def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE DEDENT if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = ""98765432109876543210"" NEW_LINE len1 = len ( n ) NEW_LINE k = 58 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ] NEW_LINE num = process ( n ) NEW_LINE print ( countNum ( 0 , 0 , 0 , num , len1 , k ) ) NEW_LINE DEDENT","] = 10000000000 NEW_LINE def count ( num , k ) : NEW_LINE INDENT n = len ( num ) NEW_LINE dp = [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [",0.05137157835063556,0.03842406664422003,0.04242509146078956,0.10576923076923077,0.018867924528301886
141,"def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE n = len ( arr ) NEW_LINE w1 , w2 = 10 , 3 NEW_LINE print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE DEDENT","] def doubleKnapsack ( i , w1_r , w2_r , arr , n , w1 , w2 , dp ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( w1_r < 0 or w2_r < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT val1 = 0 NEW_LINE val2 = 0 NEW_LINE if ( w1_r >= arr [ i ] [ 0 ] ) : NEW_LINE INDENT val1 = arr [ i ] [ 1 ] + doubleKnapsack ( i + 1 , w1_r - arr [ i ] [ 0 ] , w2_r , arr , n , w1 , w2 , dp ) NEW_LINE DEDENT",0.31843161080641663,0.23153519656477448,0.30185308240968434,0.3055555555555556,0.43478260869565216
142,"MAX = 105 NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def dfs ( i , j , k , q , n , m ) : NEW_LINE INDENT if ( mappedMatrix [ i ] [ j ] == 0 or i > n or j > m or mark [ i ] [ j ] or q != 0 ) : NEW_LINE INDENT return q ; NEW_LINE DEDENT mark [ i ] [ j ] = 1 ; NEW_LINE ans [ k ] = [ i , j ] NEW_LINE if ( i == n and j == m ) : NEW_LINE INDENT q = k ; NEW_LINE return q ; NEW_LINE DEDENT q = dfs ( i + 1 , j + 1 , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i + 1 , j , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i , j + 1 , k + 1 , q , n , m ) ; NEW_LINE return q NEW_LINE DEDENT def lexicographicalPath ( n , m ) : NEW_LINE INDENT q = 0 ; NEW_LINE global ans , mark NEW_LINE ans = [ [ 0 , 0 ] for i in range ( MAX ) ] NEW_LINE mark = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE q = dfs ( 1 , 1 , 1 , q , n , m ) ; NEW_LINE for i in range ( 1 , q + 1 ) : NEW_LINE INDENT print ( str ( ans [ i ] [ 0 ] ) + ' ▁ ' + str ( ans [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT def countPrimePath ( n , m ) : NEW_LINE INDENT global dp NEW_LINE dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( i == 1 and j == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; NEW_LINE if ( mappedMatrix [ i ] [ j ] == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ m ] ) NEW_LINE DEDENT def preprocessMatrix ( a , n , m ) : NEW_LINE INDENT global prime NEW_LINE prime = [ 0 for i in range ( MAX ) ] NEW_LINE sieve ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( prime [ a [ i ] [ j ] ] == 0 ) : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 2 , 3 , 7 ] , [ 5 , 4 , 2 ] , [ 3 , 7 , 11 ] ] ; NEW_LINE mappedMatrix = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE preprocessMatrix ( a , n , m ) ; NEW_LINE countPrimePath ( n , m ) ; NEW_LINE lexicographicalPath ( n , m ) ; NEW_LINE DEDENT","] from collections import defaultdict NEW_LINE import sys NEW_LINE def dfs ( grid , x , y , m , n , visited , ans , res , lex , step ) : NEW_LINE INDENT if ( x < 0 or y < 0 or x >= m or y >= n or visited [ x ] [ y ] or grid [ x ] [ y ] == - 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT visited [ x ] [ y ] = True NEW_LINE lex [ x ] [ y ] = lex [ x ] [ y ] + 1 NEW_LINE if ( x == m - 1 and y == n - 1 ) : NEW_LINE INDENT step [ 0 ] = lex [ x ] [ y ] NEW_LINE return NEW_LINE DEDENT if ( x + 1 < m and grid [ x + 1 ] [ y ] == 0 and lex [ x + 1 ] [ y ] > lex [ x ] [ y ] ) : NEW_LINE INDENT dfs ( grid , x + 1 , y ,",0.11137169326360827,0.010753537708601399,0.05292426964101256,0.25339366515837103,0.1284153005464481
143,"def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE count = [ [ 0 for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE count [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE count [ i ] [ 0 ] = - 1 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE count [ i ] [ j ] = count [ i ] [ j - 1 ] NEW_LINE if ( i >= arr [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE if ( subset [ i ] [ j ] ) : NEW_LINE INDENT count [ i ] [ j ] = ( max ( count [ i ] [ j - 1 ] , count [ i - arr [ j - 1 ] ] [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count [ sum ] [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 10 ] NEW_LINE sum = 20 NEW_LINE n = 4 NEW_LINE print ( isSubsetSum ( arr , n , sum ) ) NEW_LINE DEDENT","] \n def subsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for i in range ( sum + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( j < arr [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - arr [ i - 1 ] ] ) NEW",0.4178100880254542,0.3405758501864183,0.44856741453675775,0.552,0.3300970873786408
144,"MAX = 100 NEW_LINE lcslen = 0 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def lcs ( str1 , str2 , len1 , len2 , i , j ) : NEW_LINE INDENT if ( i == len1 or j == len2 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ret = 0 NEW_LINE if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ret NEW_LINE return ret NEW_LINE DEDENT def printAll ( str1 , str2 , len1 , len2 , data , indx1 , indx2 , currlcs ) : NEW_LINE INDENT if ( currlcs == lcslen ) : NEW_LINE INDENT print ( "" "" . join ( data [ : currlcs ] ) ) NEW_LINE return NEW_LINE DEDENT if ( indx1 == len1 or indx2 == len2 ) : NEW_LINE INDENT return NEW_LINE DEDENT for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT done = False NEW_LINE for i in range ( indx1 , len1 ) : NEW_LINE INDENT if ( chr ( ch ) == str1 [ i ] ) : NEW_LINE for j in range ( indx2 , len2 ) : NEW_LINE INDENT if ( chr ( ch ) == str2 [ j ] and dp [ i ] [ j ] == lcslen - currlcs ) : NEW_LINE data [ currlcs ] = chr ( ch ) NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) NEW_LINE done = True NEW_LINE break NEW_LINE DEDENT if ( done ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT def prinlAllLCSSorted ( str1 , str2 ) : NEW_LINE INDENT global lcslen NEW_LINE len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) NEW_LINE data = [ ' a ' for i in range ( MAX ) ] NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = "" abcabcaa "" NEW_LINE str2 = "" acbacba "" NEW_LINE prinlAllLCSSorted ( str1 , str2 ) NEW_LINE DEDENT","] NEW_LINE def lcs ( i , j , str1 , str2 , data , lcslen , currlcs , data ) : NEW_LINE INDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT return lcs ( i - 1 , j - 1 , str1 , str2 , data , lcslen , currlcs , data ) + 1 NEW_LINE DEDENT return max ( lcs ( i - 1 , j , str1 , str2 , data , lcslen , currlcs , data ) , lcs ( i , j - 1 , str1 , str2 , data , lcslen , currlcs , data ) ) NEW_LINE DEDENT def printLCS ( str1",0.15242112496650734,0.05235138625801371,0.1623181521258739,0.18705035971223022,0.2079646017699115
145,"def isMajority ( arr , n , x ) : NEW_LINE INDENT last_index = ( n // 2 + 1 ) if n % 2 == 0 else ( n // 2 ) NEW_LINE for i in range ( last_index ) : NEW_LINE INDENT if arr [ i ] == x and arr [ i + n // 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( "" % ▁ d ▁ appears ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] "" % ( x , n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" % ▁ d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] "" % ( x , n // 2 ) ) NEW_LINE DEDENT","] def isMajority ( arr , n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT index = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT index = ( n + 1 ) // 2 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == index ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isMajority ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 0",0.4431400889640597,0.3488979462587818,0.36283038447971766,0.3877551020408163,0.6730769230769231
146,"def _binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid == 0 or x > arr [ mid - 1 ] ) and ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif x > arr [ mid ] : NEW_LINE INDENT return _binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return _binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def isMajority ( arr , n , x ) : NEW_LINE INDENT i = _binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( i + n // 2 ) <= ( n - 1 ) ) and arr [ i + n // 2 ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT","] def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid ] == x and ( mid == 0 or arr [ mid - 1 ] != x ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] == x ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT return binarySearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT def isMajorityElement ( arr , n , x ) : NEW_LINE INDENT index = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if index == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( index >= n / 3 ) NEW_LINE DEDENT arr = [ 4 , 4 , 4 , 4 , 4 , 5",0.5876901100376577,0.5185647658425071,0.5181117524136493,0.4827586206896552,0.8313253012048193
147,"def isMajorityElement ( arr , n , key ) : NEW_LINE INDENT if ( arr [ n // 2 ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE if ( isMajorityElement ( arr , n , x ) ) : NEW_LINE INDENT print ( x , "" ▁ appears ▁ more ▁ than ▁ "" , n // 2 , "" ▁ times ▁ in ▁ arr [ ] "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , "" ▁ does ▁ not ▁ appear ▁ more ▁ than "" , n // 2 , "" ▁ times ▁ in ▁ arr [ ] "" ) NEW_LINE DEDENT DEDENT","] \n def isMajority ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i + 1 == n // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isMajority ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE ",0.4572526191489239,0.3982634689742055,0.40574700762149013,0.4,0.625
148,"INT_MIN = - 32767 NEW_LINE def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( "" Maximum ▁ Obtainable ▁ Value ▁ is ▁ "" + str ( cutRod ( arr , size ) ) ) NEW_LINE","] def rodCut ( price , n ) : NEW_LINE INDENT val = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val [ i ] = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val [ i ] = max ( val [ i ] , price [ j - 1 ] + val [ i - j ] ) NEW_LINE DEDENT DEDENT return val [ n ] NEW_LINE DEDENT price = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 17 , 20 ] NEW_LINE n = 7 NEW_LINE print ( "" Maximum   price   that   can   be   obtained   is   "" , rodCut ( price , n ) ) NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0",0.38261087504623015,0.5521937548542994,0.5667739117819006,0.3018867924528302,0.1095890410958904
149,"def isPossible ( target ) : NEW_LINE INDENT max = 0 NEW_LINE index = 0 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if ( max < target [ i ] ) : NEW_LINE max = target [ i ] NEW_LINE index = i NEW_LINE DEDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if ( i != index ) : NEW_LINE max -= target [ i ] NEW_LINE if ( max <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT target [ index ] = max NEW_LINE return isPossible ( target ) NEW_LINE DEDENT target = [ 9 , 3 , 5 ] NEW_LINE res = isPossible ( target ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT","] \n def check ( arr , target , n , m ) : NEW_LINE INDENT max = - 1 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( target [ i ] > max ) : NEW_LINE INDENT max = target [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( index != i ) : NEW_LINE INDENT max = max - arr [ i ] NEW_LINE if ( max < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if ( max <= 0 ) : NEW_LINE INDENT max = target [ index ] NEW_LINE DEDENT return check ( arr , target , n , m ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ,",0.5053629885917819,0.515482603115132,0.5391608406136974,0.44680851063829785,0.52
150,"def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 NEW_LINE print ( nCr ( n + m , k ) ) NEW_LINE DEDENT","] \n def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res / ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def sumOfProducts ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + binomialCoeff ( i , j ) * binomialCoeff ( j , k ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE k = 2 NEW_LINE print ( sumOfProducts ( n , k ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8",0.37139180170223485,0.3183417811411097,0.47278098122338513,0.19444444444444445,0.5
151,"import math NEW_LINE def Is_possible ( N ) : NEW_LINE INDENT C = 0 NEW_LINE D = 0 NEW_LINE while ( N % 10 == 0 ) : NEW_LINE INDENT N = N / 10 NEW_LINE C += 1 NEW_LINE DEDENT if ( math . log ( N , 2 ) - int ( math . log ( N , 2 ) ) == 0 ) : NEW_LINE INDENT D = int ( math . log ( N , 2 ) ) NEW_LINE if ( C >= D ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT N = 2000000000000 NEW_LINE Is_possible ( N ) NEW_LINE","] \n import math NEW_LINE def check ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N % 100 == 0 ) : NEW_LINE INDENT N = int ( N / 100 ) NEW_LINE count += 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( math . log2 ( N ) == math . floor ( math . log2 ( N ) ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT DEDENT N = 10000 NEW_LINE check ( N ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE ",0.4457240239277468,0.5223278307269009,0.5478816978199071,0.4626865671641791,0.25
152,def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE,] def nthTerm ( n ) : NEW_LINE INDENT return ( ( 2 * n * n - n ) // 2 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 6 NEW_LINE 15 NEW_LINE 30 NEW_LINE 55 NEW_LINE 91 NEW_LINE 140 NEW_LINE 204 NEW_LINE 282 NEW_LINE 375 NEW_LINE 484 NEW_LINE 610 NEW_LINE 754 NEW_LINE 916 NEW_LINE 1100 NEW_LINE 1308 NEW_LINE 1544 NEW_LINE 1808 NEW_LINE 2100 NEW_LINE 2422 NEW_LINE 2776 NEW_LINE 3162 NEW_LINE 3582 NEW_LINE 4036 NEW_LINE 4526 NEW_LINE 5054 NEW_LINE 562,0.3000006298395495,0.14862931624542647,0.4918493935889619,0.14285714285714285,0.4166666666666667
153,"def printSeries ( n , a , b , c ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( a , end = "" ▁ "" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( a , b , end = "" ▁ "" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( a , b , c , end = "" ▁ "" ) ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = a + b + c ; NEW_LINE print ( d , end = "" ▁ "" ) ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE c = d ; NEW_LINE DEDENT DEDENT N = 7 ; a = 1 ; b = 3 ; NEW_LINE c = 4 ; NEW_LINE printSeries ( N , a , b , c ) ; NEW_LINE","] def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( i * i , end = ""   "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i * ( i + 1 ) , end = ""   "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 6 NEW_LINE printSeries ( n ) NEW_LINE DEDENT 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 8 NEW_LINE 15 NEW_LINE 27 NEW_LINE 50 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 8 NEW_LINE 15 NEW_LINE 27 NEW_LINE 50 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 8 NEW_LINE 15 NEW_LINE 27 NEW_LINE",0.28692326488378633,0.22312266946589526,0.23129307914488023,0.2647058823529412,0.42857142857142855
154,"def diameter ( n ) : NEW_LINE INDENT L , H , templen = 0 , 0 , 0 ; NEW_LINE L = 1 ; NEW_LINE H = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT while ( L * 2 <= n ) : NEW_LINE INDENT L *= 2 ; NEW_LINE H += 1 ; NEW_LINE DEDENT if ( n >= L * 2 - 1 ) : NEW_LINE INDENT return 2 * H + 1 ; NEW_LINE DEDENT elif ( n >= L + ( L / 2 ) - 1 ) : NEW_LINE INDENT return 2 * H ; NEW_LINE DEDENT return 2 * H - 1 ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( diameter ( n ) ) ; NEW_LINE",] def diameterOfBIT ( N ) : NEW_LINE INDENT L = int ( ( N ** ( 1 / 2 ) ) NEW_LINE H = int ( ( N ** ( 1 / 2 ) ) NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( L == H ) : NEW_LINE INDENT return 2 * H NEW_LINE DEDENT if ( L == H + 1 ) : NEW_LINE INDENT return 2 * H + 1 NEW_LINE DEDENT if ( L == H + 2 ) : NEW_LINE INDENT return 2 * H + 2 NEW_LINE DEDENT return 2 * H + 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print (,0.369981683802457,0.3877049247769701,0.39372823489010206,0.33783783783783783,0.36065573770491804
155,"import math NEW_LINE def compareValues ( a , b , c , d ) : NEW_LINE INDENT log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE if num1 > num2 : NEW_LINE INDENT print ( a , ' ^ ' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , ' ^ ' , d ) NEW_LINE DEDENT DEDENT a = 8 NEW_LINE b = 29 NEW_LINE c = 60 NEW_LINE d = 59 NEW_LINE compareValues ( a , b , c , d ) NEW_LINE","] \n import math NEW_LINE def findLarger ( a , b , c , d ) : NEW_LINE INDENT a_b = a * math . log ( b ) NEW_LINE c_d = c * math . log ( d ) NEW_LINE if ( a_b > c_d ) : NEW_LINE INDENT print ( "" a ^ b   is   larger "" ) NEW_LINE DEDENT elif ( a_b < c_d ) : NEW_LINE INDENT print ( "" c ^ d   is   larger "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Both   are   equal "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE findLarger ( a , b , c , d ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_",0.5577677913212195,0.3057264278215805,0.42534473746329743,0.5,0.0
156,"MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a // 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE","] NEW_LINE def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findSum ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT if ( i % j == 0 and prime [ j ] ) : NEW_LINE INDENT flag = False NEW_",0.27119131397274904,0.23088571494742816,0.2877483037596993,0.29545454545454547,0.2706766917293233
157,"def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT","] def countPrimes ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def generatePrefix ( arr , n ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE",0.43315507178075235,0.42234981168339336,0.46246468645735667,0.3968253968253968,0.45098039215686275
158,"import math NEW_LINE def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT n = 10 ; x = 2 ; y = 40 NEW_LINE print ( minValue ( n , x , y ) ) NEW_LINE","] \n import math NEW_LINE def findValue ( n , x , y ) : NEW_LINE INDENT ans = math . ceil ( ( ( y * n ) / 100 ) - x ) NEW_LINE if ( ans >= x ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 100 NEW_LINE x = 80 NEW_LINE y = 20 NEW_LINE print ( findValue ( n , x , y ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20",0.5051893773116323,0.30365184932436473,0.5220592202936813,0.35294117647058826,0.8421052631578947
159,"from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] \n import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE",0.5320339330960058,0.5019325179523448,0.5595365477650119,0.5,0.5666666666666667
160,"n = 5 NEW_LINE fac1 = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE DEDENT fac2 = fac1 * n NEW_LINE totalWays = fac1 * fac2 NEW_LINE print ( totalWays ) NEW_LINE","] \n def countWays ( n ) : NEW_LINE INDENT fac1 = 1 NEW_LINE fac2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE fac2 = fac2 * i NEW_LINE DEDENT print ( fac2 // fac1 ) NEW_LINE DEDENT n = 5 NEW_LINE countWays ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE",0.4179645196191145,0.22069272540618548,0.5761653530702726,0.4583333333333333,0.4166666666666667
161,"MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT","] NEW_LINE import math NEW_LINE def SieveOfEratosthenes ( n , arr ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n , arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( n == arr [ i ] * ( arr [ i ] + 1 ) ) : NEW_LINE INDENT",0.36716411875529176,0.37928955406062,0.4229744415245893,0.28378378378378377,0.3826086956521739
162,"from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT",] \n def nextCube ( n ) : NEW_LINE INDENT return ( n * n * n ) NEW_LINE DEDENT n = 24 NEW_LINE print ( nextCube ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 8 NEW_LINE 27 NEW_LINE 64 NEW_LINE 125 NEW_LINE 216 NEW_LINE 343 NEW_LINE 512 NEW_LINE 729 NEW_LINE 1000 NEW_LINE 1331 NEW_LINE 1728 NEW_LINE 2197 NEW_LINE 2772 NEW_LINE 3436 NEW_LINE 4200 NEW_LINE 5061 NEW_LINE 6024 NEW_LINE 7102 NEW_LINE 8321 NEW_LINE 9688 NEW_LINE 11197 NEW_LINE 12864 NEW_LINE 14688 NEW_LINE 16756 NEW_LINE 19088,0.1867361914805419,0.10775710944838973,0.15307654536266674,0.20833333333333334,0.2777777777777778
163,"import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE root_n = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root_n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( int ) ( n / i ) and isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT if ( isPrime ( ( int ) ( n / i ) ) ) : NEW_LINE INDENT Sum += ( int ) ( n / i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT n = 60 NEW_LINE print ( "" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is "" , SumOfPrimeDivisors ( n ) ) NEW_LINE","] \n import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def sumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE IND",0.45355208460734736,0.42230510753694794,0.507850074746262,0.5697674418604651,0.3142857142857143
164,"def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT n = ""777"" NEW_LINE print ( findpos ( n ) ) NEW_LINE","] def getPosition ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 5 == 2 ) : NEW_LINE INDENT print ( pos * 2 + 1 , end = ""   "" ) NEW_LINE DEDENT elif ( n % 5 == 3 ) : NEW_LINE INDENT print ( pos * 2 + 2 , end = ""   "" ) NEW_LINE DEDENT elif ( n % 5 == 5 ) : NEW_LINE INDENT print ( pos * 2 + 3 , end = ""   "" ) NEW_LINE DEDENT elif ( n % 5 == 7 ) : NEW_LINE INDENT print ( pos * 2 + 4 , end = ""   "" ) NEW_LINE DEDENT n = n // 5 NEW_LINE pos = pos + 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE getPosition ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW",0.33047515211029266,0.19863269047623383,0.30954242776885843,0.3137254901960784,0.5
165,"def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( "" ( "" , possibleA , "" , "" , possibleB , "" , "" , possibleC , "" ) ▁ is ▁ one ▁ such "" , "" possible ▁ triplet ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ Such ▁ Triplet ▁ exists ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE","] \n def check ( L , R ) : NEW_LINE INDENT if ( R - L + 1 < 3 ) : NEW_LINE INDENT print ( "" No "" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( L , R + 1 , 2 ) : NEW_LINE INDENT if ( ( k * ( k + 1 ) % 2 == 0 ) and ( ( k + 1 ) * ( k + 2 ) % 2 == 0 ) and ( k * ( k + 2 ) % 2 != 0 ) ) : NEW_LINE INDENT print ( k , k + 1 , k + 2 ) NEW_LINE return NEW_LINE DEDENT DEDENT for k in range ( L , R + 1 , 2 ) : NEW_LINE INDENT if ( ( k * ( k + 1 ) % 2 == 0 ) and ( ( k + 1 ) * ( k + 2 ) % 2 == 0 ) and ( k * ( k + 2 ) % ",0.21797371247795805,0.16527980116855287,0.18614376744725575,0.3142857142857143,0.20618556701030927
166,"mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE","] \n def digitNumber ( n , digit ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 8 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( 9 * ( 10 ** ( n - 1 ) ) - 10 * ( 10 ** ( n - 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 9 * ( 10 ** ( n - 1 ) ) - 9 * ( 10 ** ( n - 2 ) ) ) NEW_LINE DEDENT DEDENT def countNumber ( n , digit ) : NEW_LINE INDENT if ( digit == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( digit == 10 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT return digit",0.44651657603225986,0.47088818568646734,0.48284163378117906,0.38028169014084506,0.4520547945205479
167,"def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return isPrime ( rev ) NEW_LINE DEDENT n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT n1 = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n1 = n1 * 10 + n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 121 NEW_LINE if ( isEmirp ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else",0.6799359317012824,0.6457740664144629,0.6521214982470738,0.7317073170731707,0.6901408450704225
168,"def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT radian = 5 NEW_LINE print ( "" degree ▁ = "" , ( Convert ( radian ) ) ) NEW_LINE","] \n def radian_to_degree ( rad ) : NEW_LINE INDENT degree = rad * 180 NEW_LINE return degree NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT rad = 3.14 NEW_LINE degree = radian_to_degree ( rad ) NEW_LINE print ( degree ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE ",0.32812707547098585,0.09195913976496636,0.22054916211897707,0.2222222222222222,0.7777777777777778
169,"def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE rowmajorSum = sn ( n , an ) ; NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE",W_LINE INDENT def sum ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) // 2 NEW_LINE return sum NEW_LINE DEDENT def trace ( n ) : NEW_LINE INDENT row_sum = sum ( n ) NEW_LINE row_sum = sum ( n ) NEW_LINE column_sum = sum ( n ) NEW_LINE column_sum = sum ( n ) NEW_LINE return row_sum + column_sum NEW_LINE DEDENT n = 4 NEW_LINE print ( trace ( n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE DEDENT 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 8 NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 1,0.29632123010327316,0.19977769820947294,0.2099152367755686,0.13114754098360656,0.6444444444444445
170,"def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( "" Not ▁ possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE m = 4 NEW_LINE k = 1 NEW_LINE max_area ( n , m , k ) NEW_LINE","] \n def maxArea ( w , h , k ) : NEW_LINE INDENT if ( w < k ) : NEW_LINE INDENT print ( w ) NEW_LINE return NEW_LINE DEDENT if ( h < k ) : NEW_LINE INDENT print ( h ) NEW_LINE return NEW_LINE DEDENT print ( w * h ) NEW_LINE DEDENT w = 2 NEW_LINE h = 10 NEW_LINE k = 2 NEW_LINE maxArea ( w , h , k ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 2",0.2075615854206418,0.16775155658865856,0.17224137378786578,0.14814814814814814,0.34210526315789475
171,def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT side = 4 NEW_LINE area = area_fun ( side ) NEW_LINE print ( area ) NEW_LINE,"] \n def findArea ( a ) : NEW_LINE INDENT return a * a NEW_LINE DEDENT a = 5 NEW_LINE print ( "" Area   of   square   is   "" , findArea ( a ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE ",0.23443819126301316,0.04668398722558142,0.14999734925504268,0.42857142857142855,0.3125
172,def countConsecutive ( N ) : NEW_LINE INDENT count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT N = 15 NEW_LINE print countConsecutive ( N ) NEW_LINE N = 10 NEW_LINE print countConsecutive ( N ) NEW_LINE,"] \n def countWays ( N ) : NEW_LINE INDENT L = int ( ( 1 + N / 2 ) ** 0.5 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , L + 1 ) : NEW_LINE INDENT ans += ( N // ( i * ( i + 1 ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 10 NEW_LINE print ( countWays ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE ",0.2454780827364868,0.20830522319273698,0.24027377441987702,0.3333333333333333,0.2
173,"def isAutomorphic ( N ) : NEW_LINE INDENT sq = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N /= 10 NEW_LINE sq /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print "" Automorphic "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" Not ▁ Automorphic "" NEW_LINE DEDENT","] \n def isAutomorphic ( N ) : NEW_LINE INDENT square = N * N NEW_LINE while ( N > 0 and square > 0 ) : NEW_LINE INDENT if ( ( N % 10 ) != ( square % 10 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = N // 10 NEW_LINE square = square // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 25 NEW_LINE if ( isAutomorphic ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 1",0.4961572716669699,0.3744125466204736,0.6420846719155376,0.3142857142857143,0.6538461538461539
174,"def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ True ] * ( N + 5 ) ; NEW_LINE i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE","] \n def findMaximumPrimeFactors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findMaximumPrimeFactors ( n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE ",0.33684859068223166,0.3348065333951568,0.34578267769272286,0.41379310344827586,0.25301204819277107
175,"def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def squareRoot ( n , p ) : NEW_LINE INDENT if ( p % 4 != 3 ) : NEW_LINE INDENT print ( "" Invalid ▁ Input "" ) NEW_LINE return NEW_LINE DEDENT n = n % p NEW_LINE x = power ( n , ( p + 1 ) // 4 , p ) NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "" Square ▁ root ▁ is ▁ "" , x ) NEW_LINE return NEW_LINE DEDENT x = p - x NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "" Square ▁ root ▁ is ▁ "" , x ) NEW_LINE return NEW_LINE DEDENT print ( "" Square ▁ root ▁ doesn ' t ▁ exist ▁ "" ) NEW_LINE DEDENT p = 7 NEW_LINE n = 2 NEW_LINE squareRoot ( n , p ) NEW_LINE","] def power ( x , y , p ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def squareRoot ( n , p ) : NEW_LINE INDENT if ( ( p + 1 ) % 4 == 0 ) : NEW_LINE INDENT if ( power ( n , ( p + 1 ) / 4 , p ) % p == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( power ( n , ( p +",0.4667159244757945,0.43916314935196493,0.45995861306734226,0.46774193548387094,0.5
176,"import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def miillerTest ( d , n ) : NEW_LINE INDENT a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT k = 4 ; NEW_LINE print ( "" All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ "" ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT","] NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x >= p ) : NEW_LINE INDENT x %= p NEW_LINE DEDENT res = ( res * x ) % p NEW_LINE y -= 1 NEW_LINE if ( y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def isProbablePrime ( n , k ) : NEW_LINE INDENT d = 0 NEW_LINE while ( d < n - 1 ) : NEW_LINE INDENT d += 2 NEW_LINE DEDENT d = d // 2 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT a = randint ( 2 , n - 2 ) NEW_LINE x = power ( a , d , n ) NEW_LINE if ( x == 1 )",0.2716772914984652,0.1679388594052625,0.26159803479724625,0.3829787234042553,0.27419354838709675
177,def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE,] def longestConseqOne ( x ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE x = x & ( x - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT x = 20 NEW_LINE print ( longestConseqOne ( x ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE ,0.3421392606649901,0.21358657512088658,0.4142297267983331,0.18518518518518517,0.5555555555555556
178,"def subtract ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT borrow = ( ~ x ) & y NEW_LINE x = x ^ y NEW_LINE y = borrow << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( "" x ▁ - ▁ y ▁ is "" , subtract ( x , y ) ) NEW_LINE","] def subtract ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE result = "" "" NEW_LINE carry = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT borrow = ( ( y [ i ] ) & ( ~ ( x [ i ] ) ) NEW_LINE result = ( ( x [ i ] ) ^ ( y [ i ] ) ^ ( borrow ) + ( carry ) ) NEW_LINE carry = ( ( x [ i ] ) & ( borrow ) NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT result = ( ""1"" + result ) NEW_LINE DEDENT return result NEW_LINE DEDENT x = ""1101001"" NEW_LINE y = ""111010"" NEW_LINE print ( "" After   Subtraction :   "" + subtract ( x , y ) ) NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW",0.23794133310384255,0.19698214969987926,0.43422124146389457,0.1724137931034483,0.14814814814814814
179,"def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( "" x ▁ - ▁ y ▁ is "" , subtract ( x , y ) ) NEW_LINE","] \n def subtract ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return a - subtract ( b , subtract ( a , b ) ) NEW_LINE DEDENT DEDENT a = 100 NEW_LINE b = 70 NEW_LINE print ( subtract ( a , b ) ) NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW",0.41133389239946727,0.1440414857727613,0.2655046101408973,0.3157894736842105,0.92
180,"def addEdge ( v , x , y ) : NEW_LINE INDENT v [ x ] . append ( y ) NEW_LINE v [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( tree , temp , ancestor , u , parent , k ) : NEW_LINE INDENT temp . append ( u ) NEW_LINE for i in tree [ u ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( tree , temp , ancestor , i , u , k ) NEW_LINE DEDENT temp . pop ( ) NEW_LINE if ( len ( temp ) < k ) : NEW_LINE INDENT ancestor [ u ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ancestor [ u ] = temp [ len ( temp ) - k ] NEW_LINE DEDENT DEDENT def KthAncestor ( N , K , E , edges ) : NEW_LINE INDENT tree = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT temp = [ ] NEW_LINE ancestor = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( tree , temp , ancestor , 1 , 0 , K ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ancestor [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE K = 2 NEW_LINE E = 8 NEW_LINE edges = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 7 ] , [ 3 , 8 ] , [ 3 , 9 ] ] NEW_LINE KthAncestor ( N , K , E , edges ) NEW_LINE DEDENT","W_LINE INDENT def addEdge ( V , u , v ) : NEW_LINE INDENT V [ u ] . append ( v ) NEW_LINE DEDENT def findKthAncestor ( V , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT ans = [ ] NEW_LINE q = [ ] NEW_LINE q . append ( i ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( len ( ans ) == K ) : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( len ( V [ node ] ) ) : NEW_LINE INDENT if ( len ( ans ) == K ) : NEW_LINE INDENT break NEW_LINE DEDENT q . append ( V [ node ] [ j ] ) NEW_LINE DEDENT DEDENT ans . append ( node ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT",0.24666130106679995,0.11355051311314555,0.16878630113137857,0.32653061224489793,0.37777777777777777
181,"def build ( sum , a , l , r , rt ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT sum [ rt ] = a [ l - 1 ] NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE build ( sum , a , l , m , rt << 1 ) NEW_LINE build ( sum , a , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT def pushDown ( sum , add , rt , ln , rn ) : NEW_LINE INDENT if ( add [ rt ] ) : NEW_LINE INDENT add [ rt << 1 ] += add [ rt ] NEW_LINE add [ rt << 1 1 ] += add [ rt ] NEW_LINE sum [ rt << 1 ] += add [ rt ] * ln NEW_LINE sum [ rt << 1 1 ] += add [ rt ] * rn NEW_LINE add [ rt ] = 0 NEW_LINE DEDENT DEDENT def update ( sum , add , L , R , C , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT sum [ rt ] += C * ( r - l + 1 ) NEW_LINE add [ rt ] += C NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE if ( L <= m ) : NEW_LINE INDENT update ( sum , add , L , R , C , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT DEDENT def queryy ( sum , add , L , R , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT return sum [ rt ] NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE ans = 0 NEW_LINE if ( L <= m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , m + 1 , r , ( rt << 1 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def sequenceMaintenance ( n , q , a , b , m ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE sum = [ 0 ] * ( 4 * n ) NEW_LINE add = [ 0 ] * ( 4 * n ) NEW_LINE ans = [ ] NEW_LINE build ( sum , a , 1 , n , 1 ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE pos = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( queryy ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) : NEW_LINE INDENT r = m - 1 NEW_LINE pos = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n - pos + 1 ) NEW_LINE update ( sum , add , pos , n , - m , 1 , n , 1 ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE Q = 3 NEW_LINE M = 1 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE query = [ 4 , 3 , 1 ] NEW_LINE sequenceMaintenance ( N , Q , arr , query , M ) NEW_LINE DEDENT","] def build ( v , arr , seg , ss , se , si ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE build ( v , arr , v , ss , mid , si ) NEW_LINE build ( v , arr , v , mid + 1 , se , 2 * si + 1 ) NEW_LINE DEDENT def pushDown ( v , seg , ss , se , si ) : NEW_LINE INDENT if ( seg [ si ] != 0 ) : NEW_LINE INDENT v [ si ] += seg [ si ] NEW_LINE if ( ss != se ) : NEW_LINE INDENT seg [ 2 * si + 1 ] += seg [ si ] NEW_LINE seg [ 2 * si + 2 ] += seg [ si ] NEW_LINE DEDENT DEDENT DEDENT def update ( v , seg , ss , se , si , l , r , val ) : NEW_LINE INDENT if ( l == ss and r == se )",0.17108462639853694,0.014089484485068167,0.07598094350766862,0.3380952380952381,0.25617283950617287
182,"import math NEW_LINE def hasCoprimePair ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( math . gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE arr = [ 6 , 9 , 15 ] NEW_LINE if ( hasCoprimePair ( arr , n ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT","W_LINE INDENT def findLength ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT arr = [ 4 , 16 , 12 , 36 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE if ( findLength ( arr , n ) ) : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 36 NEW_LINE 18 NEW_LINE 3 NEW_LINE 5 NEW",0.5749761785889573,0.6102494051193689,0.6663452859264372,0.48484848484848486,0.5384615384615384
183,"def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT n = 15 NEW_LINE print ( Numberofways ( n ) ) NEW_LINE","] \n def countWays ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT for b in range ( 1 , n + 1 ) : NEW_LINE INDENT c = n - a - b NEW_LINE if ( a + b > c and c > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 12 NEW_LINE 14 NEW_LINE 16 NEW_LINE 18 NEW_LINE 20 NEW_LINE 22 NEW_LINE 24 NEW_LINE 26 NEW_LINE 28 NEW_LINE 30 NEW_LINE 32 NEW_LINE ",0.3726445486517503,0.38040751247097027,0.5553319724586117,0.3548387096774194,0.2
184,"def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count // 2 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( N , arr ) NEW_LINE DEDENT","] def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countPairs ( arr , n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW",0.47675626444083335,0.4474583291092325,0.647066728654101,0.3125,0.5
185,"def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE while y in S : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT","] \n def findFibonacciSubseq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT continue NEW_LINE DEDENT prev = arr [ i ] NEW_LINE curr = arr [ i ] NEW_LINE maxLen = max ( maxLen , 1 ) NEW_LINE while curr in mp : NEW_LINE INDENT curr = prev + arr [ i ] NEW_LINE if curr in mp : NEW_LINE INDENT maxLen = max ( maxLen , mp [ curr ] + 1 ) NEW_LINE DEDENT prev = curr NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len",0.3361446059517331,0.3586558228835137,0.3650934805998597,0.18604651162790697,0.43478260869565216
186,"def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE","] def maxElements ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 1 , 3 , 2 , 4 , 5 , 6 ] NEW_LINE k = 11 NEW_LINE n = len ( arr ) NEW_LINE print ( maxElements ( arr , n , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 11 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW",0.4707219329514195,0.456710845791639,0.6763773671688105,0.5172413793103449,0.23255813953488372
187,"def num_candyTypes ( candies ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( candies ) ) : NEW_LINE INDENT s . add ( candies [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def distribute_candies ( candies ) : NEW_LINE INDENT allowed = len ( candies ) / 2 NEW_LINE types = num_candyTypes ( candies ) NEW_LINE if ( types < allowed ) : NEW_LINE INDENT print ( int ( types ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( allowed ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT candies = [ 4 , 4 , 5 , 5 , 3 , 3 ] NEW_LINE distribute_candies ( candies ) NEW_LINE DEDENT","W_LINE def findCandies ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def maxCandies ( arr , n ) : NEW_LINE INDENT n1 = n // 2 NEW_LINE n2 = findCandies ( arr , n1 ) NEW_LINE return n2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( maxCandies ( arr , N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW",0.4468494865791921,0.42259754538132194,0.45900329948617097,0.4057971014492754,0.5
188,"import math NEW_LINE def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT A = 6 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonals ( A , theta ) NEW_LINE print ( round ( ans [ 0 ] , 2 ) , round ( ans [ 1 ] , 2 ) ) NEW_LINE","] \n import math NEW_LINE def rhombusDiagonal ( a , theta ) : NEW_LINE INDENT d = a * math . cos ( theta ) NEW_LINE return d NEW_LINE DEDENT a = 6 NEW_LINE theta = 30 NEW_LINE print ( rhombusDiagonal ( a , theta ) ) NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW",0.23462151434927414,0.21634461115581807,0.22613273796841923,0.28846153846153844,0.20754716981132076
189,"def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT y = bin ( K ) . count ( '1' ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT print ( "" Even ▁ = "" , odd , "" , ▁ Odd ▁ = "" , even ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Even ▁ = "" , even , "" , ▁ Odd ▁ = "" , odd ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE countEvenOdd ( arr , n , K ) ; NEW_LINE DEDENT","] def countEvenOdd ( arr , n , k ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd += arr [ i ] & 1 NEW_LINE even += arr [ i ] & 2 NEW_LINE DEDENT odd_k = 0 NEW_LINE even_k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd_k += k & 1 NEW_LINE even_k += k & 2 NEW_LINE DEDENT if ( odd_k & 1 ) : NEW_LINE INDENT odd = even NEW_LINE even = odd_k NEW_LINE DEDENT print ( "" Even   =   "" , even , "" ,   Odd   =   "" , odd ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE countEven",0.3813207966466571,0.31310392940515536,0.32499977000198593,0.47692307692307695,0.41025641025641024
190,N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE,] \n def countPairs ( n ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 3,0.13706382148887652,0.015391998464028769,0.07132482595301583,0.07692307692307693,0.38461538461538464
191,"import sys NEW_LINE def longestSubSequence ( A , N , ind = 0 , lastf = - sys . maxsize - 1 , lasts = sys . maxsize ) : NEW_LINE INDENT if ( ind == N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) NEW_LINE if ( A [ ind ] [ 0 ] > lastf and A [ ind ] [ 1 ] < lasts ) : NEW_LINE INDENT ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT / * Function * / NEW_LINE public static int longestSubSequence ( int [ , ] A , int N ) NEW_LINE { return longestSubSequence ( A , N , 0 , 0 , 0 ) ; } NEW_LINE if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE print ( longestSubSequence ( A , N ) ) NEW_LINE DEDENT","] \n import sys NEW_LINE def lps ( arr , i , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT notIncl = lps ( arr , i + 1 , n ) NEW_LINE incl = 0 NEW_LINE if ( i > 0 and arr [ i - 1 ] [ 1 ] > arr [ i ] [ 1 ] ) : NEW_LINE INDENT incl = lps ( arr , i + 1 , n ) + 1 NEW_LINE DEDENT return max ( notIncl , incl ) NEW_LINE DEDENT def longestSubsequence ( arr , n ) : NEW_LINE INDENT return lps ( arr , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 2 ] , [ 2 , 1 ] , [ 3 , 2 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 2 ] , [",0.3637041908179913,0.2684175916203553,0.2827964452640733,0.38461538461538464,0.5189873417721519
192,"def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 2 , 1 , 3 ] ; NEW_LINE print ( countTriplets ( A ) ) ; NEW_LINE DEDENT","] def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT x = A [ i ] & A [ j ] NEW_LINE if x in mp : NEW_LINE INDENT mp [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT x = A [ i ] & A [ j ] NEW_LINE if ( x == 0 ) : NEW_LINE INDENT cnt += mp [ x ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4",0.37306469160717765,0.32330931171528104,0.3730310873664907,0.22448979591836735,0.5714285714285714
193,"def CountWays ( n ) : NEW_LINE INDENT noOfWays = [ 0 ] * ( n + 3 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] NEW_LINE DEDENT return noOfWays [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT","] \n def countWays ( n ) : NEW_LINE INDENT noOfWays = [ 0 ] * ( n + 1 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 2 NEW_LINE noOfWays [ 2 ] = 3 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT noOfWays [ i ] = ( noOfWays [ i - 1 ] + noOfWays [ i - 2 ] ) NEW_LINE DEDENT return noOfWays [ n ] NEW_LINE DEDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE",0.5648920844305775,0.594555877953198,0.6920394867961391,0.6756756756756757,0.2972972972972973
194,"import sys NEW_LINE def findWinner ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT c = 0 NEW_LINE DEDENT DEDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE return NEW_LINE DEDENT if ( len ( v ) == 1 ) : NEW_LINE INDENT if ( ( v [ 0 ] & 1 ) != 0 ) : NEW_LINE INDENT print ( "" Player ▁ A "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE DEDENT return NEW_LINE DEDENT first = sys . minsize NEW_LINE second = sys . minsize NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT DEDENT if ( ( ( first & 1 ) != 0 ) and ( first + 1 ) // 2 > second ) : NEW_LINE INDENT print ( "" Player ▁ A "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE DEDENT DEDENT S = ""1100011"" NEW_LINE N = len ( S ) NEW_LINE findWinner ( S , N ) NEW_LINE","] \n import sys NEW_LINE def PlayerA ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE return NEW_LINE DEDENT if ( len ( v ) == 1 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE return NEW_LINE DEDENT first = sys . maxsize NEW_LINE second = - sys . maxsize - 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = v [ i ] NEW_LINE DEDENT elif (",0.4070109531906141,0.28550539821835746,0.40832788822830934,0.5175438596491229,0.4166666666666667
195,"def can_Construct ( S , K ) : NEW_LINE INDENT m = dict ( ) NEW_LINE p = 0 NEW_LINE if ( len ( S ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in S : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT if ( K > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for h in m : NEW_LINE INDENT if ( m [ h ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if ( K < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" annabelle "" NEW_LINE K = 4 NEW_LINE if ( can_Construct ( S , K ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","] \n def check ( s , k ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( k == len ( s ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in m : NEW_LINE INDENT if ( m [ i ] % 2 == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" aaab "" NEW_LINE k = 3 NEW_LINE if ( check ( s , k ) ) : NEW_LINE INDENT print ( "" Yes",0.5002923498796593,0.4619677774830411,0.4728780085421715,0.49056603773584906,0.5757575757575758
196,"def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . lower ( ) ; NEW_LINE str2 = str2 . lower ( ) ; NEW_LINE x = str1 == str2 ; NEW_LINE return x ; NEW_LINE DEDENT def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( "" Same "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Same "" ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" Geeks "" ; NEW_LINE str2 = "" geeks "" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = "" Geek "" ; NEW_LINE str2 = "" geeksforgeeks "" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT","] \n def compareStrings ( s1 , s2 ) : NEW_LINE INDENT s1 = s1 . lower ( ) NEW_LINE s2 = s2 . lower ( ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def printSameOrNotSame ( s1 , s2 ) : NEW_LINE INDENT if ( compareStrings ( s1 , s2 ) ) : NEW_LINE INDENT print ( "" Same "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not   Same "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s1 = "" Geeks "" NEW_LINE s2 = "" geeks "" NEW_LINE printSameOrNotSame ( s1 , s2 ) NEW_LINE s1 = "" Geeks "" NEW_LINE s2 = "" Geeks "" NEW_LINE printSameOrNotSame ( s1 , s2 ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_",0.4688864309124089,0.3663726968156229,0.3730191806801663,0.5961538461538461,0.54
197,"import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( "" * "" , end = "" "" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = "" GeeksForGeeks "" NEW_LINE print ( "" String : ▁ "" , string ) NEW_LINE print ( "" Max ▁ Length ▁ of ▁ Steps : ▁ "" , n ) NEW_LINE steps ( string , n ) NEW_LINE","] \n def printStep ( s , n ) : NEW_LINE INDENT flag = False NEW_LINE for x in range ( n ) : NEW_LINE INDENT if ( flag == False ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT print ( x * s , end = "" "" ) NEW_LINE flag = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x == n - 1 ) : NEW_LINE INDENT print ( x * s , end = "" "" ) NEW_LINE flag = False NEW_LINE DEDENT DEDENT DEDENT DEDENT s = "" * "" NEW_LINE n = 5 NEW_LINE printStep ( s , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW",0.4129912013059886,0.3923539209965584,0.39664792126443305,0.4,0.46296296296296297
198,"def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT a = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE","] \n def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( visited [ arr [ i ] ] == 0 ) : NEW_LINE INDENT visited [ arr [ i ] ] = 1 NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT DEDENT DEDENT 1 NEW_LINE arr = [ 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 6 , 6 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 14 , 15 , 15 , 1",0.2708912312114811,0.3032187063578018,0.33803852618043045,0.19230769230769232,0.25
199,"def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT str1 = ""10101100"" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT str2 = ""111010100"" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","] \n def isDivisible ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = ""101010"" NEW_LINE k = 3 NEW_LINE if ( isDivisible ( n , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT n = ""101010010101001010100101010010101001010100101010010101001010100",0.5495785014043728,0.4701443874225303,0.4953653853907282,0.5185185185185185,0.7142857142857143
