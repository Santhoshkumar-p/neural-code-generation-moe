{"value":"] def minSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for it in mp : NEW_LINE INDENT sum += it * mp [ it ] NEW_LINE DEDENT ans = sum NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT ans -= ( it * ( mp [ it ] - 1 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 4 , 5 , 5 , 5 , 5 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE 1 NEW_"}
{"value":"] def maxAdjacentDiff ( arr , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_diff = - 10 ** 9 NEW_LINE prev = - 10 ** 9 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT max_diff = max ( max_diff , arr [ j ] - arr [ i ] ) NEW_LINE prev = max ( prev , arr [ j ] ) NEW_LINE DEDENT ans . append ( max_diff ) NEW_LINE arr [ i ] = prev NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i , end = \"   \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacentDiff ( arr , N ) NEW_LINE DEDENT 1 NEW_LINE 2"}
{"value":"] def findSize ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return findSize ( N \/\/ 2 ) + findSize ( N \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findSize ( N \/\/ 2 ) + 1 + findSize ( N \/\/ 2 ) NEW_LINE DEDENT DEDENT def countOnes ( arr , N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT Siz_M = findSize ( N ) NEW_LINE if ( R > Siz_M ) : NEW_LINE INDENT R = Siz_M NEW_LINE DEDENT L -= Siz_M + 1 NEW_LINE if ( L < 1 ) : NEW_LINE INDENT L = 1 NEW_LINE DEDENT return ( ( R - L + 1 ) * arr [ L"}
{"value":"W_LINE INDENT def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPair ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) == False ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n \/\/ i NEW_LINE b = n \/\/ i * ( n - 1 ) NEW_LINE print ( a , b ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE findPair ( n ) NEW_LINE"}
{"value":"] NEW_LINE max_lcm = 0 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/\/ gcd ( a , b ) NEW_LINE DEDENT def max_lcm ( n ) : NEW_LINE INDENT global max_lcm NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i * i > n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT max_lcm = max ( max_lcm , lcm ( i , n \/\/ i ) ) NEW_LINE DEDENT DEDENT return max_lcm NEW_LINE DEDENT def find_representation ( n , sum , prev ,"}
{"value":"] \\n def isPrime ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( N ** 0.5 ) + 1 , 6 ) : NEW_LINE INDENT if ( N % i == 0 or N % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( N ) : NEW_LINE INDENT if ( isPrime ( N - 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _"}
{"value":"] \\n def splitArray ( arr , n , k ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE if ( splitArray ( arr , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE "}
{"value":"] from collections import defaultdict NEW_LINE def sumOfDivision ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT maxi = 0 NEW_LINE for it in mp : NEW_LINE INDENT maxi = max ( maxi , mp [ it ] ) NEW_LINE DEDENT freq = [ 0 ] * ( maxi + 1 ) NEW_LINE for it in mp : NEW_LINE INDENT freq [ mp [ it ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT ans += ( ( i * freq [ i ] ) * ( i + 1 ) \/\/ 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW"}
{"value":"] \\n def minimumInsertions ( arr , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= arr [ i ] NEW_LINE Sum += arr [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( Sum > 2 * Xor ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum - 2 * Xor ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( Xor ) NEW_LINE print ( Sum + Xor ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE minimumInsertions ( arr , N ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE "}
{"value":"] \\n def checkRoots ( a , b , c ) : NEW_LINE INDENT if ( a != 0 ) : NEW_LINE INDENT D = b * b - 4 * a * c NEW_LINE if ( D > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( D == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE if ( checkRoots ( a , b , c ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE "}
{"value":"] NEW_LINE import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr * sr == x ) ) NEW_LINE DEDENT def isSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE if ( isSunnyNumber ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE "}
{"value":"] \\n def countNumbers ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i - 1 ) % n == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE print ( countNumbers ( N ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 1 NEW_LINE 5 NEW_LINE 7 NEW_LINE 8 NEW_LINE 10 NEW_LINE 15 NEW_LINE 20 NEW_LINE 30 NEW_LINE 100 NEW_LINE 1000 NEW_LINE 10000 NEW_LINE 100000 NEW_LINE 1000000 NEW_LINE 10000000 NEW_LINE 100000000 NEW_LINE "}
{"value":"] \\n def printNumbers ( N , K ) : NEW_LINE INDENT for i in range ( 1 , K ) : NEW_LINE INDENT print ( i , end = \"   \" ) NEW_LINE DEDENT print ( N - K + 1 , end = \"   \" ) NEW_LINE DEDENT N = 10 NEW_LINE K = 4 NEW_LINE printNumbers ( N , K ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3"}
{"value":"] def getNthSteppingNumber ( N ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( 1 ) NEW_LINE q . append ( 2 ) NEW_LINE q . append ( 3 ) NEW_LINE q . append ( 4 ) NEW_LINE q . append ( 5 ) NEW_LINE q . append ( 6 ) NEW_LINE q . append ( 7 ) NEW_LINE q . append ( 8 ) NEW_LINE q . append ( 9 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT x = q [ 0 ] NEW_LINE del q [ 0 ] NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT if ( x % 10 != 9 ) : NEW_LINE INDENT q . append ( 10 * x + ( x % 10 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( 10 * x + ( x % 10 ) - 1 ) NEW_LINE DEDENT DEDENT"}
{"value":"] \\n import math NEW_LINE def getNearest ( N ) : NEW_LINE INDENT x = math . sqrt ( N ) NEW_LINE x = math . floor ( x ) NEW_LINE x = math . pow ( x , 2 ) NEW_LINE y = math . ceil ( x ) NEW_LINE y = math . pow ( y , 2 ) NEW_LINE if ( abs ( N - x ) < abs ( N - y ) ) : NEW_LINE INDENT return ( N - x ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( y - N ) NEW_LINE DEDENT DEDENT N = 15 NEW_LINE print ( getNearest ( N ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW"}
{"value":", 0.5 ] NEW_LINE def pi_value ( N ) : NEW_LINE INDENT pi = 4 * ( 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798096734694 ) NEW_LINE print ( pi ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 50 NEW_LINE pi_value ( N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW"}
{"value":"] \\n from math import log2 NEW_LINE def binary ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a . append ( n % 2 ) NEW_LINE n \/\/= 2 NEW_LINE DEDENT return a NEW_LINE DEDENT def decimal ( arr ) : NEW_LINE INDENT n = 0 NEW_LINE for i in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT n += arr [ i ] * pow ( 2 , len ( arr ) - i - 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT def concatenate ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE a = binary ( a ) NEW_LINE b = binary ( b ) NEW_LINE if ( n < k ) : NEW_LINE INDENT a . append ( 0 ) NEW_LINE for i in range ( k - n ) : NEW_LINE INDENT a"}
{"value":"] \\n MAX = 100000 NEW_LINE res = [ 0 ] * MAX NEW_LINE def precompute ( ) : NEW_LINE INDENT res [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * i NEW_LINE DEDENT DEDENT def performQueries ( n ) : NEW_LINE INDENT precompute ( ) NEW_LINE q = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 2 ] , [ 4 , 3 ] ] NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT print ( res [ q [ i ] [ 1 ] ] \/\/ res [ q [ i ] [ 0 ] ] ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE performQueries ( n ) NEW_LINE 1 , 2 NEW_LINE 2 , 2 NEW_LINE 3 , 2 NEW_LINE 4 , 3 NEW_LINE 5 ,"}
{"value":"] \\n from math import gcd NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def countDivisibles ( a , b , c , num ) : NEW_LINE INDENT return ( ( num \/\/ a ) + ( num \/\/ b ) + ( num \/\/ c ) - ( num \/\/ gcd ( a , b ) ) - ( num \/\/ gcd ( b , c ) ) - ( num \/\/ gcd ( a , c ) ) ) NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 NEW_LINE high = 10 ** 18 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( countDivisibles ( a , b , c , mid ) < n ) : NEW_LINE INDENT"}
{"value":"] \\n def checkAngle ( n , i , j , k ) : NEW_LINE INDENT x = abs ( j - i ) NEW_LINE y = abs ( k - j ) NEW_LINE if ( x >= n or y >= n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x > y ) : NEW_LINE INDENT angle = ( 360 * x ) \/ n NEW_LINE DEDENT else : NEW_LINE INDENT angle = ( 360 * y ) \/ n NEW_LINE DEDENT if ( angle >= 180 ) : NEW_LINE INDENT angle = 360 - angle NEW_LINE DEDENT if ( angle >= 180 - ( 180 \/ 360 ) * ( j - i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 10 NEW_LINE i = 2 NEW_LINE j = 4 NEW_LINE k = 7 NEW_LINE if ( checkAngle ( n"}
{"value":"] def findLoss ( x , y ) : NEW_LINE INDENT return x - y NEW_LINE DEDENT x = 50 NEW_LINE y = 40 NEW_LINE print ( findLoss ( x , y ) ) NEW_LINE 2 NEW_LINE 5 NEW_LINE 10 NEW_LINE 15 NEW_LINE 20 NEW_LINE 25 NEW_LINE 30 NEW_LINE 35 NEW_LINE 40 NEW_LINE 45 NEW_LINE 50 NEW_LINE 55 NEW_LINE 60 NEW_LINE 65 NEW_LINE 70 NEW_LINE 75 NEW_LINE 80 NEW_LINE 85 NEW_LINE 90 NEW_LINE 95 NEW_LINE 100 NEW_LINE 105 NEW_LINE 110 NEW_LINE 115 NEW_LINE 120 NEW_LINE 125 NEW_LINE 130 NEW_LINE 135 NEW_LINE 140 NEW_LINE 145 NEW_LINE "}
{"value":"NEW_LINE MAXN = 100000 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE hash = { } NEW_LINE def Sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN + 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN + 1 , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN + 1 , 2 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN + 1 , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def storePrimeFactors ( ) : NEW_"}
{"value":"] \\n def noOfWays ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE ans *= ( 2 * n - 1 ) NEW_LINE ans *= ( 2 * n - 3 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( noOfWays ( n ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 6 NEW_LINE 10 NEW_LINE 15 NEW_LINE 21 NEW_LINE 28 NEW_LINE 36 NEW_LINE 45 NEW_LINE 55 NEW_LINE 66 NEW_LINE 78 NEW_LINE 91 NEW_LINE 105 NEW_LINE 120 NEW_LINE 136 NEW_LINE 153 NEW_LINE 171 NEW_LINE 190 NEW_LINE 210 NEW_LINE 231 NEW_LINE 253 NEW_LINE 276 NEW_LINE 300"}
{"value":"] \\n N = 10 NEW_LINE mat = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE mat [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT mat [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i - 1 ] [ j - 1 ] + mat [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return mat [ n ] [ r ] NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE 1 NEW_LINE "}
{"value":"] def minDiff ( n ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT n = 10 NEW_LINE print ( minDiff ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_"}
{"value":"] \\n def check ( n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last = n % 10 NEW_LINE count [ last ] += 1 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT n = 123 NEW_LINE check ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE "}
{"value":"] \\n def printNlines ( K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( i + 1 , end = \"   \" ) NEW_LINE print ( i + 2 , end = \"   \" ) NEW_LINE print ( i + 3 , end = \"   \" ) NEW_LINE print ( i + 4 , end = \"   \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 1 NEW_LINE printNlines ( K ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE"}
{"value":"] \\n def sumOfSeries ( n ) : NEW_LINE INDENT return ( n * ( 4 * n * n + 6 * n - 1 ) ) \/ 3 NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum   of   n   terms   is   :   \" , sumOfSeries ( n ) ) NEW_LINE 1 , 3 , 5 , 9 , 17 , 33 , 65 , 129 , 257 , 513 , 1025 [\/INST] 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 , 22 , 24 [\/INST] 3 , 6 , 9 , 12 , 15 , 18 , 21 , 24 , 27 , 30 , 33 [\/INST] 4 , 8 , 12 , 16 , 20 , 24 , 28 , 32 ,"}
{"value":"] \\n MAX = 100 NEW_LINE def countSpecialStrings ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( MAX ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] + fib [ i - 2 ] ) NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( countSpecialStrings ( n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 5 NEW_LINE 8 NEW_LINE 13 NEW_LINE 21 NEW_LINE 34 NEW_LINE 55 NEW_LINE 89 NEW_LINE 144 NEW_LINE 233 NEW_LINE 377 NEW_LINE 610 NEW_LINE 987 NEW_LINE 1"}
{"value":"] \\n def countPaths ( arr , i , j , m , n ) : NEW_LINE INDENT if ( i == m - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( i >= m or j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( countPaths ( arr , i + arr [ i ] [ j ] , j + arr [ i ] [ j ] , m , n ) + countPaths ( arr , i + 1 , j , m , n ) + countPaths ( arr , i , j + 1 , m , n ) ) NEW_LINE DEDENT arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( countPaths ( arr , 0 , 0 , 3 , 3 ) ) NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE"}
{"value":"] \\n def countPaths ( arr , n , k ) : NEW_LINE INDENT if ( arr [ n - 1 ] == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( i + j > n ) : NEW_LINE INDENT break NEW_LINE DEDENT dp [ i ] += dp [ i + j ] NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( countPaths ( arr , n , k ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE "}
{"value":"] \\n def countOddEven ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return ( count_even * count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countOddEven ( arr , n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 2 NEW_"}
{"value":"] \\n import numpy as np NEW_LINE def toVector ( N ) : NEW_LINE INDENT digits = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digits . append ( N % 10 ) NEW_LINE N \/\/= 10 NEW_LINE DEDENT if ( N == 0 ) : NEW_LINE INDENT digits . append ( 0 ) NEW_LINE DEDENT digits . reverse ( ) NEW_LINE return digits NEW_LINE DEDENT def countNumbers ( A , B , C ) : NEW_LINE INDENT digit = toVector ( C ) NEW_LINE if ( len ( digit ) < B ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( digit ) == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT lower = np . zeros ( B + 1 ) NEW_LINE lower [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT if ( digit [ i - 1 ]"}
{"value":"] import math NEW_LINE def countPaths ( wt , n , M ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT used = False NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( wt - i >= 0 ) : NEW_LINE INDENT used = True NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return countPaths ( wt - M , n , M ) + countPaths ( wt - n , n , M ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE M = 2 NEW_LINE W = 10 NEW_LINE print ( countPaths ( W , N , M ) ) NEW_LINE DEDENT 1 NEW_LINE 2"}
{"value":"] \\n def countPartitions ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT return countPartitions ( n - 1 ) + countPartitions ( n - 2 ) + countPartitions ( n - 3 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( countPartitions ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE "}
{"value":"] \\n import numpy as np NEW_LINE def longestIncreasingPath ( matrix , m , n , dp ) : NEW_LINE INDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( m == 0 and n == ( n - 1 ) ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == 0 and n == n ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == m and n == 0 ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == m and n == ( n - 1 ) ) : NEW_LINE INDENT dp [ m ] [ n ] = 1 NEW_LINE return 1 NEW_LINE DEDENT if ( m == ( m - 1 ) and n == 0"}
{"value":"] def countPaths ( x , y ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( x == 0 ) : NEW_LINE INDENT return countPaths ( y - 1 , y ) NEW_LINE DEDENT elif ( y == 0 ) : NEW_LINE INDENT return countPaths ( x - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( countPaths ( x - 1 , y ) + countPaths ( x , y - 1 ) ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE y = 3 NEW_LINE print ( countPaths ( x , y ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE"}
{"value":"] \\n def goldMine ( grid , n , m ) : NEW_LINE INDENT goldMineTable = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT goldMineTable [ i ] [ 0 ] = grid [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT goldMineTable [ 0 ] [ i ] = max ( grid [ 0 ] [ i ] , goldMineTable [ 0 ] [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT goldMineTable [ i ] [ j ] = max ( grid [ i ] [ j ] + max ( goldMineTable [ i - 1 ] [ j - 1 ] , goldMineTable [ i - 1 ] [ j ] , goldMineTable [ i - 1"}
{"value":"] NEW_LINE import sys NEW_LINE def minAdjustmentCost ( A , M , N , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = sys . maxsize NEW_LINE DEDENT dp [ 0 ] [ A [ 0 ] ] = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - k ) ) NEW_LINE DEDENT DEDENT D"}
{"value":"] def countTriplets ( L , R ) : NEW_LINE INDENT total = 0 NEW_LINE diff = R - L NEW_LINE if ( diff % 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT total = ( diff \/\/ 3 ) * ( diff \/\/ 3 + 1 ) \/\/ 2 NEW_LINE return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 1 NEW_LINE R = 10 NEW_LINE print ( countTriplets ( L , R ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 12 NEW_LINE 14 NEW_LINE 16 NEW_LINE 18 NEW_LINE 20 NEW_LINE 22 NEW_LINE 24 NEW_LINE 26 NEW_LINE 28 NEW_LINE 30 NEW_LINE 1 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE"}
{"value":"] def constructArrays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( 2 * n ) NEW_LINE B = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT A [ i - 1 ] = i NEW_LINE B [ i - 1 ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = \"   \" ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE constructArrays ( N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW"}
{"value":"] \\n def flipCommonBits ( A , B ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A & ( ~ ( 1 << i ) ) NEW_LINE B = B & ( ~ ( 1 << i ) ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 10 NEW_LINE B = 15 NEW_LINE flipCommonBits ( A , B ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE"}
{"value":"NT def countDistinctSum ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += a [ i ] + b [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE b = [ 5 , 6 , 7 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( countDistinctSum ( a , b , n ) ) NEW_LINE 1 NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW"}
{"value":"] def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT freq [ 0 ] += 1 NEW_LINE DEDENT elif ( str [ i ] == '1' ) : NEW_LINE INDENT freq [ 1 ] += 1 NEW_LINE DEDENT elif ( str [ i ] == '2' ) : NEW_LINE INDENT freq [ 2 ] += 1 NEW_LINE DEDENT DEDENT if ( freq [ 0 ] and freq [ 1 ] and freq [ 2 ] ) : NEW_LINE INDENT count = ( freq [ 0 ] * freq [ 1 ] * freq [ 2 ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"10022"}
{"value":"] def minOperations ( s ) : NEW_LINE INDENT count = 0 NEW_LINE n = len ( s ) NEW_LINE if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] and s [ i + 1 ] == s [ i + 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \"10010100\" NEW_LINE print ( minOperations ( s ) ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE"}
{"value":"] \\n def convertToHex ( n ) : NEW_LINE INDENT return \" { 0 : X } \" . format ( n ) NEW_LINE DEDENT def encryptString ( S ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT count = 1 NEW_LINE ch = S [ i ] NEW_LINE while ( i < len ( S ) and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE ans += ch NEW_LINE ans += convertToHex ( count ) NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" aabbbc \" NEW_LINE print ( encryptString ( S ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6"}
{"value":"] def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countStrings ( N ) : NEW_LINE INDENT total = binomialCoeff ( 2 , N ) NEW_LINE equal = binomialCoeff ( 2 , N \/\/ 2 ) NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT return total - equal NEW_LINE DEDENT else : NEW_LINE INDENT return total NEW_LINE DEDENT DEDENT N = 5 NEW_LINE print ( countStrings ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE"}
{"value":"] \\n def removeChar ( str , ch ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT if ( str [ 0 ] == ch ) : NEW_LINE INDENT return removeChar ( str [ 1 : ] , ch ) NEW_LINE DEDENT else : NEW_LINE INDENT return str [ 0 ] + removeChar ( str [ 1 : ] , ch ) NEW_LINE DEDENT DEDENT str = \" geeksforgeeks \" NEW_LINE ch = ' e ' NEW_LINE print ( removeChar ( str , ch ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE "}
{"value":"] \\n def isValidTime ( s ) : NEW_LINE INDENT if ( s [ 0 ] == ' ? ' or s [ 1 ] == ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s [ 2 ] == ' ? ' or s [ 3 ] == ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s [ 0 ] == '2' and s [ 1 ] == '3' and s [ 2 ] == '5' and s [ 3 ] == '9' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def checkDifference ( s ) : NEW_LINE INDENT if ( abs ( ( ord ( s [ 0 ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ 1 ] ) - ord ( '0' ) ) - ( ord ( s [ 2 ] ) - ord ( '0' ) ) * 10 - ( ord ( s [ 3 ] ) - ord ( '0' )"}
{"value":"NT def check ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) : NEW_LINE INDENT if ( len ( st ) > 0 and st [ - 1 ] == str [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT str = \" abab \" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE str = \" abac \" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE str = \" aba \" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE str = \" abac \" NEW_LINE check ( str ) NEW_LINE 2 NEW_LINE 2 NEW_LINE "}
{"value":"] NEW_LINE from collections import defaultdict NEW_LINE def countStrings ( arr1 , arr2 , n , m ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE res = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = arr1 [ i ] NEW_LINE temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) < 26 ) : NEW_LINE INDENT temp += 1 << ( ord ( s [ j ] ) - ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT freq [ temp ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT s = arr2 [ i ] NEW_LINE temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) < 2"}
{"value":"] def printBinary ( s , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count = 0 NEW_LINE while ( i < n and s [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT s = list ( s ) NEW_LINE s [ i - count + j ] = '1' NEW_LINE s = ' ' . join ( s ) NEW_LINE DEDENT print ( s ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"1010001\" NEW_LINE n = len ( s ) NEW_LINE printBinary ( s , n ) NEW_LINE DEDENT 1 NEW_LINE 0 NEW_LINE 1 NEW_LINE "}
{"value":"] def camelToSentence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ord ( s [ i ] ) >= 65 and ord ( s [ i ] ) <= 90 ) : NEW_LINE INDENT print ( \"   \" , end = \" \" ) NEW_LINE print ( chr ( ord ( s [ i ] ) + 32 ) , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" GeeksForGeeks \" NEW_LINE camelToSentence ( s ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5"}
{"value":"] \\n def countOccurrences ( n , k , s ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % len ( s ) != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n \/\/ len ( s ) ) * ( len ( s ) - 1 ) + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE k = 2 NEW_LINE s = \" aa \" NEW_LINE print ( countOccurrences ( n , k , s ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE DEDENT 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE"}
{"value":"] def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT for j in range ( count [ i ] ) : NEW_LINE INDENT print ( i , end = \"   \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 6 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 5 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 1 NEW_"}
{"value":"] def check ( s , m ) : NEW_LINE INDENT n = len ( s ) NEW_LINE zeros = 0 NEW_LINE ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros >= m ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ones >= m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = \"000011111\" NEW_LINE m = 4 NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE "}
{"value":"] def productOfDigits ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE level = 1 NEW_LINE while ( level < k ) : NEW_LINE INDENT level += 1 NEW_LINE ans *= n NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT ans *= n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 1234 NEW_LINE k = 2 NEW_LINE print ( productOfDigits ( n , k ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 24 NEW_LINE 32 NEW_LINE 48 NEW_LINE 64 NEW_LINE 123 NEW_LINE 246 NEW_LINE 492 NEW_LINE 984 NEW_LINE 1968 NEW_LINE 3936 NEW_LINE 78"}
{"value":"] def removeDuplicates ( a , n ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( isPresent [ i ] [ j ] == False ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if ( a [ i ] [ k ] == a [ i ] [ j ] ) : NEW_LINE INDENT isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT if ( a [ k ] [ j ] == a [ i ] [ j ] ) : NEW_LINE INDENT isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT if ( isPresent [ i ] [ j ] == False and isPresent [ j ] [ i ] == False ) : NEW_LINE INDENT print ( a [ i ] ["}
{"value":"] \\n def isValidISBN ( ISBN ) : NEW_LINE INDENT if ( len ( ISBN ) != 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , 9 ) : NEW_LINE INDENT sum += ( ( ord ( ISBN [ i ] ) - ord ( '0' ) ) * ( 10 - i ) ) NEW_LINE DEDENT if ( ( sum % 11 == 0 and ISBN [ 9 ] == 'X' ) or ( sum % 11 == 10 and ISBN [ 9 ] == '0' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT ISBN = \" 9780131423950 \" NEW_LINE if ( isValidISBN ( ISBN ) ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT"}
{"value":"] def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def reverseVowels ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE vowels = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT vowels . append ( str [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT str [ i ] = vowels [ - 1 ] NEW_LINE vowels . pop ( ) NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksfor"}
{"value":"] \\n def findString ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE v = False NEW_LINE output = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '   ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( v == True ) : NEW_LINE INDENT output += s [ i ] NEW_LINE v = False NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" Geeks   for   Geeks \" NEW_LINE print ( findString ( s ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW"}
{"value":"] def dfs ( i , j , vis , ans , z , z_count , graph ) : NEW_LINE INDENT vis [ i ] [ j ] = True NEW_LINE z += 1 NEW_LINE if ( i == graph [ 0 ] [ 0 ] and j == graph [ 0 ] [ 0 ] ) : NEW_LINE INDENT ans . append ( z ) NEW_LINE return NEW_LINE DEDENT if ( z == z_count ) : NEW_LINE INDENT ans . append ( z ) NEW_LINE return NEW_LINE DEDENT if ( i > 0 and graph [ i - 1 ] [ j ] and not vis [ i - 1 ] [ j ] ) : NEW_LINE INDENT dfs ( i - 1 , j , vis , ans , z , z_count , graph ) NEW_LINE DEDENT if ( i < graph [ 0 ] [ 0 ] and graph [ i + 1 ] [ j ] and not vis [ i + 1 ] [ j ] ) : NEW_LINE INDENT dfs ( i + 1 , j , vis , ans"}
{"value":"] \\n def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT right = n - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= 2 * arr [ right ] ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT ans += right - i NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 2 , 1 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1"}
{"value":"] \\n def area_square ( side ) : NEW_LINE INDENT area = ( side * side ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT side = 5 NEW_LINE print ( area_square ( side ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_"}
{"value":"] \\n N = 3 NEW_LINE M = 2 NEW_LINE def maxPoints ( points ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT x1 , y1 = points [ i ] NEW_LINE x2 , y2 = points [ j ] NEW_LINE if ( x1 == x2 and y1 == y2 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = ( y2 - y1 ) \/ ( x2 - x1 ) NEW_LINE for m in range ( M ) : NEW_LINE INDENT x3 , y3 = points [ m ] NEW_LINE if ( ( k * x3 - y3 ) == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"}
{"value":"] \\n def icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 18 * n ) \/\/ 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( \"5 - th   icosihenagonal   number   is   =   \" , icosihenagonal_num ( n ) ) NEW_LINE 5 - th icosihenagonal number is   =   43 NEW_LINE 2 NEW_LINE 4 NEW_LINE 7 NEW_LINE 11 NEW_LINE 16 NEW_LINE 22 NEW_LINE 30 NEW_LINE 39 NEW_LINE 49 NEW_LINE 61 NEW_LINE 75 NEW_LINE 91 NEW_LINE 109 NEW_LINE 130 NEW_LINE 154 NEW_LINE 181 NEW_LINE 211 NEW_LINE 245 NEW_LINE 283 NEW_LINE 325 NEW_LINE 372 NEW_LINE 424 NEW_LINE 482 NEW_LINE"}
{"value":"] \\n def findCentroid ( x , y , n ) : NEW_LINE INDENT A = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT A += ( x [ i + 1 ] * y [ i ] - x [ i ] * y [ i + 1 ] ) NEW_LINE DEDENT xCentroid = A \/ ( 6.0 * n ) NEW_LINE yCentroid = A \/ ( 6.0 * n ) NEW_LINE print ( \" Centroid   =   ( \" , xCentroid , \" ,   \" , yCentroid , \" ) \" ) NEW_LINE DEDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 4 , 5 , 6 ] NEW_LINE n = len ( x ) NEW_LINE findCentroid ( x , y , n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE"}
{"value":"] \\n def angles ( a , b , c ) : NEW_LINE INDENT x = a + b + c NEW_LINE print ( \" Angles   are   : \" ) NEW_LINE print ( \" A   = \" , x \/ 2 ) NEW_LINE print ( \" B   = \" , x \/ 2 ) NEW_LINE print ( \" C   = \" , x \/ 2 ) NEW_LINE DEDENT a = 30 NEW_LINE b = 40 NEW_LINE c = 120 NEW_LINE angles ( a , b , c ) NEW_LINE 3 ; NEW_LINE 4 ; NEW_LINE 120 NEW_LINE 1 \/ 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2"}
{"value":"] \\n import math NEW_LINE def distance ( a , b , c , d , e , f ) : NEW_LINE INDENT return ( abs ( ( a * e - b * d ) \/ math . sqrt ( ( a * a + b * b ) ) ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE e = 5 NEW_LINE f = 6 NEW_LINE print ( distance ( a , b , c , d , e , f ) ) NEW_LINE 1 , 2 , 3 , 4 , 5 , 6 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 1 NEW_LINE 2 NEW_LINE "}
{"value":"] def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def countWays ( N ) : NEW_LINE INDENT ans = fact ( N ) \/\/ fact ( N \/\/ 2 ) NEW_LINE ans = ans \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE "}
{"value":"] def check ( S , D ) : NEW_LINE INDENT V = [ 0 for i in range ( 1000005 ) ] NEW_LINE V [ 0 ] = S % D NEW_LINE for i in range ( 1 , 1000005 ) : NEW_LINE INDENT V [ i ] = ( V [ i - 1 ] + V [ i - 1 ] % D ) % D NEW_LINE if ( V [ i ] in V [ 0 : i ] ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT V [ i ] = V [ i ] NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 100 NEW_LINE D = 1000 NEW_LINE print ( check ( S , D ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE "}
{"value":"] def countSteps ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 1 and y != 1 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT count += 1 NEW_LINE x -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE y -= 1 NEW_LINE DEDENT DEDENT if ( x > 1 and y > 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 3 NEW_LINE Y = 4 NEW_LINE countSteps ( X , Y ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE"}
{"value":"] \\n def countReversals ( expr ) : NEW_LINE INDENT m = len ( expr ) NEW_LINE if ( m % 2 != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = m \/\/ 2 NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( expr [ i ] == ' ( ' ) : NEW_LINE INDENT s . append ( ' ( ' ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( ' ) ' ) NEW_LINE DEDENT DEDENT for i in range ( n , m ) : NEW_LINE INDENT if ( expr [ i ] == ' ( ' ) : NEW_LINE INDENT s . append ( ' ( ' ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( ' ) ' ) NEW_LINE DEDENT DEDENT red_len = ( m + n ) NEW_LINE c = 0 NEW_LINE for i in range ( red_len ) : NEW_LINE INDENT if ("}
{"value":"] \\n def minimumNumber ( input , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE last_entry = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if ( input [ i ] == ' I ' ) : NEW_LINE INDENT noOfNextD = current_max NEW_LINE DEDENT else : NEW_LINE INDENT noOfNextD = last_entry NEW_LINE DEDENT if ( input [ i ] == ' I ' and i == 0 ) : NEW_LINE INDENT current_max += 1 NEW_LINE print ( current_max , end = \" \" ) NEW_LINE DEDENT elif ( input [ i ] == ' I ' ) : NEW_LINE INDENT print ( current_max + 1 , end = \" \" ) NEW_LINE current_max += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( noOfNextD == 0 ) : NEW_LINE INDENT print ( last_entry , end = \" \" ) NEW_LINE D"}
{"value":"] \\n def findMinimumNumber ( str ) : NEW_LINE INDENT min_avail = 0 NEW_LINE pos_of_I = - 1 NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' I ' ) : NEW_LINE INDENT pos_of_I = i NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( min_avail ) NEW_LINE min_avail -= 1 NEW_LINE DEDENT DEDENT for i in range ( pos_of_I + 1 ) : NEW_LINE INDENT ans . append ( min_avail ) NEW_LINE min_avail -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" DIDI \" NEW_LINE findMinimumNumber ( str"}
{"value":"] \\n def decode ( seq ) : NEW_LINE INDENT result = \" \" NEW_LINE stack = [ ] NEW_LINE n = len ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if ( seq [ i ] == ' ? ' or i == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT while ( len ( stack ) != 0 ) : NEW_LINE INDENT result += str ( stack [ - 1 ] ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT seq = \" ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?"}
{"value":"] \\n def minNum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE rank = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT rank [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT rank [ ord ( s [ i ] ) - ord ( '0' ) ] = i + 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT ans += chr ( ord ( '0' ) + rank [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \"1234567890\" NEW_LINE print ( minNum ( s ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_"}
{"value":"] \\n def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def smallestNumber ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 0 , 10 ) :"}
{"value":"T ] def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def isNonTransitive ( L , R ) : NEW_LINE INDENT for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( a , b ) == 1 ) : NEW_LINE INDENT for c in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( b , c ) == 1 and gcd ( a , c ) != 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 2 NEW_LINE R = 10 NEW_LINE if ( isNon"}
{"value":"] import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT cuberoot = int ( math . cbrt ( a * b ) ) NEW_LINE if ( a % cuberoot == 0 and b % cuberoot == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT a = 20 NEW_LINE b = 48 NEW_LINE check ( a , b ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE "}
{"value":"] \\n def isUndulating ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( rem % 2 == 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE DEDENT else : NEW_LINE INDENT rem = temp % 10 NEW_LINE DEDENT if ( rem != 0 and rem != 5 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 125 NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 25 NEW_LINE 222 NEW_LINE 111 NEW_LINE 122 NEW_LINE 222 NEW_LINE 2"}
{"value":"] def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum   of   the   series   is   \" , calculateSum ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28"}
{"value":"] \\n def countDigit ( k , n , m ) : NEW_LINE INDENT return ( ( m - n + 1 ) - ( ( ( n - 1 ) \/\/ 10 ) - ( m \/\/ 10 ) ) ) NEW_LINE DEDENT n = 100 NEW_LINE m = 1000 NEW_LINE k = 0 NEW_LINE print ( countDigit ( k , n , m ) ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW"}
{"value":"] \\n def divisibleSum ( l , r ) : NEW_LINE INDENT n = ( r \/\/ 6 ) NEW_LINE m = ( l - 1 ) \/\/ 6 NEW_LINE sum1 = ( n * ( n + 1 ) * 6 ) \/\/ 2 NEW_LINE sum2 = ( m * ( m + 1 ) * 6 ) \/\/ 2 NEW_LINE return ( sum1 - sum2 ) NEW_LINE DEDENT l = 6 NEW_LINE r = 15 NEW_LINE print ( divisibleSum ( l , r ) ) NEW_LINE 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_"}
{"value":"] NEW_LINE def largestSmaller ( str ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( str ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT str = list ( str ) NEW_LINE str [ index ] , str [ index + 1 ] = str [ index + 1 ] , str [ index ] NEW_LINE return \" \" \" . join ( str ) NEW_LINE DEDENT DEDENT str = \"12345\" NEW_LINE print ( largestSmaller ( str ) NEW_LINE 1 NEW_LINE 0 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW"}
{"value":"] def horner ( poly , n ) : NEW_LINE INDENT result = poly [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT result = result * x + poly [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT def sign ( poly , n ) : NEW_LINE INDENT return horner ( poly , n ) >= 0 NEW_LINE DEDENT x = 3 NEW_LINE poly = [ 2 , - 6 , 2 , - 1 ] NEW_LINE n = len ( poly ) NEW_LINE if ( sign ( poly , n ) ) : NEW_LINE INDENT print ( \" Positive \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Negative \" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_"}
{"value":"] \\n import math NEW_LINE def sieveOfEratostheneses ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT return prime NEW_LINE DEDENT def findMinimumNumber ( arr , n ) : NEW_LINE INDENT prime = sieveOfEratostheneses ( 1000000 ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( prime [ sum ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = sum NEW_LINE while ( not prime [ num ]"}
{"value":"] \\n def printSubArraySum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT sum = sum + arr [ k ] ; NEW_LINE DEDENT print ( \" Sum   of   subarray   from   \" , i , \"   to   \" , j , \"   is   \" , sum , sep = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printSubArraySum ( arr , n ) ; NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_"}
{"value":"] \\n def findPower ( n ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE power += 1 NEW_LINE DEDENT return power NEW_LINE DEDENT n = 15 NEW_LINE print ( findPower ( n ) ) NEW_LINE 3 NEW_LINE 5 NEW_LINE 12 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 20 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 36 NEW_LINE 37 NEW_LINE 40 NEW_LINE 48 NEW_LINE 49 NEW_LINE 50 NEW_LINE 51 NEW_LINE 52 NEW_LINE 53 NEW_LINE 54 NEW_LINE 55 NEW_LINE 56 NEW"}
{"value":"] \\n def mod ( a , m ) : NEW_LINE INDENT while ( a > m ) : NEW_LINE INDENT a -= m NEW_LINE DEDENT return a NEW_LINE DEDENT def findPower ( a , b , m ) : NEW_LINE INDENT ans = 1 NEW_LINE a = mod ( a , m ) NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT ans = ( ans * a ) % m NEW_LINE DEDENT b = b \/ 2 NEW_LINE a = ( a * a ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT a = \"1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"value":"] NEW_LINE class DataPoint : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def interpolate ( x , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT term = ( x - DataPoint ( 0 , 0 ) . x ) * ( DataPoint ( i , 0 ) . x ) NEW_LINE term = term \/ ( DataPoint ( i , 0 ) . x - x ) NEW_LINE term = term * ( DataPoint ( i , 0 ) . y ) NEW_LINE result = result + term NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT data = [ ] NEW_LINE data . append ( DataPoint ( 0 , 0 ) ) NEW_LINE data . append ( DataPoint ( 1 , 1 ) ) NEW_LINE data . append ("}
{"value":"] def printPrimes ( n ) : NEW_LINE INDENT n = int ( n \/ 2 ) NEW_LINE marked = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 2 * i - 1 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT print ( 2 , end = \"   \" ) NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT if ( not marked [ i ] ) : NEW_LINE INDENT print ( i , end = \"   \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT n = 10 NEW_LINE printPrimes ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE 9 NEW_LINE 11 NEW"}
{"value":"T ] NEW_LINE def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N NEW_LINE X = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT X ^= A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT B [ i ] = X ^ A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( A ) NEW_LINE K = 1 NEW_LINE constructArray ( A , N , K ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW"}
{"value":"] def findExtra ( A , B , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = result ^ A [ i ] ^ B [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE B = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE n = len ( A ) NEW_LINE print ( findExtra ( A , B , n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 2"}
{"value":"] def hammingDistance ( a , b ) : NEW_LINE INDENT return bin ( a ^ b ) . count ( '1' ) NEW_LINE DEDENT a = 10 NEW_LINE b = 7 NEW_LINE print ( hammingDistance ( a , b ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE "}
{"value":"] def bitwiseAndSet ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) : NEW_LINE INDENT result = result | ( 1 << i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE print ( bitwiseAndSet ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 128 NEW_LINE 256 NEW_LINE 512 NEW_LINE 1024 NEW_LINE 2048 NEW_LINE 4096 NEW_LINE 8192 NEW_LINE 16384 NEW_LINE 32768 NEW_LINE 65536 NEW_LINE 131072 NEW_LINE 262144 NEW_LINE 524288 NEW"}
{"value":"] \\n def findMSB ( n ) : NEW_LINE INDENT k = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return ( 1 << ( k - 1 ) ) NEW_LINE DEDENT n = 20 NEW_LINE print ( findMSB ( n ) ) NEW_LINE 2 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE "}
{"value":"] \\n def countSubsets ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( n \/\/ arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 3 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubsets ( arr , n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW"}
{"value":"] def countSubsets ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 1 NEW_LINE for i in mp : NEW_LINE INDENT res *= ( mp [ i ] + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubsets ( arr , n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10"}
{"value":"] NEW_LINE dp = [ [ 0 for i in range ( 1000000 ) ] for i in range ( 1000000 ) ] NEW_LINE def preCalculate ( ) : NEW_LINE INDENT for i in range ( 1 , 1000000 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - j * j ] [ j - 1 ] + dp [ i - j * j ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT if ( N == 4"}
{"value":"] \\n sum = 0 NEW_LINE def findSum ( root , target ) : NEW_LINE INDENT global sum NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT p = [ 0 , 0 ] NEW_LINE p [ 0 ] = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE findSum ( root . left , target ) NEW_LINE p [ 0 ] += 1 NEW_LINE p [ 1 ] += 1 NEW_LINE if ( root . data == target ) : NEW_LINE INDENT sum += ( p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ] - 2 * p [ 0 ] * p [ 1 ] ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT p [ 0 ] = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE findSum ( root . right , target ) NEW_LINE sum += ( p [ 0 ] * p [ 0 ] + p [ 1 ]"}
{"value":"] def rearrange ( a , b , n , k ) : NEW_LINE INDENT b . sort ( reverse = True ) NEW_LINE if ( b [ 0 ] > k ) : NEW_LINE INDENT print ( \" Not   possible \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE b = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE rearrange ( a , b , n , k ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11"}
{"value":"] def countRows ( mat , n ) : NEW_LINE INDENT row = n NEW_LINE col = n NEW_LINE ans = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT sum_row = 0 NEW_LINE for j in range ( col ) : NEW_LINE INDENT sum_row += mat [ i ] [ j ] NEW_LINE DEDENT if ( sum_row > sum - sum_row ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE countRows ( mat , 3 ) NEW_LINE 2 NEW_LINE 3 NEW_LINE"}
{"value":"] def check ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] and arr [ i ] != arr [ i - 1 ] + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( check ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE "}
{"value":"] \\n def areContiguous ( arr , n ) : NEW_LINE INDENT m = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT m = m + 1 NEW_LINE l = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = min ( l , arr [ i ] ) NEW_LINE DEDENT if ( m - l < n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ arr [ i ] ] = True NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ]"}
{"value":"] \\n def isContiguous ( arr , n ) : NEW_LINE INDENT us = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us [ arr [ i ] ] = 1 NEW_LINE DEDENT if ( us [ arr [ 0 ] - 1 ] == 1 ) : NEW_LINE INDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while ( us [ curr_ele ] == 1 ) : NEW_LINE INDENT if ( us [ curr_ele + 1 ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( us [ arr [ 0 ] + 1 ] == 1 ) : NEW_LINE INDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] + 1 NEW_LINE while ( us [ curr_ele ] == 1 ) :"}
{"value":"] \\n def longestSubarray ( arr , n , k ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE cnt = 0 NEW_LINE ans = 0 NEW_LINE best = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE visited [ i ] = True NEW_LINE DEDENT if ( cnt > k ) : NEW_LINE INDENT cnt = k NEW_LINE DEDENT while ( cnt > 0 and i >= 0 ) : NEW_LINE INDENT if ( visited [ i ] ) : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i >= 0 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT if ( i + 1 < n ) : NEW_LINE INDENT visited [ i + 1 ] = True NEW_LINE DEDENT"}
{"value":"] def checkOverlap ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( [ arr [ i ] , arr [ i ] ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ 0 ] == - 1 ) : NEW_LINE INDENT s . append ( v [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( v [ i ] [ 0 ] ) NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT if ( len ( s ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT x = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE if ( len ( s ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT y = s ["}
{"value":"] \\n import sys NEW_LINE ptr = [ 0 for i in range ( 100 ) ] NEW_LINE def findRange ( list1 , n , k ) : NEW_LINE INDENT ptr = [ 0 for i in range ( k ) ] NEW_LINE index = 0 NEW_LINE while ( True ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == len ( list1 [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT min = sys . maxsize NEW_LINE max = - sys . maxsize - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT min = min ( min , list1 [ i ] [ ptr [ i ] ] ) NEW_LINE max = max ( max , list1 [ i ] [ ptr [ i ] ] ) NEW_LINE DEDENT"}
{"value":"] \\n def findLargestD ( S , n ) : NEW_LINE INDENT S . sort ( ) NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT j = i + 1 NEW_LINE k = n - 1 NEW_LINE l = n - 2 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( S [ i ] == ( S [ j ] + S [ k ] + S [ l ] ) ) : NEW_LINE INDENT return S [ i ] NEW_LINE DEDENT if ( S [ i ] < ( S [ j ] + S [ k ] + S [ l ] ) ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE l -= 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT S = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( S ) NEW_LINE print ("}
{"value":"] \\n def findFourElements ( arr , n , X ) : NEW_LINE INDENT s = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT s [ arr [ i ] + arr [ j ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT c = X - arr [ i ] - arr [ j ] - arr [ k ] NEW_LINE if c in s : NEW_LINE INDENT print ( \" a   = \" , arr [ i ] , \" ,   b   = \" , arr [ j ] , \" ,   c   = \" , arr [ k ] , \" ,   d   = \" , c ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 4 ,"}
{"value":"] def countElements ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum >= k ) : NEW_LINE INDENT count += 1 NEW_LINE sum = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( countElements ( arr , n , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 10 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW"}
{"value":"] def leftRotate ( arr , n , d ) : NEW_LINE INDENT temp = arr [ d ] NEW_LINE arr [ d ] = arr [ 0 ] NEW_LINE for i in range ( 1 , d ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ d ] = temp NEW_LINE DEDENT def leftRotateByD ( arr , n , d ) : NEW_LINE INDENT for i in range ( 0 , d ) : NEW_LINE INDENT leftRotate ( arr , n , 1 ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE d = 2 NEW_LINE print ( \" Before   rotation :   \" )"}
{"value":"] def sortArray ( arr , n , a , b ) : NEW_LINE INDENT start = a NEW_LINE end = b NEW_LINE temp = [ 0 ] * n NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT temp [ i - start ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i - start ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 1 , 3 , 2 , 5 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE a = 2 NEW_LINE b = 5 NEW_LINE sortArray ( arr , n , a , b ) NEW_LINE DEDENT "}
{"value":"] \\n MAX = 100 NEW_LINE def sortRow ( mat , descending ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( descending [ i ] [ j ] < descending [ i ] [ j - 1 ] ) : NEW_LINE INDENT temp = descending [ i ] [ j ] NEW_LINE descending [ i ] [ j ] = descending [ i ] [ j - 1 ] NEW_LINE descending [ i ] [ j - 1 ] = temp NEW_LINE temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE mat [ i ] [ j - 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT def getTranspose ( mat , descending ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE"}
{"value":"] def moveZeroes ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] , arr [ count ] = arr [ count ] , arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT arr = [ 1 , 0 , 3 , 0 , 0 , 7 , 2 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE moveZeroes ( arr , n ) NEW_LINE print ( \" Modified   array   is   : \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT 1 NEW_LINE 0 NEW_LINE 3 NEW_LINE 0 NEW_"}
{"value":"] def moveZeroes ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] , arr [ count ] = arr [ count ] , arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 0 , 0 , 3 , 0 , 2 , 0 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE moveZeroes ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE 2 NEW_LINE 0 NEW_LINE 0 NEW_LINE 3 NEW_LINE 0 NEW_LINE 2 NEW_LINE 0 NEW_LINE 6 NEW_LINE 12 NEW_"}
{"value":"] def pushZero ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT def modifyArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] *= 2 NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZero ( arr , n ) NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE IN"}
{"value":"] def shiftZeroes ( arr , n ) : NEW_LINE INDENT lastSeen = n - 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] , arr [ lastSeen ] = arr [ lastSeen ] , arr [ i ] NEW_LINE lastSeen -= 1 NEW_LINE DEDENT DEDENT DEDENT 1 NEW_LINE arr = [ 1 , 0 , 0 , 0 , 1 , 0 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE shiftZeroes ( arr , n ) NEW_LINE print ( arr ) NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_"}
{"value":"] def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT def rearrange ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j + 1 ] , arr [ j ] = arr [ j ] , arr [ j + 1 ] NEW_LINE DEDENT arr [ i ] , arr [ - i - 1 ] = arr [ - i - 1 ] , arr [ i ] NEW_LINE DEDENT printArr ( arr , n ) NEW_LINE DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5"}
{"value":"] def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT def reverse ( arr , l , r ) : NEW_LINE INDENT while ( l < r ) : NEW_LINE INDENT temp = arr [ l ] NEW_LINE arr [ l ] = arr [ r ] NEW_LINE arr [ r ] = temp NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE k = l NEW_LINE while ( i <= m and j <= r ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT arr [ k ] = arr [ i ] NEW"}
{"value":"] \\n def rearrange ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( i < j and arr [ i ] < 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i < j and arr [ j ] > 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end"}
{"value":"] def findWinner ( arr , n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findWinner ( arr , N ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0"}
{"value":"] \\n import math NEW_LINE def precompute ( N , arr ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N \/\/ 2 + 1 ) : NEW_LINE INDENT if ( i + j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] NEW_LINE dp [ i ] [ j ] += dp [ i + j ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumQueries ( N , arr , Q ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE precompute ( N , arr ) NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT if ( Q [ i ] [ 1 ] <= math . sqrt ( N ) ) : NEW_LINE INDENT x = Q [ i ] [ "}
{"value":"] \\n def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > 2 : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_"}
{"value":"] def findGreater ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] and arr [ i ] < arr [ i + 2 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 1 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findGreater ( arr , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE"}
{"value":"] \\n def findElements ( arr , n ) : NEW_LINE INDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( arr [ i ] < arr [ second ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ first ] or arr [ i ] == arr [ second ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( arr [ i ] < arr [ first ] or arr [ i ] < arr [ second ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n"}
{"value":"] def minOperations ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT res += arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minOperations ( arr , N ) ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 1 NEW_LINE 5 NEW_LINE 4 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17"}
{"value":"] def smallestMissing ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestMissing ( arr , n ) ) NEW_LINE 2 NEW_LINE 6 NEW_LINE 1 NEW_LINE 10 NEW_LINE 4 NEW_LINE 5 NEW_LINE 9 NEW_LINE 8 NEW_LINE 7 NEW_LINE 3 NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 4 NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE"}
{"value":"] def findMissing ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def smallestMissing ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != i and arr [ i ] != i + 1 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestMissing ( arr , n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 1"}
{"value":"] \\n def maxSum ( arr , n ) : NEW_LINE INDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT incl = max ( incl , excl + arr [ i ] ) NEW_LINE excl = max ( excl , incl - arr [ i ] ) NEW_LINE DEDENT return max ( incl , excl ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 7 NEW_LINE 6 NEW_LINE 5 NEW_LINE 3 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0"}
{"value":"] def minChanges ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE dist = [ 0 ] * ( n + m - 2 ) NEW_LINE for i in range ( n + m - 2 ) : NEW_LINE INDENT dist [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dist [ i + j ] += 1 NEW_LINE DEDENT DEDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( n + m - 2 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT freq [ j ] += ( mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE max_val ="}
{"value":"] \\n 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 NEW_LINE INDENT def fill ( lookup , arr , n ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = - 1 NEW_LINE lookup [ i ] [ n - 1 ] = - 1 NEW_LINE DEDENT for j in range ( 1 , 32 ) : NEW_LINE INDENT for i in range ( n - ( 1 << j ) + 1 ) : NEW_LINE INDENT lookup [ j ] [ i ] = lookup [ j - 1 ] [ lookup [ j - 1"}
{"value":"] = 10000000000000 NEW_LINE def build ( arr , lookup , n ) : NEW_LINE INDENT lookup [ 0 ] [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT lookup [ i ] [ j ] = ( lookup [ i - 1 ] [ j ] if lookup [ i - 1 ] [ j ] == INF else gcd ( lookup [ i - 1 ] [ j ] , lookup [ i - 1 ] [ j - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT def RMQ ( arr , l , r ) : NEW_LINE INDENT j = 0 NEW_LINE while ( 1 << ( j + 1 ) <= r - l + 1"}
{"value":"] \\n def lexicographicallySmallest ( arr , n , k ) : NEW_LINE INDENT pos = n - k NEW_LINE while ( k > 0 and pos >= 0 ) : NEW_LINE INDENT Min = min ( k , n ) NEW_LINE for i in range ( pos , min ( pos + k , n ) ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ pos ] NEW_LINE arr [ pos ] = temp NEW_LINE pos += 1 NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT DEDENT 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE lexicographicallySmallest ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \"   \" )"}
{"value":"] \\n def maxSubArraySum ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE start = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( max_sum < csum [ i ] - csum [ i - k ] ) : NEW_LINE INDENT max_sum = csum [ i ] - csum [ i - k ] NEW_LINE start = i - k + 1 NEW_LINE DEDENT DEDENT return start NEW_LINE DEDENT arr = [ 1 , 13 , - 3 , 2 , 3 , 1 , 1 , 1"}
{"value":"] \\n def maxSubarray ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum - arr [ i - k ] NEW_LINE sum = sum + arr [ i ] NEW_LINE if ( max_sum < sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE start = i - k + 1 NEW_LINE DEDENT DEDENT return start NEW_LINE DEDENT arr = [ 1 , 11 , 2 , 3 , 0 , 2 , 5 , 2 , 10 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE start = maxSubarray ( arr , n , k ) NEW_LINE if ( start =="}
{"value":"W_LINE INDENT mpp = { } NEW_LINE def findMinScore ( pos , myturn , arr , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( myturn == 0 ) : NEW_LINE INDENT ans = min ( findMinScore ( pos + 1 , 1 , arr , n ) + arr [ pos ] , findMinScore ( pos + 2 , 1 , arr , n ) + arr [ pos ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( findMinScore ( pos + 1 , 0 , arr , n ) + arr [ pos ] , findMinScore ( pos + 2 , 0 , arr , n ) + arr [ pos ] ) NEW_LINE DEDENT mpp [ ( pos , myturn ) ] = ans NEW_LINE return ans NEW_LINE DEDENT def findMinPenality ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE myturn = 0"}
{"value":"3 ; Driver code [\/INST] \\n prime = [ True ] * 1000001 NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , 1000001 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , 1000001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def getMid ( corner1 , corner2 ) : NEW_LINE INDENT if ( corner1 == corner2 ) : NEW_LINE INDENT return corner1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( corner1 + corner2 ) \/ 2 ) NEW_LINE DEDENT DEDENT def getSumUtil ( node , corner1 , corner2 , arr ,"}
{"value":"] \\n def countWays ( i , j , dp , str1 , str2 , index , index2 , n , m ) : NEW_LINE INDENT if ( i >= n or j >= m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT c = str1 [ i ] NEW_LINE ans = 0 NEW_LINE for k in range ( index , m ) : NEW_LINE INDENT if ( str2 [ k ] == c ) : NEW_LINE INDENT ans += countWays ( i + 1 , j + 1 , dp , str1 , str2 , k + 1 , index2 , n , m ) NEW_LINE DEDENT DEDENT dp [ i ] [ j ] = ans NEW_LINE return ans NEW_LINE DEDENT def countWays ( str1 , str2 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE m ="}
{"value":"] = 10000000000 NEW_LINE def count ( num , k ) : NEW_LINE INDENT n = len ( num ) NEW_LINE dp = [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ ["}
{"value":"] def doubleKnapsack ( i , w1_r , w2_r , arr , n , w1 , w2 , dp ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( w1_r < 0 or w2_r < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT val1 = 0 NEW_LINE val2 = 0 NEW_LINE if ( w1_r >= arr [ i ] [ 0 ] ) : NEW_LINE INDENT val1 = arr [ i ] [ 1 ] + doubleKnapsack ( i + 1 , w1_r - arr [ i ] [ 0 ] , w2_r , arr , n , w1 , w2 , dp ) NEW_LINE DEDENT"}
{"value":"] from collections import defaultdict NEW_LINE import sys NEW_LINE def dfs ( grid , x , y , m , n , visited , ans , res , lex , step ) : NEW_LINE INDENT if ( x < 0 or y < 0 or x >= m or y >= n or visited [ x ] [ y ] or grid [ x ] [ y ] == - 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT visited [ x ] [ y ] = True NEW_LINE lex [ x ] [ y ] = lex [ x ] [ y ] + 1 NEW_LINE if ( x == m - 1 and y == n - 1 ) : NEW_LINE INDENT step [ 0 ] = lex [ x ] [ y ] NEW_LINE return NEW_LINE DEDENT if ( x + 1 < m and grid [ x + 1 ] [ y ] == 0 and lex [ x + 1 ] [ y ] > lex [ x ] [ y ] ) : NEW_LINE INDENT dfs ( grid , x + 1 , y ,"}
{"value":"] \\n def subsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for i in range ( sum + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( j < arr [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - arr [ i - 1 ] ] ) NEW"}
{"value":"] NEW_LINE def lcs ( i , j , str1 , str2 , data , lcslen , currlcs , data ) : NEW_LINE INDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT return lcs ( i - 1 , j - 1 , str1 , str2 , data , lcslen , currlcs , data ) + 1 NEW_LINE DEDENT return max ( lcs ( i - 1 , j , str1 , str2 , data , lcslen , currlcs , data ) , lcs ( i , j - 1 , str1 , str2 , data , lcslen , currlcs , data ) ) NEW_LINE DEDENT def printLCS ( str1"}
{"value":"] def isMajority ( arr , n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT index = n \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT index = ( n + 1 ) \/\/ 2 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == index ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isMajority ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 0"}
{"value":"] def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) \/\/ 2 NEW_LINE if ( arr [ mid ] == x and ( mid == 0 or arr [ mid - 1 ] != x ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] == x ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT return binarySearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT def isMajorityElement ( arr , n , x ) : NEW_LINE INDENT index = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if index == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( index >= n \/ 3 ) NEW_LINE DEDENT arr = [ 4 , 4 , 4 , 4 , 4 , 5"}
{"value":"] \\n def isMajority ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i + 1 == n \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isMajority ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 2 NEW_LINE 3 NEW_LINE 3 NEW_LINE 4 NEW_LINE 4 NEW_LINE 4 NEW_LINE "}
{"value":"] def rodCut ( price , n ) : NEW_LINE INDENT val = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val [ i ] = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val [ i ] = max ( val [ i ] , price [ j - 1 ] + val [ i - j ] ) NEW_LINE DEDENT DEDENT return val [ n ] NEW_LINE DEDENT price = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 17 , 20 ] NEW_LINE n = 7 NEW_LINE print ( \" Maximum   price   that   can   be   obtained   is   \" , rodCut ( price , n ) ) NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0"}
{"value":"] \\n def check ( arr , target , n , m ) : NEW_LINE INDENT max = - 1 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( target [ i ] > max ) : NEW_LINE INDENT max = target [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( index != i ) : NEW_LINE INDENT max = max - arr [ i ] NEW_LINE if ( max < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if ( max <= 0 ) : NEW_LINE INDENT max = target [ index ] NEW_LINE DEDENT return check ( arr , target , n , m ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ,"}
{"value":"] \\n def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res \/ ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def sumOfProducts ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + binomialCoeff ( i , j ) * binomialCoeff ( j , k ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE k = 2 NEW_LINE print ( sumOfProducts ( n , k ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8"}
{"value":"] \\n import math NEW_LINE def check ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N % 100 == 0 ) : NEW_LINE INDENT N = int ( N \/ 100 ) NEW_LINE count += 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( math . log2 ( N ) == math . floor ( math . log2 ( N ) ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT N = 10000 NEW_LINE check ( N ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE "}
{"value":"] def nthTerm ( n ) : NEW_LINE INDENT return ( ( 2 * n * n - n ) \/\/ 2 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 6 NEW_LINE 15 NEW_LINE 30 NEW_LINE 55 NEW_LINE 91 NEW_LINE 140 NEW_LINE 204 NEW_LINE 282 NEW_LINE 375 NEW_LINE 484 NEW_LINE 610 NEW_LINE 754 NEW_LINE 916 NEW_LINE 1100 NEW_LINE 1308 NEW_LINE 1544 NEW_LINE 1808 NEW_LINE 2100 NEW_LINE 2422 NEW_LINE 2776 NEW_LINE 3162 NEW_LINE 3582 NEW_LINE 4036 NEW_LINE 4526 NEW_LINE 5054 NEW_LINE 562"}
{"value":"] def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( i * i , end = \"   \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i * ( i + 1 ) , end = \"   \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE printSeries ( n ) NEW_LINE DEDENT 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 8 NEW_LINE 15 NEW_LINE 27 NEW_LINE 50 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 8 NEW_LINE 15 NEW_LINE 27 NEW_LINE 50 NEW_LINE 1 NEW_LINE 3 NEW_LINE 4 NEW_LINE 8 NEW_LINE 15 NEW_LINE 27 NEW_LINE"}
{"value":"] def diameterOfBIT ( N ) : NEW_LINE INDENT L = int ( ( N ** ( 1 \/ 2 ) ) NEW_LINE H = int ( ( N ** ( 1 \/ 2 ) ) NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( L == H ) : NEW_LINE INDENT return 2 * H NEW_LINE DEDENT if ( L == H + 1 ) : NEW_LINE INDENT return 2 * H + 1 NEW_LINE DEDENT if ( L == H + 2 ) : NEW_LINE INDENT return 2 * H + 2 NEW_LINE DEDENT return 2 * H + 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ("}
{"value":"] \\n import math NEW_LINE def findLarger ( a , b , c , d ) : NEW_LINE INDENT a_b = a * math . log ( b ) NEW_LINE c_d = c * math . log ( d ) NEW_LINE if ( a_b > c_d ) : NEW_LINE INDENT print ( \" a ^ b   is   larger \" ) NEW_LINE DEDENT elif ( a_b < c_d ) : NEW_LINE INDENT print ( \" c ^ d   is   larger \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Both   are   equal \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE findLarger ( a , b , c , d ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_"}
{"value":"] NEW_LINE def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findSum ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT if ( i % j == 0 and prime [ j ] ) : NEW_LINE INDENT flag = False NEW_"}
{"value":"] def countPrimes ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def generatePrefix ( arr , n ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE"}
{"value":"] \\n import math NEW_LINE def findValue ( n , x , y ) : NEW_LINE INDENT ans = math . ceil ( ( ( y * n ) \/ 100 ) - x ) NEW_LINE if ( ans >= x ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 100 NEW_LINE x = 80 NEW_LINE y = 20 NEW_LINE print ( findValue ( n , x , y ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20"}
{"value":"] \\n import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE"}
{"value":"] \\n def countWays ( n ) : NEW_LINE INDENT fac1 = 1 NEW_LINE fac2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE fac2 = fac2 * i NEW_LINE DEDENT print ( fac2 \/\/ fac1 ) NEW_LINE DEDENT n = 5 NEW_LINE countWays ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE"}
{"value":"] NEW_LINE import math NEW_LINE def SieveOfEratosthenes ( n , arr ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n , arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( n == arr [ i ] * ( arr [ i ] + 1 ) ) : NEW_LINE INDENT"}
{"value":"] \\n def nextCube ( n ) : NEW_LINE INDENT return ( n * n * n ) NEW_LINE DEDENT n = 24 NEW_LINE print ( nextCube ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 8 NEW_LINE 27 NEW_LINE 64 NEW_LINE 125 NEW_LINE 216 NEW_LINE 343 NEW_LINE 512 NEW_LINE 729 NEW_LINE 1000 NEW_LINE 1331 NEW_LINE 1728 NEW_LINE 2197 NEW_LINE 2772 NEW_LINE 3436 NEW_LINE 4200 NEW_LINE 5061 NEW_LINE 6024 NEW_LINE 7102 NEW_LINE 8321 NEW_LINE 9688 NEW_LINE 11197 NEW_LINE 12864 NEW_LINE 14688 NEW_LINE 16756 NEW_LINE 19088"}
{"value":"] \\n import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def sumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE IND"}
{"value":"] def getPosition ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 5 == 2 ) : NEW_LINE INDENT print ( pos * 2 + 1 , end = \"   \" ) NEW_LINE DEDENT elif ( n % 5 == 3 ) : NEW_LINE INDENT print ( pos * 2 + 2 , end = \"   \" ) NEW_LINE DEDENT elif ( n % 5 == 5 ) : NEW_LINE INDENT print ( pos * 2 + 3 , end = \"   \" ) NEW_LINE DEDENT elif ( n % 5 == 7 ) : NEW_LINE INDENT print ( pos * 2 + 4 , end = \"   \" ) NEW_LINE DEDENT n = n \/\/ 5 NEW_LINE pos = pos + 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE getPosition ( n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW"}
{"value":"] \\n def check ( L , R ) : NEW_LINE INDENT if ( R - L + 1 < 3 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( L , R + 1 , 2 ) : NEW_LINE INDENT if ( ( k * ( k + 1 ) % 2 == 0 ) and ( ( k + 1 ) * ( k + 2 ) % 2 == 0 ) and ( k * ( k + 2 ) % 2 != 0 ) ) : NEW_LINE INDENT print ( k , k + 1 , k + 2 ) NEW_LINE return NEW_LINE DEDENT DEDENT for k in range ( L , R + 1 , 2 ) : NEW_LINE INDENT if ( ( k * ( k + 1 ) % 2 == 0 ) and ( ( k + 1 ) * ( k + 2 ) % 2 == 0 ) and ( k * ( k + 2 ) % "}
{"value":"] \\n def digitNumber ( n , digit ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 8 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( 9 * ( 10 ** ( n - 1 ) ) - 10 * ( 10 ** ( n - 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 9 * ( 10 ** ( n - 1 ) ) - 9 * ( 10 ** ( n - 2 ) ) ) NEW_LINE DEDENT DEDENT def countNumber ( n , digit ) : NEW_LINE INDENT if ( digit == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( digit == 10 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT return digit"}
{"value":"] \\n def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT n1 = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n1 = n1 * 10 + n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 121 NEW_LINE if ( isEmirp ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else"}
{"value":"] \\n def radian_to_degree ( rad ) : NEW_LINE INDENT degree = rad * 180 NEW_LINE return degree NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT rad = 3.14 NEW_LINE degree = radian_to_degree ( rad ) NEW_LINE print ( degree ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE "}
{"value":"W_LINE INDENT def sum ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) \/\/ 2 NEW_LINE return sum NEW_LINE DEDENT def trace ( n ) : NEW_LINE INDENT row_sum = sum ( n ) NEW_LINE row_sum = sum ( n ) NEW_LINE column_sum = sum ( n ) NEW_LINE column_sum = sum ( n ) NEW_LINE return row_sum + column_sum NEW_LINE DEDENT n = 4 NEW_LINE print ( trace ( n ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 7 NEW_LINE DEDENT 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 8 NEW_LINE DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 1"}
{"value":"] \\n def maxArea ( w , h , k ) : NEW_LINE INDENT if ( w < k ) : NEW_LINE INDENT print ( w ) NEW_LINE return NEW_LINE DEDENT if ( h < k ) : NEW_LINE INDENT print ( h ) NEW_LINE return NEW_LINE DEDENT print ( w * h ) NEW_LINE DEDENT w = 2 NEW_LINE h = 10 NEW_LINE k = 2 NEW_LINE maxArea ( w , h , k ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 2"}
{"value":"] \\n def findArea ( a ) : NEW_LINE INDENT return a * a NEW_LINE DEDENT a = 5 NEW_LINE print ( \" Area   of   square   is   \" , findArea ( a ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE "}
{"value":"] \\n def countWays ( N ) : NEW_LINE INDENT L = int ( ( 1 + N \/ 2 ) ** 0.5 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , L + 1 ) : NEW_LINE INDENT ans += ( N \/\/ ( i * ( i + 1 ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 10 NEW_LINE print ( countWays ( N ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE "}
{"value":"] \\n def isAutomorphic ( N ) : NEW_LINE INDENT square = N * N NEW_LINE while ( N > 0 and square > 0 ) : NEW_LINE INDENT if ( ( N % 10 ) != ( square % 10 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = N \/\/ 10 NEW_LINE square = square \/\/ 10 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 25 NEW_LINE if ( isAutomorphic ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 1"}
{"value":"] \\n def findMaximumPrimeFactors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findMaximumPrimeFactors ( n ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE "}
{"value":"] def power ( x , y , p ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def squareRoot ( n , p ) : NEW_LINE INDENT if ( ( p + 1 ) % 4 == 0 ) : NEW_LINE INDENT if ( power ( n , ( p + 1 ) \/ 4 , p ) % p == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( power ( n , ( p +"}
{"value":"] NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x >= p ) : NEW_LINE INDENT x %= p NEW_LINE DEDENT res = ( res * x ) % p NEW_LINE y -= 1 NEW_LINE if ( y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def isProbablePrime ( n , k ) : NEW_LINE INDENT d = 0 NEW_LINE while ( d < n - 1 ) : NEW_LINE INDENT d += 2 NEW_LINE DEDENT d = d \/\/ 2 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT a = randint ( 2 , n - 2 ) NEW_LINE x = power ( a , d , n ) NEW_LINE if ( x == 1 )"}
{"value":"] def longestConseqOne ( x ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE x = x & ( x - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT x = 20 NEW_LINE print ( longestConseqOne ( x ) ) NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 16 NEW_LINE 32 NEW_LINE 64 NEW_LINE 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE "}
{"value":"] def subtract ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE result = \" \" NEW_LINE carry = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT borrow = ( ( y [ i ] ) & ( ~ ( x [ i ] ) ) NEW_LINE result = ( ( x [ i ] ) ^ ( y [ i ] ) ^ ( borrow ) + ( carry ) ) NEW_LINE carry = ( ( x [ i ] ) & ( borrow ) NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT result = ( \"1\" + result ) NEW_LINE DEDENT return result NEW_LINE DEDENT x = \"1101001\" NEW_LINE y = \"111010\" NEW_LINE print ( \" After   Subtraction :   \" + subtract ( x , y ) ) NEW_LINE 2 NEW_LINE 0 NEW_LINE 1 NEW_LINE 1 NEW_LINE 0 NEW_LINE 0 NEW"}
{"value":"] \\n def subtract ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return a - subtract ( b , subtract ( a , b ) ) NEW_LINE DEDENT DEDENT a = 100 NEW_LINE b = 70 NEW_LINE print ( subtract ( a , b ) ) NEW_LINE 2 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW_LINE 1 NEW"}
{"value":"W_LINE INDENT def addEdge ( V , u , v ) : NEW_LINE INDENT V [ u ] . append ( v ) NEW_LINE DEDENT def findKthAncestor ( V , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT ans = [ ] NEW_LINE q = [ ] NEW_LINE q . append ( i ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( len ( ans ) == K ) : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( len ( V [ node ] ) ) : NEW_LINE INDENT if ( len ( ans ) == K ) : NEW_LINE INDENT break NEW_LINE DEDENT q . append ( V [ node ] [ j ] ) NEW_LINE DEDENT DEDENT ans . append ( node ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT"}
{"value":"] def build ( v , arr , seg , ss , se , si ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( ss + se ) \/\/ 2 NEW_LINE build ( v , arr , v , ss , mid , si ) NEW_LINE build ( v , arr , v , mid + 1 , se , 2 * si + 1 ) NEW_LINE DEDENT def pushDown ( v , seg , ss , se , si ) : NEW_LINE INDENT if ( seg [ si ] != 0 ) : NEW_LINE INDENT v [ si ] += seg [ si ] NEW_LINE if ( ss != se ) : NEW_LINE INDENT seg [ 2 * si + 1 ] += seg [ si ] NEW_LINE seg [ 2 * si + 2 ] += seg [ si ] NEW_LINE DEDENT DEDENT DEDENT def update ( v , seg , ss , se , si , l , r , val ) : NEW_LINE INDENT if ( l == ss and r == se )"}
{"value":"W_LINE INDENT def findLength ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT arr = [ 4 , 16 , 12 , 36 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE if ( findLength ( arr , n ) ) : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 4 NEW_LINE 8 NEW_LINE 12 NEW_LINE 16 NEW_LINE 36 NEW_LINE 18 NEW_LINE 3 NEW_LINE 5 NEW"}
{"value":"] \\n def countWays ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT for b in range ( 1 , n + 1 ) : NEW_LINE INDENT c = n - a - b NEW_LINE if ( a + b > c and c > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT 2 NEW_LINE 4 NEW_LINE 6 NEW_LINE 8 NEW_LINE 10 NEW_LINE 12 NEW_LINE 14 NEW_LINE 16 NEW_LINE 18 NEW_LINE 20 NEW_LINE 22 NEW_LINE 24 NEW_LINE 26 NEW_LINE 28 NEW_LINE 30 NEW_LINE 32 NEW_LINE "}
{"value":"] def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countPairs ( arr , n ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 0 NEW_LINE 0 NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW"}
{"value":"] \\n def findFibonacciSubseq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT continue NEW_LINE DEDENT prev = arr [ i ] NEW_LINE curr = arr [ i ] NEW_LINE maxLen = max ( maxLen , 1 ) NEW_LINE while curr in mp : NEW_LINE INDENT curr = prev + arr [ i ] NEW_LINE if curr in mp : NEW_LINE INDENT maxLen = max ( maxLen , mp [ curr ] + 1 ) NEW_LINE DEDENT prev = curr NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len"}
{"value":"] def maxElements ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 3 , 2 , 4 , 5 , 6 ] NEW_LINE k = 11 NEW_LINE n = len ( arr ) NEW_LINE print ( maxElements ( arr , n , k ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 11 NEW_LINE 2 NEW_LINE 1 NEW_LINE 3 NEW_LINE 2 NEW_LINE 4 NEW_LINE 5 NEW"}
{"value":"W_LINE def findCandies ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def maxCandies ( arr , n ) : NEW_LINE INDENT n1 = n \/\/ 2 NEW_LINE n2 = findCandies ( arr , n1 ) NEW_LINE return n2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( maxCandies ( arr , N ) ) NEW_LINE DEDENT 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW"}
{"value":"] \\n import math NEW_LINE def rhombusDiagonal ( a , theta ) : NEW_LINE INDENT d = a * math . cos ( theta ) NEW_LINE return d NEW_LINE DEDENT a = 6 NEW_LINE theta = 30 NEW_LINE print ( rhombusDiagonal ( a , theta ) ) NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW_LINE 0 NEW"}
{"value":"] def countEvenOdd ( arr , n , k ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd += arr [ i ] & 1 NEW_LINE even += arr [ i ] & 2 NEW_LINE DEDENT odd_k = 0 NEW_LINE even_k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd_k += k & 1 NEW_LINE even_k += k & 2 NEW_LINE DEDENT if ( odd_k & 1 ) : NEW_LINE INDENT odd = even NEW_LINE even = odd_k NEW_LINE DEDENT print ( \" Even   =   \" , even , \" ,   Odd   =   \" , odd ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE countEven"}
{"value":"] \\n def countPairs ( n ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE 18 NEW_LINE 19 NEW_LINE 20 NEW_LINE 21 NEW_LINE 22 NEW_LINE 23 NEW_LINE 24 NEW_LINE 25 NEW_LINE 26 NEW_LINE 27 NEW_LINE 28 NEW_LINE 29 NEW_LINE 30 NEW_LINE 31 NEW_LINE 32 NEW_LINE 33 NEW_LINE 34 NEW_LINE 35 NEW_LINE 3"}
{"value":"] \\n import sys NEW_LINE def lps ( arr , i , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT notIncl = lps ( arr , i + 1 , n ) NEW_LINE incl = 0 NEW_LINE if ( i > 0 and arr [ i - 1 ] [ 1 ] > arr [ i ] [ 1 ] ) : NEW_LINE INDENT incl = lps ( arr , i + 1 , n ) + 1 NEW_LINE DEDENT return max ( notIncl , incl ) NEW_LINE DEDENT def longestSubsequence ( arr , n ) : NEW_LINE INDENT return lps ( arr , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 2 ] , [ 2 , 1 ] , [ 3 , 2 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 2 ] , ["}
{"value":"] def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT x = A [ i ] & A [ j ] NEW_LINE if x in mp : NEW_LINE INDENT mp [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT x = A [ i ] & A [ j ] NEW_LINE if ( x == 0 ) : NEW_LINE INDENT cnt += mp [ x ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4"}
{"value":"] \\n def countWays ( n ) : NEW_LINE INDENT noOfWays = [ 0 ] * ( n + 1 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 2 NEW_LINE noOfWays [ 2 ] = 3 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT noOfWays [ i ] = ( noOfWays [ i - 1 ] + noOfWays [ i - 2 ] ) NEW_LINE DEDENT return noOfWays [ n ] NEW_LINE DEDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE 2 NEW_LINE 3 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW_LINE 16 NEW_LINE 17 NEW_LINE"}
{"value":"] \\n import sys NEW_LINE def PlayerA ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT if ( len ( v ) == 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT first = sys . maxsize NEW_LINE second = - sys . maxsize - 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = v [ i ] NEW_LINE DEDENT elif ("}
{"value":"] \\n def check ( s , k ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( k == len ( s ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in m : NEW_LINE INDENT if ( m [ i ] % 2 == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aaab \" NEW_LINE k = 3 NEW_LINE if ( check ( s , k ) ) : NEW_LINE INDENT print ( \" Yes"}
{"value":"] \\n def compareStrings ( s1 , s2 ) : NEW_LINE INDENT s1 = s1 . lower ( ) NEW_LINE s2 = s2 . lower ( ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def printSameOrNotSame ( s1 , s2 ) : NEW_LINE INDENT if ( compareStrings ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Same \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not   Same \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" Geeks \" NEW_LINE s2 = \" geeks \" NEW_LINE printSameOrNotSame ( s1 , s2 ) NEW_LINE s1 = \" Geeks \" NEW_LINE s2 = \" Geeks \" NEW_LINE printSameOrNotSame ( s1 , s2 ) NEW_LINE DEDENT 2 NEW_LINE 3 NEW_"}
{"value":"] \\n def printStep ( s , n ) : NEW_LINE INDENT flag = False NEW_LINE for x in range ( n ) : NEW_LINE INDENT if ( flag == False ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT print ( x * s , end = \" \" ) NEW_LINE flag = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x == n - 1 ) : NEW_LINE INDENT print ( x * s , end = \" \" ) NEW_LINE flag = False NEW_LINE DEDENT DEDENT DEDENT DEDENT s = \" * \" NEW_LINE n = 5 NEW_LINE printStep ( s , n ) NEW_LINE 1 NEW_LINE 2 NEW_LINE 3 NEW_LINE 4 NEW_LINE 5 NEW_LINE 6 NEW_LINE 7 NEW_LINE 8 NEW_LINE 9 NEW_LINE 10 NEW_LINE 11 NEW_LINE 12 NEW_LINE 13 NEW_LINE 14 NEW_LINE 15 NEW"}
{"value":"] \\n def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( visited [ arr [ i ] ] == 0 ) : NEW_LINE INDENT visited [ arr [ i ] ] = 1 NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT DEDENT DEDENT 1 NEW_LINE arr = [ 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 6 , 6 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 12 , 13 , 13 , 13 , 14 , 14 , 14 , 15 , 15 , 1"}
{"value":"] \\n def isDivisible ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = \"101010\" NEW_LINE k = 3 NEW_LINE if ( isDivisible ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT n = \"101010010101001010100101010010101001010100101010010101001010100"}
