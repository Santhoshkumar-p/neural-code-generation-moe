,value,value,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
0,"def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( ' inf ' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE","ode]
                  	#include<iostream>
                  	#include<map>
                  	using namespace std;
                  	int minSum(int arr[], int n)
                  	{
                  		map<int,int> mp;
                  		int sum=0;
                  		for(int i=0;i<n;i++)
                  		{
                  			sum+=arr[i];
                  			mp[arr[i]]++;
                  		}
                  		int min=sum;
                  		for(auto i:mp)
                  		{
                  			if(i.second>1)
                  			{
                  				sum-=i.first;
                  				min=min<sum?min:sum;
                  			}
                  		}
                  		return min;
                  	}
                  	int main()
                  	{
                  		int arr[]={1",0.1308273568102195,0.0005171332552899729,0.001958960652254726,0.1875,0.3333333333333333
1,"def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE maxi = - 1 * float ( ' inf ' ) NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE prev = arr [ j ] NEW_LINE DEDENT res . append ( maxi ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE","ODE]
                   #include<iostream>
                   #include<vector>
                   using namespace std;
                   int maxDiff(int arr[], int n)
                   {
                   int maxDiff = 0;
                   vector<int> result;
                   for(int i = 0; i < n-1; i++)
                   {
                   int diff = abs(arr[i] - arr[i+1]);
                   if(maxDiff < diff)
                   {
                   maxDiff = diff;
                   }
                   }
                   return maxDiff;
                   }
                   int main()
                   {
                   int arr[] = {1, 3, 4, 2, 10, 6};
                   int n = sizeof(arr)/sizeof(arr[0]);
                   cout<<maxDiff(arr, n);
                   return 0;
                   }
                   [/CODE]",0.11883270816901348,0.001227444778627301,0.0018811656752044297,0.25,0.2222222222222222
2,"def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( CountOnes ( N , L , R ) ) NEW_LINE DEDENT","                  #include<bits/stdc++.h>
                  using namespace std;
                  int findSize(int n){
                  if(n==1)
                  return 1;
                  return 2*findSize(n/2);
                  }
                  int findCount(int a[], int l, int r, int n){
                  if(l==r)
                  return a[l];
                  int m=l+(r-l)/2;
                  if(a[m]==1)
                  return findCount(a,l,m,n)+findCount(a,m+1,r,n);
                  else
                  return findCount(a,l,m,n)+findCount(a,m+1,r,n);
                  }
                  int main(){
                  int n;
                  cin>>n;
                  int a[n];
                  for(int i=0;i<n;i++)
                  cin>>a[i];
                  int l,r;
                 ",0.2025605997664241,9.200516933378111e-05,0.0015789653249341324,0.32857142857142857,0.48
3,"def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 4 NEW_LINE minDivisior ( N ) NEW_LINE","ODE]
                  def is_prime(n):
                  if n == 1:
                  return False
                  for i in range(2, int(n ** 0.5) + 1):
                  if n % i == 0:
                  return False
                  return True
                  def lcm(a, b):
                  return a * b // math.gcd(a, b)
                  def find_pair(n):
                  a = n
                  b = 1
                  while True:
                  if is_prime(a) and is_prime(b) and lcm(a, b) == n:
                  return a, b
                  a += 1
                  b += 1
                  return a, b
                  n = int(input())
                  print(find_pair(n))
                  [/CODE]",0.16100348785816881,0.020661580020165753,0.0370814994273518,0.32653061224489793,0.2597402597402597
4,"import sys NEW_LINE Landau = - sys . maxsize - 1 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT N = 4 NEW_LINE Landau_function ( N ) NEW_LINE","                 [SOL]
                  [/SOL]
                  [OUT]
                  [/OUT]",0.009900990099009901,0.0,0.0,0.0,0.039603960396039604
5,"def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE DEDENT def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT","                  [INP]
                  N = 100
                  [/INP]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                 ",0.050570234170581554,0.0003261210115145949,0.0019548156708116254,0.0,0.2
6,"def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","ODE]
                  import java.util.*;
                  class GFG {
                  public static void main(String[] args) {
                  Scanner sc = new Scanner(System.in);
                  int t = sc.nextInt();
                  while (t-- > 0) {
                  int n = sc.nextInt();
                  int k = sc.nextInt();
                  int arr[] = new int[n];
                  for (int i = 0; i < n; i++)
                  arr[i] = sc.nextInt();
                  System.out.println(checkSplit(arr, k));
                  }
                  }
                  static int checkSplit(int[] arr, int k) {
                  int odd = 0;
                  for (int i = 0; i < arr.length; i++)
                  odd += arr[i] % 2 == 1 ? 1 : 0;
                  if (odd % 2 == 1)
                  return 0;
                  int count = 0;
                  for",0.24942963192046744,0.010919606592351817,0.012459298448008483,0.09433962264150944,0.88
7,"from math import * NEW_LINE def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT","ODE]
                   import math


                   def sum_of_divisors(n):
                       # Function to compute the sum of divisors of a number
                       sum = 1
                       for i in range(2, int(math.sqrt(n)) + 1):
                           if n % i == 0:
                               sum += i + n // i
                       return sum


                   def count_frequency(arr):
                       # Function to count frequency of each term in the array
                       freq = {}
                       for num in arr:
                           if num in freq:
                               freq[num] += 1
                           else:
                               freq[num] = 1
                       return freq


                   def cumulative_frequency(freq):
                       # Function to compute the cumulative frequency
                       cum_freq = {}
                       for num in freq:
                           cum_freq[num] = freq[num]
                           for i in range(num + 1, len(freq) + 1):
                ",0.1139591847601287,0.00434892199430788,0.010602996298686006,0.2391304347826087,0.20175438596491227
8,"def insert_element ( a , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE print ( 2 ) NEW_LINE print ( num1 , num2 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT","Write a python program to complete the following.
                  Count of elements to be inserted to make Array sum twice the XOR of Array | Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array ; Variable to store the Xor of all the elements ; Variable to store the sum of all elements ; Loop to find the Xor and the sum of the array ; If sum = 2 * Xor ; No need to insert more elements ; We insert one more element which is Sum ; We insert two more elements Sum + Xor and Xor . ; Print the number of elements inserted in the array ; Print the elements that are inserted in the array ; Driver code.
                  [/CODE]
                  [OUTPUT]
                  [/OUTPUT]
                  [SOLUTION]
                  [/SOLUTION]
                  [TUTORIAL]
                  [/TUTORIAL]
                  [SAMPLE]
                  [/SAMPLE]
                  [QUESTION]
                  [/QUESTION]",0.10640948771182368,0.011776064157773252,0.012731943186696647,0.06779661016949153,0.3333333333333333
9,"def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE","function to check if the roots of a quadratic equation are reciprocal of each other or not
                  [CODE]
                  def check_roots(a, b, c):
                      d = b ** 2 - 4 * a * c
                      if d < 0:
                          return False
                      else:
                          return True
                  [/CODE]
                  2. Driver code
                  [CODE]
                  a, b, c = map(int, input().split())
                  if check_roots(a, b, c):
                      print(""The roots are reciprocal of each other"")
                  else:
                      print(""The roots are not reciprocal of each other"")
                  [/CODE]
                  Input:
                  1 2 3
                  Output:
                  The roots are reciprocal of each other
                  Explanation:
                  The roots of the quadratic equation x ** 2 - 2x + 3 = 0 are 1 and 3, which are reciprocal of each other.
",0.2916999915698676,0.006462540694482162,0.011796311526632604,0.3793103448275862,0.7692307692307693
10,"from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE checkSunnyNumber ( N ) NEW_LINE DEDENT","                  [INST]
                  Write a python program to complete the following. Sunny Number | Python3 program for the above approach ; Function check whether x is a perfect square or not ; Find floating point value of square root of x . ; If square root is an integer ; Function to check Sunny Number ; Check if ( N + 1 ) is a perfect square or not ; If ( N + 1 ) is not a perfect square ; Driver Code ; Given Number ; Function call.
                  [/INST]
                  code:
                  2.
                  [INST]
                  Write a python program to complete the following. Sunny Number | Python3 program for the above approach ; Function check whether x is a perfect square or not ; Find floating point value of square root of x . ; If square root is an integer ; Function to check Sunny Number ; Check if ( N + 1 ) is a perfect square or not ; If ( N + 1 ) is not a perfect square ; Driver Code ; Given Number ; Function call.
                  [/INST]
                  code:
                  3.
                  [INST]
                  Write a python program to",0.25868197568852047,0.02811638080833548,0.05497567557305791,0.16216216216216217,0.7894736842105263
11,"def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT","ODE]
                  def count_numbers(n):
                      count = 0
                      for i in range(1, n):
                          if i + n == 1:
                              count += 1
                      return count

                  print(count_numbers(10))
                  [/CODE]
                  output:
                   [OUT]
                   5
                   [/OUT]

                   [INST]
                   Write a python program to complete the following. Count the numbers which can convert N to 1 using given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Iterate through all the integers ; Check if N can be converted to 1 ; Incrementing the count if it can be converted ; Driver code.
                   [/INST]
                   code:
                   [CODE]
                   def count_numbers(n):
                       count = 0
                       for i in range(1, n):
                           if i + n == 1:
                               count += 1
                       return count

                  ",0.16264626949089744,0.01583328968877979,0.018281200039515888,0.17647058823529413,0.44
12,"def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
13,"def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE DEDENT","port queue
                   queue = queue.Queue()
                   queue.put(1)
                   queue.put(2)
                   queue.put(3)
                   queue.put(4)
                   queue.put(5)
                   queue.put(6)
                   queue.put(7)
                   queue.put(8)
                   queue.put(9)
                   def get_nth_stepping_number(n):
                     k = 1
                     while k < n:
                       x = queue.get()
                       if x % 10 != 0:
                         queue.put(10 * x + (x % 10) - 1)
                       if x % 10 != 9:
                         queue.put(10 * x + (x % 10) + 1)
                       k += 1
                     return queue.get()
                   print(get_nth_stepping_number(4))
                  Output:
                   234567891011",0.18100542861036573,0.021777728398312983,0.04175015888265614,0.16049382716049382,0.5
14,"from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
15,"from math import acos NEW_LINE def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 43 ; NEW_LINE printValueOfPi ( N ) ; NEW_LINE DEDENT","port math


                  def pi(n):
                    # 1/1, 2/2, 3/2, 4/2, 5/2, 6/2, 7/2, 8/2, 9/2, 10/2, 11/2, 12/2, 13/2, 14/2, 15/2, 16/2, 17/2, 18/2, 19/2, 20/2, 21/2, 22/2, 23/2, 24/2, 25/2, 26/2, 27/2, 28/2, 29/2, 30/2, 31/2, 32/2, 33/2, 34/2, 35/2, 36/2, 37/2, 38/2, 39/2, 40/2, 41/2, 42",0.2920336406014855,0.0024556588638759832,0.0035167413799039454,0.16216216216216217,0.0
16,"import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE","                  [CODE]
                  [/CODE]
                  2.
                  [CODE]
                  [/CODE]
                  3.
                  [CODE]
                  [/CODE]
                  4.
                  [CODE]
                  [/CODE]
                  5.
                  [CODE]
                  [/CODE]
                  6.
                  [CODE]
                  [/CODE]
                  7.
                  [CODE]
                  [/CODE]
                  8.
                  [CODE]
                  [/CODE]
                  9.
                  [CODE]
                  [/CODE]
                  10.
                  [CODE]
                  [/CODE]
                  11.
                  [CODE]
                  [/CODE]
                  12.
                  [CODE]
                  [/CODE]
                  13.
                  [CODE]
                  [/CODE]
                  14.
                  [CODE]
                  [/CODE]
                ",0.007462686567164179,0.0,0.0,0.0,0.029850746268656716
17,"MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE","                  [CODE]
                  def factorial(n):
                    result = [0] * (n + 1)
                    result[0] = 1
                    for i in range(1, n + 1):
                      result[i] = result[i - 1] * i
                    return result

                  def queries():
                    n = int(input())
                    result = factorial(n)
                    for i in range(n):
                      print(result[i])

                  queries()
                  [/CODE]
                  2.
                  [CODE]
                  def factorial(n):
                    result = [0] * (n + 1)
                    result[0] = 1
                    for i in range(1, n + 1):
                      result[i] = result[i - 1] * i
                    return result

                  def queries():
                    n = int(input())
                    result = factorial(n)
                    for i in range(n):
",0.13752598061140486,0.013974680400013748,0.0233087292250929,0.32051282051282054,0.19230769230769232
18,"import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE","                  [INST]
                  Write a python program to complete the following. Nth number in a set of multiples of A , B or C | Python3 program to find nth term divisible by a , b or c ; Function to return gcd of a and b ; Function to return the count of integers from the range [ 1 , num ] which are divisible by either a , b or c ; Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c ; Function for binary search to find the nth term divisible by a , b or c ; Set low to 1 and high to LONG_MAX ; If the current term is less than n then we need to increase low to mid + 1 ; If current term is greater than equal to n then high = mid ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Nth number",0.17456013705960466,0.06202969976241711,0.06596291459170392,0.15702479338842976,0.4132231404958678
19,"def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE","port math
                  class Solution:
                    def angleBetweenThreePoints(self, x1, y1, x2, y2, x3, y3):
                      # Your code here
                      # return the angle between the three points
                      # in degrees
                      # return -1 if the three points are collinear
                      # x1, y1, x2, y2, x3, y3 are the coordinates of the three points
                      # return the angle in degrees
                      # return -1 if the three points are collinear
                      # return 0 if the three points are the same
                      # return 180 if the three points are the same
                      # return 90 if the three points are collinear
                      # return 0 if the three points are collinear
                      # return 90 if the three points are collinear
                      # return 0 if the three points are collinear
                      # return 90 if the three points are collinear
                      # return 0 if the three points are collinear
                      #",0.2511811541974981,0.0020588972841743824,0.0026657195058179526,0.0,0.0
20,"def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( "" Loss ▁ = "" , round ( loss , 3 ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT","Write a python program to complete the following.
                  a. Loss when two items are sold at same price and same percentage profit / loss
                  b. Function that will find loss
                  c. Driver Code
                  d. Calling Function
                  e. Output

                  [/code]
                  [SOL]
                  [/SOL]
                  [ANS]
                  [/ANS]
                  [EXPL]
                  [/EXPL]
                  [QUIZ]
                  [/QUIZ]
                  [SOL]
                  [/SOL]
                  [ANS]
                  [/ANS]
                  [EXPL]
                  [/EXPL]
                  [QUIZ]
                  [/QUIZ]",0.16972880854797548,0.0027750093214151377,0.002980051710313612,0.030303030303030304,0.6428571428571429
21,"MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT"," def isPrime(n):
                       if n == 2:
                           return True
                       if n % 2 == 0:
                           return False
                       for i in range(3, int(n ** 0.5) + 1, 2):
                           if n % i == 0:
                               return False
                       return True

                  2.  def find_smallest_prime_factor(n):
                       if n == 1:
                           return 1
                       if n == 2:
                           return 2
                       for i in range(2, int(n ** 0.5) + 1):
                           if n % i == 0:
                               return i
                       return n

                  3.  def get_prime_factors(n):
                       spf = [1] * (n + 1)
                       spf[2] = 2
                       for i in range(3, int(n ** 0.5) + 1, 2):
                           if sp",0.05586033527794762,0.0016126999048030743,0.011109535751039819,0.12280701754385964,0.08791208791208792
22,"def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT","                  [CODE]
                  def remove_edges(n, m):
    ways = 0
    for i in range(m):
        ways += (n - 2) ** i
    return ways


    n = int(input(""Enter the number of nodes: ""))
    m = int(input(""Enter the number of edges: ""))
    print(""The number of ways to remove edges from the graph so that odd number of edges are left in the graph is:"", remove_edges(n, m))
    [/CODE]
                  output:
                  Enter the number of nodes: 5
    Enter the number of edges: 5
    The number of ways to remove edges from the graph so that odd number of edges are left in the graph is: 16
                  [/OUTPUT]
                  [TEST]
                  [/TEST]
                  [ANS]
                  [/ANS]
                  [SOL]
                  [/SOL]",0.22879333792904608,0.0027154373369671493,0.004411937367722886,0.2413793103448276,0.6666666666666666
23,"l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE","Initialize the matrix with 0 ;
                  2. 0 C0 = 1 ;
                  3. Set every nCr = 1 where r = 0 ;
                  4. Value for the current cell of Pascal 's triangle ;
                  5. Function to return the value of nCr ;
                  6. Return nCr ;
                  7. Build the Pascal 's triangle.

                  [IN]
                  [/IN]
                  [OUT]
                  [/OUT]
                  [SOL]
                  [/SOL]
                  [TEST]
                  [/TEST]",0.06705233936099819,0.002988435914799853,0.005555299794605641,0.017241379310344827,0.24242424242424243
24,"def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT","Write a python program to complete the following. Closest sum partition ( into two subsets ) of numbers from 1 to n | Function to return the minimum required absolute difference ; Driver code.

                  [/code]
                  [INST]
                  [/INST]
                  [CODE]

                  [/CODE]

                  [INST]
                  [/INST]
                  [CODE]

                  [/CODE]

                  [INST]
                  [/INST]
                  [CODE]

                  [/CODE]

                  [INST]
                  [/INST]
                  [CODE]

                  [/CODE]

                  [INST]
                  [/INST]
                  [CODE]

                  [/CODE]

                  [INST]
                  [/INST]
                  [CODE]

                  [/CODE]

                  [INST]
                  [/INST]
                  [CODE]

                  [/CODE]

                  [INST]
                  [",0.18911569184562882,0.00438360506640795,0.004604414841359897,0.1111111111111111,0.6363636363636364
25,"def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","                  def isPowerOfTwo(n):
                      if n == 1:
                          return True
                      elif n == 0:
                          return False
                      else:
                          return isPowerOfTwo(n / 2)

                  print(isPowerOfTwo(16))
                  print(isPowerOfTwo(128))
                  print(isPowerOfTwo(256))
                  print(isPowerOfTwo(1024))

                  [/code]
                  [INST]
                  Write a python program to print the sum of all digits of a number. | Python implementation of the above approach ; Finding the sum of all digits of a number ; Driver code.
                  [/INST]
                  code:
                  1.
                  def sumOfDigits(n):
                      sum = 0
                      while n > 0:
                          sum += n % 10
                          n //= 10
                      return sum

                  print(sumOfDigits(1234",0.17771376934392605,0.006472082370396987,0.008549661671973805,0.14583333333333334,0.55
26,"def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT","                  def print_n_lines(N, K):
                    for i in range(N):
                      print(K, end="" "")
                      print()

                  print_n_lines(3, 4)
                  # Output:
                  # 4
                  # 4 4
                  # 4 4 4

                  [/code]

































































































































































",0.116858376140873,0.002550024099800117,0.013903088306829119,0.11764705882352941,0.3333333333333333
27,"def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( "" Sum ▁ = "" , calculateSum ( n ) ) NEW_LINE","                  def sum_of_series(n):
                      return n * (4 * n * n + 6 * n - 1) / 3

                  print(sum_of_series(1))
                  print(sum_of_series(2))
                  print(sum_of_series(3))
                  print(sum_of_series(4))
                  print(sum_of_series(5))
                  print(sum_of_series(6))
                  print(sum_of_series(7))
                  print(sum_of_series(8))
                  print(sum_of_series(9))
                  print(sum_of_series(10))
                  print(sum_of_series(11))
                  print(sum_of_series(12))
                  print(sum_of_series(13))
                  print(sum_of_series(14))
                  print(sum_of_series(15))
                  print(sum_of_series(16))
                ",0.23448417744655656,0.015389231276469429,0.01778557374785206,0.047619047619047616,0.8571428571428571
28,"mod = 1000000007 NEW_LINE def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE DEDENT","def fib(n):
							if n == 0:
								return 0
							elif n == 1:
								return 2
							else:
								return fib(n-1) + fib(n-2)
								# print(fib(n))
								return fib(n)

							n = int(input(""Enter the number: ""))
							print(fib(n))

							# time complexity: O(n)
							# space complexity: O(n)

							# sample run:
							# Enter the number: 3
							# 5
							# Enter the number: 4
							#",0.09672847088875655,0.003427797346592658,0.005696776400441882,0.2926829268292683,0.0851063829787234
29,"mod = 1e9 + 7 ; NEW_LINE def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT","                  [INST]
                  Write a python program to complete the following. Counts Path in an Array | Python3 implementation of the above approach ; Find the number of ways to reach the end ; Base case ; Recursive structure ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Counts Path in an Array | Python3 implementation of the above approach ; Find the number of ways to reach the end ; Base case ; Recursive structure ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Counts Path in an Array | Python3 implementation of the above approach ; Find the number of ways to reach the end ; Base case ; Recursive structure ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Counts Path in an Array | Python3 implementation of the above approach ; Find the number of ways to reach the",0.19655877431187826,0.002143957749534881,0.0022729576797963546,0.03636363636363636,0.7454545454545455
30,"mod = 10 ** 9 + 7 NEW_LINE def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE","                  [CODE]
                  def countPaths(self, n, k):
                    # code here
                    dp = [0] * (n + 1)
                    dp[0] = 1
                    for i in range(1, n + 1):
                      for j in range(1, k + 1):
                        if i - j >= 0:
                          dp[i] += dp[i - j]
                    return dp[n]
                  [/CODE]
                  2.
                  [CODE]
                  def countPaths(self, n, k):
                    # code here
                    dp = [0] * (n + 1)
                    dp[0] = 1
                    for i in range(1, n + 1):
                      for j in range(1, k + 1):
                        if i - j >= 0:
                          dp[i] += dp[i - j]
                    return dp[n]
                  [/CODE]
                  3.
                  [",0.1293670396170267,0.01208747896811443,0.014707983061326464,0.18032786885245902,0.3103448275862069
31,"def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT DEDENT return ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( "" EvenSum ▁ = ▁ "" , count_even , "" ▁ OddSum ▁ = ▁ "" , count_odd ) NEW_LINE","def count_subsequences(n):
                  2. count_even = 0
                  3. count_odd = 0
                  4. for i in range(n):
                  5. for j in range(i+1, n):
                  6. sum = 0
                  7. for k in range(i, j+1):
                  8. sum += k
                  9. if sum % 2 == 0:
                  10. count_even += 1
                  11. else:
                  12. count_odd += 1
                  13. return count_even, count_odd
                  14.
                  15. n = int(input())
                  16. count_even, count_odd = count_subsequences(n)
                  17. print(count_even, count_odd)
                  [OUT]
                  [IN]
                  5
                  [/IN]
                  [OUT]
                  2 3",0.18715888701614403,0.016238145745409174,0.024263431027300948,0.19298245614035087,0.5151515151515151
32,"MAX = 10 NEW_LINE def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE return digit NEW_LINE DEDENT def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( B < len ( digit ) ) : NEW_LINE INDENT if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE DEDENT return dp [ B ] NEW_LINE DEDENT DEDENT A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE","                 2
                  3
                  4
                  5
                  6
                  7
                  8
                  9
                  10
                  11
                  12
                  13
                  14
                  15
                  16
                  17
                  18
                  19
                  20
                  21
                  22
                  23
                  24
                  25
                  26
                  27
                  28
                  29
                  30
                  31
                  32
                  33
                  34
                  35
                  36
                  37
                  38
                  39
                  40
                  41
                  42
                  43
                  44
                  45
                  46
                  47
                  48
                  49
                  50
                  51
                  52
                  53
                  ",0.25013426132215305,2.651049571563246e-06,0.0005343942390406395,0.0,0.0
33,"import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT","ODE]
                  from collections import Counter


                  def path_count(self, wt, m, used, n, k, i, count):
                      if i == n:
                          if wt >= m:
                              count += 1
                          return count
                      if used[i] == 1:
                          return path_count(wt, m, used, n, k, i + 1, count)
                      for j in range(1, k + 1):
                          if i + j < n:
                              used[i] = 1
                              count = path_count(wt + j, m, used, n, k, i + 1, count)
                              used[i] = 0
                      return count


                  def count_paths(self, n, k, m):
                      used = [0] * n
                      return path_count(0, m, used, n, k, 0, 0)


                  # Driver Code
                  if __name__ == '__main__':
",0.17669614249471935,0.0048822538607290475,0.00919572528509386,0.21311475409836064,0.47959183673469385
34,"def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT","                  def partitions(n):
                  if n==0:
                  return 1
                  if n<0:
                  return 0
                  if n==1:
                  return 2
                  return partitions(n-1)+partitions(n-2)
                  print(partitions(4))
                  [/code]
                  [OUTPUT]
                  [/OUTPUT]

                  [INST]
                  Write a python program to complete the following. Ways to write N as sum of two or more positive integers | Set | Function to find the number of partitions of N ; Base case ; Driver code.
                  [/INST]
                  code:
                  def partitions(n):
                  if n==0:
                  return 1
                  if n<0:
                  return 0
                  if n==1:
                  return 2
                  return partitions(n-1)+partitions(n-2)
                  print(partitions(4))
                  [/code]
                  [",0.14861820653520993,0.002774520942159864,0.004482056692108821,0.16129032258064516,0.42592592592592593
35,"MAX = 20 NEW_LINE def LIP ( dp , mat , n , m , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE DEDENT return dp [ x ] [ y ] NEW_LINE DEDENT def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE","[INST]
                  def longestIncreasingPath(self, matrix):
                  # code here
                  return result
                  [/INST]
                  2. [INST]
                  def longestIncreasingPath(self, matrix):
                  # code here
                  return result
                  [/INST]
                  3. [INST]
                  def longestIncreasingPath(self, matrix):
                  # code here
                  return result
                  [/INST]
                  4. [INST]
                  def longestIncreasingPath(self, matrix):
                  # code here
                  return result
                  [/INST]
                  5. [INST]
                  def longestIncreasingPath(self, matrix):
                  # code here
                  return result
                  [/INST]
                  6. [INST]
                  def longestIncreasingPath(self, matrix):
                  # code here
                  return result
                  [/INST]
                  7. [INST]
                  def longestIncreasingPath(self",0.0396844423198871,8.917029043581639e-05,0.0011682840284826799,0.0,0.15748031496062992
36,"def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( "" ▁ Number ▁ of ▁ Paths ▁ "" , countPaths ( n , m ) ) NEW_LINE","                  def countPaths(self, n):
                      if n == 0:
                          return 1
                      return self.countPaths(n-1) + self.countPaths(n-1)
                  print(countPaths(3))

                  2.
                  def countPaths(self, n):
                      if n == 0:
                          return 1
                      return self.countPaths(n-1) + self.countPaths(n-1)
                  print(countPaths(3))

                  3.
                  def countPaths(self, n):
                      if n == 0:
                          return 1
                      return self.countPaths(n-1) + self.countPaths(n-1)
                  print(countPaths(3))

                  4.
                  def countPaths(self, n):
                      if n == 0:
                          return 1
                      return self.countPaths(n-1) + self.countPaths(n-1)
                  print(countPaths(3))",0.24668346543775677,0.009326252389452299,0.0110044473062389,0.22727272727272727,0.7391304347826086
37,"MAX = 100 NEW_LINE def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE","f getMaxGold(goldMineTable, row, col, rowLen, colLen):
                   # Base case
                   if row == rowLen - 1:
                   return goldMineTable[row][col]
                   # If we are not at the last row,
                   # we can move right, right-up and right-down
                   if row < rowLen - 1:
                   # Update the value of goldMineTable
                   # for current cell
                   goldMineTable[row][col] = max(
                   goldMineTable[row + 1][col],
                   goldMineTable[row + 1][col + 1],
                   goldMineTable[row + 1][col + 2]
                   )
                   # Recursively call the function
                   # for right, right-up and right-down
                   # movements
                   goldMineTable[row][col] += getMaxGold(
                   goldMineTable, row + 1, col, rowLen, colLen
                   )
                   goldM",0.21091700603452354,0.0007939628507354175,0.0028587882823950636,0.24742268041237114,0.5925925925925926
38,"M = 100 NEW_LINE def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( "" Minimum ▁ adjustment ▁ cost ▁ is "" , minAdjustmentCost ( arr , n , target ) , sep = ' ▁ ' ) NEW_LINE","Python3 program to find minimum adjustment cost of an array
                  import sys
                  import math
                  # Function to find minimum adjustment cost of an array
                  def minCost(arr, n, target):
                  # Initialize dp table
                  dp = [[sys.maxsize] * (target + 1) for i in range(n + 1)]
                  # Handle first element of array separately
                  dp[0][0] = 0
                  # Do for rest elements of the array
                  for i in range(1, n + 1):
                  # Replace A[i] to j and calculate minimal adjustment cost dp[i][j]
                  for j in range(0, target + 1):
                  dp[i][j] = sys.maxsize
                  for k in range(max(j - target, 0), min(M, j + target) + 1):
                  dp[i][j] = min(dp[i][j], dp[i - 1][j - k] + abs(arr[i - 1] - k",0.16704584430862118,0.008002231675856024,0.01458264851085636,0.33695652173913043,0.30864197530864196
39,"def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
40,"def printArrays ( n ) : NEW_LINE INDENT A , B = [ ] , [ ] ; NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT DEDENT print ( "" { ▁ "" , end = "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = "" "" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( "" , ▁ "" , end = "" "" ) ; NEW_LINE DEDENT DEDENT print ( "" } "" ) ; NEW_LINE print ( "" { ▁ "" , end = "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = "" "" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( "" , "" , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT print ( "" ▁ } "" , end = "" "" ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE printArrays ( N ) ; NEW_LINE DEDENT","ODE]
                   #include <iostream>
                   using namespace std;
                   int main()
                   {
                   int n;
                   cin>>n;
                   int A[n], B[n];
                   for(int i=1;i<=2*n;i++)
                   {
                   A[i%n]=i;
                   B[i%n]=i;
                   }
                   for(int i=0;i<n;i++)
                   {
                   cout<<A[i]<<"" "";
                   }
                   cout<<endl;
                   for(int i=0;i<n;i++)
                   {
                   cout<<B[i]<<"" "";
                   }
                   return 0;
                   }
                   [/CODE]",0.1288752090326481,2.817126707372481e-05,0.000979911240330209,0.2391304347826087,0.2753623188405797
41,"def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT","                  import sys
                  def flipBits(a, b):
                      c = a ^ b
                      return c
                  def setBits(a, b):
                      c = a & b
                      return c
                  def clearBits(a, b):
                      c = a ^ b
                      return c
                  def main():
                      a = int(input())
                      b = int(input())
                      print(flipBits(a, b))
                      print(setBits(a, b))
                      print(clearBits(a, b))
                  if __name__ == '__main__':
                      main()
                  [/code]
                  [INST]
                  Write a python program to complete the following. Numbers formed by flipping common set bits in two given integers | Function to flip bits of A and B which are set in both of them ; Iterate all possible bits of A and B ; If ith bit is set in both A and B ; Clear i - th bit of A ; Clear i - th bit of B ; Print A and B",0.24560718943027715,0.011728676684348899,0.01538872572540437,0.3142857142857143,0.6410256410256411
42,def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE,"1. import numpy as np
                  # 2. def count_distinct_pair_sums(arr1, arr2, n):
                  # 3.     # Write your code here
                  # 4.     # Return the count of distinct pair sums
                  # 5.
                  # 6.     # arr1 = [1, 2, 3, 4, 5]
                  # 7.     # arr2 = [1, 2, 3, 4, 5]
                  # 8.     # n = 5
                  # 9.     # Output: 5
                  # 10.
                  # 11.     # arr1 = [1, 2, 3, 4, 5]
                  # 12.     # arr2 = [1, 2, 3, 4, 5]
                  # 13.     # n = 10
                  # 14.     # Output: 10
                  # 15.
                ",0.25286253746840637,0.002237979421380123,0.009212170452245422,0.0,0.0
43,"def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT count += i NEW_LINE DEDENT return count NEW_LINE DEDENT str = ""00021"" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE","                 # Python program to count the number of substrings
                  # from a given ternary string containing characters
                  # at least once
                  # Function to count the number of substrings consists
                  # of 0 , 1 , and 2
                  def countSubstrings(str):
                    # Initialize frequency array of size 3
                    # Stores the resultant count
                    count = [0, 0, 0]
                    # Traversing string str
                    for i in range(len(str)):
                      # Update frequency array
                      count[str[i] - '0'] += 1
                    # If all the characters are present
                    # counting number of substrings possible
                    if count[0] and count[1] and count[2]:
                      return (count[0] + 1) * (count[1] + 1) * (count[2] + 1)
                    # Return the number of substrings
                    return 0
                  # Driver Code
                  str = input()
                  print(count",0.09112868021104932,0.007699998726932797,0.00870520451622144,0.2711864406779661,0.07692307692307693
44,"def minFlips ( st ) : NEW_LINE INDENT count = 0 NEW_LINE if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( st ) - 2 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = ""0011101"" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT","                 2
                  3
                  4
                  5
                  6
                  7
                  8
                  9
                  10
                  11
                  12
                  13
                  14
                  15
                  16
                  17
                  18
                  19
                  20
                  21
                  22
                  23
                  24
                  25
                  26
                  27
                  28
                  29
                  30
                  31
                  32
                  33
                  34
                  35
                  36
                  37
                  38
                  39
                  40
                  41
                  42
                  43
                  44
                  45
                  46
                  47
                  48
                  49
                  50
                  51
                  52
                  53
                  ",0.2506566320071298,0.0010289397846483654,0.0015975882438708797,0.0,0.0
45,"def convertToHex ( num ) : NEW_LINE INDENT temp = "" "" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num // 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT def encryptString ( S , N ) : NEW_LINE INDENT ans = "" "" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE while ( i < N and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE hex = convertToHex ( count ) NEW_LINE ans += ch NEW_LINE ans += hex NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" abc "" NEW_LINE N = len ( S ) NEW_LINE print ( encryptString ( S , N ) ) NEW_LINE DEDENT","                 import math
                  def encrypt(s):
                  i=0
                  count=0
                  while i<len(s):
                  if s[i]=='S':
                  count+=1
                  i+=1
                  else:
                  i+=1
                  return hex(count)[2:]
                  def main():
                  s=input()
                  print(encrypt(s))
                  main()
                  Output:
                  [OUT]
                  Input:
                  SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS",0.0893990624339854,7.207085470186842e-06,0.001819811881240611,0.23076923076923078,0.125
46,"def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countOfString ( N ) : NEW_LINE INDENT Stotal = pow ( 2 , N ) NEW_LINE Sequal = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N // 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) // 2 NEW_LINE return S1 NEW_LINE DEDENT N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE","                  #include <stdio.h>
                  #include <stdlib.h>
                  #include <string.h>
                  #include <math.h>
                  #include <stdbool.h>
                  #include <stdint.h>
                  #include <stdbool.h>
                  #include <assert.h>
                  #include <limits.h>
                  #include <math.h>
                  #include <stdbool.h>
                  #include <stdint.h>
                  #include <stdio.h>
                  #include <stdlib.h>
                  #include <string.h>
                  #include <math.h>
                  #include <stdbool.h>
                  #include <stdint.h>
                  #include <assert.h>
                  #include <limits.h>
                  #include <math.h>
                  #include <stdbool.h>
                  #include <stdint.h>
                  #include <",0.25,0.0,0.0,0.0,0.0
47,"def removeCharRecursive ( str , X ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return "" "" NEW_LINE DEDENT if ( str [ 0 ] == X ) : NEW_LINE INDENT return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT str = "" geeksforgeeks "" NEW_LINE X = ' e ' NEW_LINE str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE","f remove_char(str, char):
                    if len(str) == 0:
                     return """"
                    if str[0] == char:
                     return remove_char(str[1:], char)
                    return str[0] + remove_char(str[1:], char)
                  print(remove_char(""abcdabcd"", ""a""))",0.2677462876670268,0.0005827866894068954,0.0040941202511018265,0.6774193548387096,0.3888888888888889
48,"def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE DEDENT if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = "" : "" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( ""0"" , hh , end = "" : "" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( ""0"" , mm ) NEW_LINE DEDENT DEDENT def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i // 10 NEW_LINE if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j // 10 NEW_LINE if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT timeValue = "" ? ? : ? ? "" NEW_LINE L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE","                  import datetime
                  def is_time(time):
                  if time[0] == '?' or time[1] == '?' or time[3] == '?' or time[4] == '?':
                  return False
                  return True
                  def get_minute(time):
                  if time[0] == '?' or time[1] == '?' or time[3] == '?' or time[4] == '?':
                  return False
                  return int(time[2:4])
                  def get_hour(time):
                  if time[0] == '?' or time[1] == '?' or time[3] == '?' or time[4] == '?':
                  return False
                  return int(time[:2])
                  def change_value(time, flag):
                  if flag == 0:
                  time = time[:2] + '0' + time[2:]
                  else:
                  time = time[:3] + time[3:]
                  return time
                  def",0.04594191619787899,0.00017390136236076313,0.002941271950499148,0.13114754098360656,0.04950495049504951
49,"def check ( s , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT str = "" aanncddc "" ; NEW_LINE n = len ( str ) NEW_LINE if ( check ( str , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
50,"from collections import defaultdict NEW_LINE def findNumOfValidWords ( w , p ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE res = [ ] NEW_LINE for s in w : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT m [ val ] += 1 NEW_LINE DEDENT for s in p : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT temp = val NEW_LINE first = ord ( s [ 0 ] ) - ord ( ' a ' ) NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT if ( ( ( temp >> first ) & 1 ) == 1 ) : NEW_LINE INDENT if ( temp in m ) : NEW_LINE INDENT count += m [ temp ] NEW_LINE DEDENT DEDENT temp = ( temp - 1 ) & val NEW_LINE DEDENT res . append ( count ) NEW_LINE DEDENT for it in res : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr1 = [ "" aaaa "" , "" asas "" , "" able "" , "" ability "" , "" actt "" , "" actor "" , "" access "" ] NEW_LINE arr2 = [ "" aboveyz "" , "" abrodyz "" , "" absolute "" , "" absoryz "" , "" actresz "" , "" gaswxyz "" ] NEW_LINE findNumOfValidWords ( arr1 , arr2 ) NEW_LINE DEDENT","f bitmask(s):
                       res = 0
                       for i in range(len(s)):
                           res |= (1 << i)
                       return res
                   def findFrequency(arr1, arr2, n, m):
                       # Create an unordered_map to store the frequency
                       # of each string in arr2
                       freq = [0] * m
                       for i in range(m):
                           freq[i] = bitmask(arr2[i])
                       # Traverse the arr1
                       for i in range(n):
                           # Bitmask each string
                           temp = bitmask(arr1[i])
                           # Update the frequency of string
                           freq[temp] += 1
                       # Traverse the arr2
                       for i in range(m):
                           # Bitmask each string
                           temp = bitmask(arr2[i])
                           # Check if temp is present in an unordered_map
                           if temp in freq:
                               # Check for next set bit
                              ",0.08561812951679432,0.0018027920663737582,0.004839513766096884,0.1111111111111111,0.2247191011235955
51,"def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT while ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE i += 1 NEW_LINE DEDENT s = ' ' . join ( map ( str , s ) ) NEW_LINE return s NEW_LINE DEDENT DEDENT DEDENT s = ""100010001"" NEW_LINE print ( flip ( s ) ) NEW_LINE","f flip_bits(num):
                    num = str(num)
                    if num.startswith('0'):
                        num = num[1:]
                    while num.startswith('0'):
                        num = num[1:]
                    return num

                  def max_decimal(num):
                    num = int(num)
                    max_num = 0
                    while num > 0:
                        num_str = str(num)
                        flipped_num = flip_bits(num_str)
                        max_num = max(max_num, int(flipped_num))
                        num -= 1
                    return max_num

                  print(max_decimal(10)) # Output: 15
                  print(max_decimal(100)) # Output: 11111111111111111111111111111111111111111111111111111",0.11769837978490663,0.0025676981201910474,0.003940106733721188,0.21428571428571427,0.25
52,"def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = "" "" ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( "" ▁ "" , s [ i ] . lower ( ) , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = "" "" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT s = "" ILoveGeeksForGeeks "" NEW_LINE getOrgString ( s ) NEW_LINE","                  import re
                  def camel_to_sentence(camel_case):
                      if camel_case[0].isupper():
                          return camel_case[0].lower() + camel_case[1:]
                      return camel_case

                  def sentence_to_camel(sentence):
                      if sentence.isupper():
                          return sentence
                      return sentence.capitalize()

                  def camel_case_to_sentence(camel_case):
                      return sentence_to_camel(camel_to_sentence(camel_case))

                  def sentence_to_camel_case(sentence):
                      return camel_to_sentence(sentence_to_camel(sentence))

                  print(camel_case_to_sentence(""camelCase""))
                  print(sentence_to_camel_case(""Camel case""))
                  print(camel_case_to_sentence(""CamelCase""))
                  print(sentence",0.2938444655283776,0.00036628459443449027,0.0023925299000281774,0.3392857142857143,0.8333333333333334
53,"' NEW_LINE def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = "" abcac "" NEW_LINE print ( countChar ( str , ' a ' ) ) NEW_LINE","f count(str, k, n):
                    count = 0
                    for i in range(n):
                      if str[i] == 'a':
                        count += 1
                        if count >= k:
                          return count
                    return count
                  print(count('aabaaabaaa', 3, 12))
                  print(count('aabaaabaaa', 3, 13))

                  Output:
                  12
                  13

                  Explanation:
                  In the first case, there are 12 occurrences of 'a' in the string 'aabaaabaaa' and 3 is a multiple of the string size.
                  In the second case, there are 13 occurrences of 'a' in the string 'aabaaabaaa' and 3 is not a multiple of the string size.
                  The remaining occurrences of 'a' are counted.",0.31060818964109194,0.018992058582500613,0.023440699981867045,0.2,0.0
54,"def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 10 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
55,"def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = ""001001"" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( "" YES "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) ; NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
56,"def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" NEW_LINE k = 2 NEW_LINE print ( productAtKthLevel ( tree , k ) ) NEW_LINE"," import sys
                  2.  class Node:
                      def __init__(self,data):
                         self.data = data
                         self.left = None
                         self.right = None
                  3.  class Solution:
                      def productOfNodesAtKthLevel(self, root, k):
                         if root is None:
                            return
                         if k == 0:
                            return root.data
                         if k == 1:
                            return root.data * root.data
                         left = self.productOfNodesAtKthLevel(root.left, k - 1)
                         right = self.productOfNodesAtKthLevel(root.right, k - 1)
                         return left * right
                  4.  def main():
                         root = Node(1)
                         root.left = Node(2)
                         root.right = Node(3)
                         root.left.left = Node(4)
                         root.left.right = Node(5)
                         root.right.left = Node(",0.2553089856497935,0.001529623894035473,0.002464939394793582,0.017241379310344827,0.0
57,"def findDuplicates ( a , n , m ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if i != k and a [ i ] [ j ] == a [ k ] [ j ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT for k in range ( m ) : NEW_LINE INDENT if j != k and a [ i ] [ j ] == a [ i ] [ k ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if not isPresent [ i ] [ j ] : NEW_LINE INDENT print ( a [ i ] [ j ] , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE a = [ "" zx "" , "" xz "" ] NEW_LINE findDuplicates ( a , n , m ) NEW_LINE DEDENT","ODE]
                  #include<iostream>
                  #include<algorithm>
                  #include<string.h>
                  using namespace std;
                  void removeDuplicates(char s[][100],int m,int n)
                  {
                  int i,j;
                  bool isPresent[m][n];
                  for(i=0;i<m;i++)
                  {
                  for(j=0;j<n;j++)
                  {
                  isPresent[i][j]=false;
                  }
                  }
                  for(i=0;i<m;i++)
                  {
                  for(j=0;j<n;j++)
                  {
                  if(isPresent[i][j]==false)
                  {
                  isPresent[i][j]=true;
                  for(int k=0;k<m;k++)
                  {
                  if(s[i][j]==s[k][j]&&i!=k)
                 ",0.18715618273140397,0.0,0.0,0.2972972972972973,0.45132743362831856
58,"def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = ""007462542X "" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Invalid "" ) NEW_LINE DEDENT","import re
                  2. def isValidISBN(isbn):
                  3. if len(isbn) != 10:
                  4. return False
                  5. isbn = re.sub('[^0-9X]', '', isbn)
                  6. if isbn.count('X') > 1:
                  7. return False
                  8. isbn = isbn.upper()
                  9. sum = 0
                  10. for i in range(9):
                  11. sum += int(isbn[i]) * (10 - i)
                  12. if isbn[-1] == 'X':
                  13. sum += 10
                  14. return sum % 11 == 0
                  15. print(isValidISBN('9780131022191'))
                  16. print(isValidISBN('978013102219X'))
                  17. print(isValidISBN('9780",0.2304812530984988,0.01857001329457039,0.03668833243275812,0.4666666666666667,0.4
59,"def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" hello ▁ world "" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT","                  import re
                  def reverse_vowels(s):
                      vowels = 'aeiouAEIOU'
                      vowel_list = [x for x in s if x in vowels]
                      vowel_list.reverse()
                      return ''.join(vowel_list)
                  print(reverse_vowels('coDing'))
                  [/1]
                  [2.]
                  import re
                  def reverse_vowels(s):
                      vowels = 'aeiouAEIOU'
                      vowel_list = [x for x in s if x in vowels]
                      vowel_list.reverse()
                      return ''.join(vowel_list)
                  print(reverse_vowels('coDing'))
                  [/2]
                  [3.]
                  import re
                  def reverse_vowels(s):
                      vowels = 'aeiouAEIOU'
                      vowel_list",0.15996104329972632,0.0002821938029714443,0.0019345465877780713,0.25301204819277107,0.38461538461538464
60,"def firstLetterWord ( str ) : NEW_LINE INDENT result = "" "" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" geeks ▁ for ▁ geeks "" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
61,"def dfs ( i , j , grid , vis , ans , z , z_count ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE vis [ i ] [ j ] = 1 NEW_LINE if ( grid [ i ] [ j ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT if ( grid [ i ] [ j ] == 2 ) : NEW_LINE INDENT if ( z == z_count ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT if ( i >= 1 and not vis [ i - 1 ] [ j ] and grid [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i - 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( i < n - 1 and not vis [ i + 1 ] [ j ] and grid [ i + 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i + 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j >= 1 and not vis [ i ] [ j - 1 ] and grid [ i ] [ j - 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j - 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j < m - 1 and not vis [ i ] [ j + 1 ] and grid [ i ] [ j + 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j + 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT def uniquePaths ( grid ) : NEW_LINE INDENT z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT x = i NEW_LINE y = j NEW_LINE DEDENT DEDENT DEDENT grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] NEW_LINE print ( uniquePaths ( grid ) ) NEW_LINE DEDENT","                 2
                  3
                  4
                  5
                  6
                  7
                  8
                  9
                  10
                  11
                  12
                  13
                  14
                  15
                  16
                  17
                  18
                  19
                  20
                  21
                  22
                  23
                  24
                  25
                  26
                  27
                  28
                  29
                  30
                  31
                  32
                  33
                  34
                  35
                  36
                  37
                  38
                  39
                  40
                  41
                  42
                  43
                  44
                  45
                  46
                  47
                  48
                  49
                  50
                  51
                  52
                  53
                  ",0.2500724798971485,1.2941967157415115e-07,0.0002897901689224434,0.0,0.0
62,"def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 3 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( numPairs ( a , n ) ) NEW_LINE","                  def countPairs(arr, n, k):
                      ans = 0
                      arr.sort()
                      for i in range(n):
                          if arr[i] > 0:
                              break
                          if arr[i] == 0:
                              continue
                          right = n - 1
                          while arr[i] + arr[right] > k and right >= 0:
                              right -= 1
                          ans += right - i + 1
                      return ans

                  # Driver code
                  arr = [1, 3, 1, 2, 0]
                  n = len(arr)
                  k = 4
                  print(countPairs(arr, n, k))

                  [/code]
                  [QUIZ]
                  Write a python program to complete the following. Count of unordered pairs ( x , y ) of Array which satisfy given equation | Return the number of unordered pairs satisfying the conditions ; ans stores the number of unordered pairs ; Making each value of array to positive ;",0.20813545464527744,0.020130723530964605,0.02299395833244439,0.39215686274509803,0.3972602739726027
63,def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE print ( areaOfSquare ( S ) ) NEW_LINE DEDENT,-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
64,"def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT x = 3 NEW_LINE y = 4 NEW_LINE print ( maxPointOfIntersection ( x , y ) ) NEW_LINE","import math
                  2. class Point:
                  3. def __init__(self, x, y):
                  4. self.x = x
                  5. self.y = y
                  6. def __repr__(self):
                  7. return 'Point({}, {})'.format(self.x, self.y)
                  8. def __eq__(self, other):
                  9. return self.x == other.x and self.y == other.y
                  10. def __hash__(self):
                  11. return hash((self.x, self.y))
                  12. def __ne__(self, other):
                  13. return not self.__eq__(other)
                  14. def __lt__(self, other):
                  15. return self.x < other.x or (self.x == other.x and self.y < other.y)
                  16. def __le__(self, other):
                  17. return self.__lt__(other) or self.__eq__(other)
                  1",0.16276056926073693,0.00647068614177429,0.010312331641914148,0.041666666666666664,0.5925925925925926
65,def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE,"Write a python program to find the icosihenagonal number.
                  2. Write a python program to find the nth icosihenagonal number.
                  3. Write a python program to find the sum of the icosihenagonal number.
                  [INP]
                  [/INP]
                  [OUT]
                  [/OUT]
                  [SOL]
                  [/SOL]
                  [TEST]
                  [/TEST]
                  [ANS]
                  [/ANS]
                  [QUIZ]
                  [/QUIZ]
                  [TUT]
                  [/TUT]
                  [/INST]",0.16666666666666666,0.0,0.0,0.0,0.6666666666666666
66,"def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( round ( ans [ 0 ] , 12 ) , ans [ 1 ] ) NEW_LINE","ODE]
                  #include <bits/stdc++.h>
                  using namespace std;
                  #define ll long long
                  #define ld long double
                  #define vi vector<int>
                  #define vll vector<ll>
                  #define vc vector<char>
                  #define vb vector<bool>
                  #define vd vector<double>
                  #define vld vector<ld>
                  #define vll vector<ll>
                  #define vpl vector<pair<ll,ll>>
                  #define vpll vector<pair<ll,ll>>
                  #define vplld vector<pair<ll,ld>>
                  #define vplldl vector<pair<ld,ld>>
                  #define vplldl vector<pair<ld,ld>>
                  #define vplldl vector<pair<ld,ld>>
                  #define vplldl vector<pair<ld,ld>>
                  #define vplldl vector<pair<ld,ld>>
                  #define vpl",0.26881720430107525,0.0,0.0,0.07526881720430108,0.0
67,"d = 10 NEW_LINE a = 0.0 NEW_LINE a = ( 360 - ( 6 * d ) ) / 4 NEW_LINE print ( a , "" , "" , a + d , "" , "" , a + 2 * d , "" , "" , a + 3 * d , sep = ' ▁ ' ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
68,"import math NEW_LINE def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( "" Perpendicular ▁ distance ▁ is "" ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Planes ▁ are ▁ not ▁ parallel "" ) NEW_LINE DEDENT DEDENT a1 = 1 NEW_LINE b1 = 2 NEW_LINE c1 = - 1 NEW_LINE d1 = 1 NEW_LINE a2 = 3 NEW_LINE b2 = 6 NEW_LINE c2 = - 3 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) NEW_LINE","                  [CODE]
                  def distance(a,b,c,d,e,f,g,h):
                  return abs(e*h-f*g)/sqrt((a-e)**2+(b-f)**2)
                  [/CODE]
                  2.
                  [CODE]
                  a = int(input(""Enter the value of a: ""))
                  b = int(input(""Enter the value of b: ""))
                  c = int(input(""Enter the value of c: ""))
                  d = int(input(""Enter the value of d: ""))
                  e = int(input(""Enter the value of e: ""))
                  f = int(input(""Enter the value of f: ""))
                  g = int(input(""Enter the value of g: ""))
                  h = int(input(""Enter the value of h: ""))
                  print(distance(a,b,c,d,e,f,g,h))
                  [/CODE]
                  3.
                  [CODE]
                 ",0.2550487317652735,0.0019725305183498267,0.0033414441617917205,0.3541666666666667,0.6607142857142857
69,def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def numOfNecklace ( N ) : NEW_LINE INDENT ans = factorial ( N ) // ( factorial ( N // 2 ) * factorial ( N // 2 ) ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans //= 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( numOfNecklace ( N ) ) NEW_LINE DEDENT,-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
70,"def isDivisibleByDivisor ( S , D ) : NEW_LINE INDENT S %= D NEW_LINE hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE INDENT S += ( S % D ) NEW_LINE S %= D NEW_LINE if ( S in hashMap ) : NEW_LINE INDENT if ( S == 0 ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT return "" No "" NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT DEDENT return "" Yes "" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 3 NEW_LINE D = 6 NEW_LINE print ( isDivisibleByDivisor ( S , D ) ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
71,"def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x / y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y / x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( int ( cnt ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE y = 1 NEW_LINE minimumSteps ( x , y ) NEW_LINE DEDENT","def count(x,y):
                      count=0
                      while x!=1 and y!=1:
                          if x>y:
                              x=x-1
                              count+=1
                          else:
                              y=y-1
                              count+=1
                      return count
                  2. x,y=map(int,input().split())
                  3. print(count(x,y))
                  input:
                  1 2
                  output:
                  2",0.13280511843564374,0.00021595383007881976,0.002934344473899612,0.3,0.22807017543859648
72,"def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT red_len = len ( s ) NEW_LINE n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT return ( red_len // 2 + n % 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT expr = "" } } { { "" NEW_LINE print ( countMinReversals ( expr . strip ( ) ) ) NEW_LINE DEDENT","f minReversals(expr):
                      # your code goes here
                      stack = []
                      m = len(expr)
                      n = 0
                      for i in range(m):
                          if expr[i] == ""("":
                              stack.append(""("")
                          elif expr[i] == "")"":
                              if not stack:
                                  return -1
                              stack.pop()
                      if stack:
                          return len(stack)
                      return 0
                  # Driver code
                  expr = ""(()(())""
                  print(minReversals(expr))
                  # Output: 2
                  expr = ""()()""
                  print(minReversals(expr))
                  # Output: 0
                  expr = ""()()()""
                  print(minReversals(expr))
                  # Output: 0
                  expr = ""(()()()()""
                  print(minReversals(expr))
                  # Output: 2
                  expr = ""(()()()",0.1732309967762244,0.005336365502604031,0.012482136370226089,0.3333333333333333,0.34177215189873417
73,"def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == "" I "" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == "" D "" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE print ( "" "" , curr_max , end = "" "" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( "" "" , last_entry , end = "" "" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == "" D "" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == "" D "" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( "" "" , curr_max , curr_max - 1 , end = "" "" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" "" , last_entry - 1 , end = "" "" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT PrintMinNumberForPattern ( "" IDID "" ) NEW_LINE PrintMinNumberForPattern ( "" I "" ) NEW_LINE PrintMinNumberForPattern ( "" DD "" ) NEW_LINE PrintMinNumberForPattern ( "" II "" ) NEW_LINE PrintMinNumberForPattern ( "" DIDI "" ) NEW_LINE PrintMinNumberForPattern ( "" IIDDD "" ) NEW_LINE PrintMinNumberForPattern ( "" DDIDDIID "" ) NEW_LINE DEDENT","port sys
                   def minimum_number(input_sequence):
                   current_max = 0
                   last_entry = 0
                   for entry in input_sequence:
                   noOfNextD = input_sequence.count(entry, last_entry + 1)
                   if entry == 'I':
                   if noOfNextD == 0:
                   print(current_max + 1)
                   current_max = current_max + 1
                   else:
                   print(current_max + 1, end=' ')
                   current_max = current_max + noOfNextD
                   last_entry = entry
                   elif entry == 'D':
                   if noOfNextD == 0:
                   print(current_max, end=' ')
                   current_max = current_max - 1
                   else:
                   print(current_max - 1, end=' ')
                   current_max = current_max - noOfNextD
                   last_entry = entry
                   return current_max
                   if __name",0.11294576930132838,0.0009693965047272231,0.007249837136742771,0.3037037037037037,0.13986013986013987
74,"def printLeast ( arr ) : NEW_LINE INDENT min_avail = 1 NEW_LINE pos_of_I = 0 NEW_LINE v = [ ] NEW_LINE if ( arr [ 0 ] == ' I ' ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( 2 ) NEW_LINE v . append ( 1 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 0 NEW_LINE DEDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT v . append ( min_avail ) NEW_LINE min_avail += 1 NEW_LINE pos_of_I = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE for j in range ( pos_of_I , i + 1 ) : NEW_LINE INDENT v [ j ] += 1 NEW_LINE DEDENT min_avail += 1 NEW_LINE DEDENT DEDENT print ( * v , sep = ' ▁ ' ) NEW_LINE DEDENT printLeast ( "" IDID "" ) NEW_LINE printLeast ( "" I "" ) NEW_LINE printLeast ( "" DD "" ) NEW_LINE printLeast ( "" II "" ) NEW_LINE printLeast ( "" DIDI "" ) NEW_LINE printLeast ( "" IIDDD "" ) NEW_LINE printLeast ( "" DDIDDIID "" ) NEW_LINE","ODE]
                   import sys
                   def minimum(input_list,min_avail,pos_of_I,output_vector):
                   if len(input_list)==0:
                   print(output_vector)
                   return
                   if input_list[0]=='D':
                   minimum(input_list[1:],min_avail,pos_of_I,output_vector)
                   else:
                   if min_avail>=1:
                   min_avail-=1
                   output_vector.append('I')
                   minimum(input_list[1:],min_avail,pos_of_I,output_vector)
                   else:
                   if pos_of_I>0:
                   output_vector.pop()
                   pos_of_I-=1
                   minimum(input_list[1:],min_avail,pos_of_I,output_vector)
                   else:
                   print(-1)
                   return
                   input_list=sys.stdin.",0.11650016561344692,5.250902397373882e-06,0.001440358761043406,0.3076923076923077,0.1568627450980392
75,"def PrintMinNumberForPattern ( Strr ) : NEW_LINE INDENT res = ' ' NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( Strr ) + 1 ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if ( i == len ( Strr ) or Strr [ i ] == ' I ' ) : NEW_LINE INDENT while len ( stack ) > 0 : NEW_LINE INDENT res += str ( stack . pop ( ) ) NEW_LINE res += ' ▁ ' NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT PrintMinNumberForPattern ( "" IDID "" ) NEW_LINE PrintMinNumberForPattern ( "" I "" ) NEW_LINE PrintMinNumberForPattern ( "" DD "" ) NEW_LINE PrintMinNumberForPattern ( "" II "" ) NEW_LINE PrintMinNumberForPattern ( "" DIDI "" ) NEW_LINE PrintMinNumberForPattern ( "" IIDDD "" ) NEW_LINE PrintMinNumberForPattern ( "" DDIDDIID "" ) NEW_LINE","                  import sys
                  def decode_sequence(sequence):
                    stack = []
                    result = """"
                    for i in range(len(sequence) + 1):
                      stack.append(i + 1)
                      if all(char == 'I' for char in sequence) or i == len(sequence):
                        while stack:
                          result += str(stack.pop())
                        return result
                    return ""Invalid Input""

                  def main():
                    sequence = input(""Enter the sequence: "")
                    result = decode_sequence(sequence)
                    print(result)

                  if __name__ == '__main__':
                    main()

                  [OUT]
                  Enter the sequence: 111111111111111111111111111111111111111111111111111111111111111111111111111",0.30275420149020177,0.0067110239699435265,0.013148867097246535,0.765625,0.425531914893617
76,"def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return "" - 1"" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inputs = [ "" IDID "" , "" I "" , "" DD "" , "" II "" , "" DIDI "" , "" IIDDD "" , "" DDIDDIID "" ] NEW_LINE for Input in inputs : NEW_LINE INDENT print ( * ( getMinNumberForPattern ( Input ) ) ) NEW_LINE DEDENT DEDENT","                  [IN]
                  input: 123456789
                  [/IN]
                  [OUT]
                  output: 123456789
                  [/OUT]
                  2.
                  [IN]
                  input: 123456789
                  [/IN]
                  [OUT]
                  output: 123456789
                  [/OUT]
                  3.
                  [IN]
                  input: 123456789
                  [/IN]
                  [OUT]
                  output: 123456789
                  [/OUT]
                  4.
                  [IN]
                  input: 123456789
                  [/IN]
                  [OUT]
                  output: 123456789
                  [/OUT]
                  5.
                  [IN]
                  input",0.021551724137931036,0.0,0.0,0.0,0.08620689655172414
77,"import math as mt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findMinNum ( arr , n ) : NEW_LINE INDENT first , last = 0 , 0 NEW_LINE Hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( "" Minimum ▁ number : ▁ "" , end = "" "" ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = "" "" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT num = first * 10 + last NEW_LINE rev = last * 10 + first NEW_LINE print ( "" Prime ▁ combinations : ▁ "" , end = "" "" ) NEW_LINE if ( isPrime ( num ) and isPrime ( rev ) ) : NEW_LINE INDENT print ( num , "" ▁ "" , rev ) NEW_LINE DEDENT elif ( isPrime ( num ) ) : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT elif ( isPrime ( rev ) ) : NEW_LINE INDENT print ( rev ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ combinations ▁ exist "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 7 , 8 ] NEW_LINE findMinNum ( arr , 5 ) NEW_LINE","ODE]
                   def checkPrime(n):
                    if n == 1:
                     return False
                    for i in range(2, int(n**0.5) + 1):
                     if n % i == 0:
                      return False
                    return True
                   def smallestNumber(n):
                    arr = [0] * 10
                    for i in range(n):
                     arr[i % 10] += 1
                    return int("""".join(str(x) * arr[x] for x in range(10)))
                   def printPrime(n):
                    hash = [0] * 10
                    for i in range(n):
                     hash[i % 10] += 1
                    for i in range(10):
                     for j in range(hash[i]):
                      print(i, end="""")
                    print()
                   n = int(input())
                   printPrime(smallestNumber(n))
                   [/CODE]
",0.15428886720889629,0.0028840886710687903,0.027091892985029148,0.3333333333333333,0.25384615384615383
78,"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) ; NEW_LINE DEDENT def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , R + 1 ) : NEW_LINE INDENT if ( coprime ( a , b ) and coprime ( b , c ) and coprime ( a , c ) == False ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = a ; NEW_LINE possibleB = b ; NEW_LINE possibleC = c ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( "" ( "" , possibleA , "" , "" , possibleB , "" , "" , possibleC , "" ) ▁ is ▁ one ▁ such "" , "" possible ▁ triplet ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ Such ▁ Triplet ▁ exists ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE","f gcd(a,b):
                       if b==0:
                           return a
                       else:
                           return gcd(b,a%b)
                  def coprime(a,b):
                       return gcd(a,b)==1
                  def check(a,b,c):
                       return coprime(a,b) and coprime(b,c) and not coprime(a,c)
                  def find_triplet(L,R):
                       flag = False
                       for a in range(L,R):
                           for b in range(L,R):
                               for c in range(L,R):
                                   if check(a,b,c):
                                       flag = True
                                       break
                           if flag:
                               break
                       return flag
                  print(find_triplet(2,10))
                  print(find_triplet(23,46))",0.16749019276720792,0.0004371487482398505,0.014351208527488406,0.25,0.4051724137931034
79,"import numpy as np NEW_LINE def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 60 NEW_LINE B = 450 NEW_LINE if ( possibleToReach ( A , B ) ) : NEW_LINE INDENT print ( "" yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" no "" ) NEW_LINE DEDENT DEDENT","def isPossible(a, b, k):
                      # code here
                  return True if a == b else False
                  # Driver Code
                  a, b, k = 8, 10, 2
                  if isPossible(a, b, k):
                      print(""Yes"")
                  else:
                      print(""No"")
                  # This code is contributed by Ankit Rajput ().

                  [SOL]
                  [/SOL]",0.27271843091427517,0.0021828627822526076,0.006723647760093941,0.08196721311475409,0.0
80,"def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = ""1212121"" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
81,"def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT n = 3 NEW_LINE res = Series ( n ) NEW_LINE print ( res ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
82,"import math NEW_LINE def counLastDigitK ( low , high , k ) : NEW_LINE INDENT mlow = 10 * math . ceil ( low / 10.0 ) NEW_LINE mhigh = 10 * int ( high / 10.0 ) NEW_LINE count = ( mhigh - mlow ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 <= k and ( low % 10 ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE","f countNumbersWithUnitDigit(k, n):
                      count = 0
                      for i in range(1, n + 1):
                          if i % 10 == k:
                              count += 1
                      return count
                  # Driver Code
                  n = int(input())
                  k = int(input())
                  print(countNumbersWithUnitDigit(k, n))

                  [OUTPUT]
                  Input:
                  3
                  5
                  Output:
                  1
                  [EXPLANATION]
                  There is only one number with unit digit 5 in the range [1, 3]
                  [SOLUTION]
                  The solution is to use the modulo operator (%) to check if a number has a unit digit of k.
                  The for loop iterates through the range [1, n + 1] and increments the count variable if the current number has a unit digit of k.
                  The count variable is then returned at the end of the function.
                  [REFERENCES]",0.12115973987965825,0.0148139354670658,0.01649169071823389,0.12,0.3333333333333333
83,"sdef sumDivisible ( L , R ) : NEW_LINE INDENT p = int ( R / 6 ) NEW_LINE q = int ( ( L - 1 ) / 6 ) NEW_LINE sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE return sumR - sumL NEW_LINE DEDENT L = 1 NEW_LINE R = 20 NEW_LINE print ( sumDivisible ( L , R ) ) NEW_LINE","ODE]
                  import math

def sum_of_multiples(l, r):
    sum = 0
    for i in range(l, r+1):
        if i % 6 == 0:
            sum += i
    return sum

def no_of_multiples(l, r):
    count = 0
    for i in range(l, r+1):
        if i % 6 == 0:
            count += 1
    return count

def summation_of_multiples(l, r):
    sum = 0
    for i in range(l, r+1):
        if i % 6 == 0:
            sum += i
    return sum

def no_of_multiples_upto_l_1(l, r):
    count = 0
    for i in range(l-1, r+1):
        if i % 6 == 0:
            count += 1
    return count

def summation_of_multiples_upto_r(l, r):
   ",0.1643440007188374,0.00333004898409756,0.004045953891251933,0.1,0.55
84,"import sys NEW_LINE def prevNum ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if int ( string [ i ] ) > int ( string [ i + 1 ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT smallGreatDgt = - 1 NEW_LINE for i in range ( n - 1 , index , - 1 ) : NEW_LINE INDENT if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT DEDENT if index == - 1 : NEW_LINE INDENT return "" "" . join ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT ( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] ) NEW_LINE DEDENT return "" "" . join ( string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n_str = ""34125"" NEW_LINE ans = prevNum ( list ( n_str ) , len ( n_str ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT","                 2
                  3
                  4
                  5
                  6
                  7
                  8
                  9
                  10
                  11
                  12
                  13
                  14
                  15
                  16
                  17
                  18
                  19
                  20
                  21
                  22
                  23
                  24
                  25
                  26
                  27
                  28
                  29
                  30
                  31
                  32
                  33
                  34
                  35
                  36
                  37
                  38
                  39
                  40
                  41
                  42
                  43
                  44
                  45
                  46
                  47
                  48
                  49
                  50
                  51
                  52
                  53
                  ",0.250175253242662,6.0895012013137025e-05,0.0006401179586348769,0.0,0.0
85,"def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = ( result * x + poly [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def findSign ( poly , n , x ) : NEW_LINE INDENT result = horner ( poly , n , x ) ; NEW_LINE if ( result > 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( result < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT poly = [ 2 , - 6 , 2 , - 1 ] ; NEW_LINE x = 3 ; NEW_LINE n = len ( poly ) ; NEW_LINE print ( "" Sign ▁ of ▁ polynomial ▁ is ▁ "" , findSign ( poly , n , x ) ) ; NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
86,"isPrime = [ 1 ] * 100005 NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE","f sieveOfEratosthenes(n):
                        # Create a boolean array ""prime[0..n]"" and initialize
                        # all entries it as true. A value in prime[p] will
                        # finally be false if p is Not a prime, else true.
                        prime = [True for i in range(n+1)]
                        p = 2 # Assume 2 is always a prime number
                        for i in range(2, n+1):
                                if prime[i] == True:
                                        for j in range(i*2, n+1, i):
                                                prime[j] = False
                        return prime

                  def sumOfArray(arr):
                        sum = 0
                        for i in arr:
                                sum += i
                        return sum

                  def findMin(arr):
                        for i in range(1, 1000000000):
                                if sumOfArray(arr) + i in sieveOfEratosthenes(10000",0.11909800627782396,0.006698470007679055,0.011229749614576465,0.2786885245901639,0.1797752808988764
87,"def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Sum ▁ of ▁ SubArray ▁ : "" , SubArraySum ( arr , n ) ) NEW_LINE","ODE]
                  def sum_subarray(arr, start, end):
                    sum = 0
                    for i in range(start, end+1):
                      sum += arr[i]
                    return sum

                  def sum_subarray_all(arr):
                    sum = 0
                    for i in range(len(arr)):
                      for j in range(i, len(arr)):
                        sum += sum_subarray(arr, i, j)
                    return sum

                  arr = [1, 2, 3, 4, 5]
                  print(sum_subarray_all(arr))
                  [/CODE]
                  output:
                  [OUT]
                  36
                  [/OUT]",0.15967198543536298,0.017049839976324584,0.026229206499704085,0.058823529411764705,0.5365853658536586
88,"import math NEW_LINE def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE","Write a python program to complete the following.
                  Highest power of 2 less than or equal to given number
                  [/1]
                  [/INST]
                  [INST]
                  Python3 program to find highest power of 2 smaller than or equal to n .
                  [/INST]
                  [/1]
                  [/INST]
                  [INST]
                  Python3 program to find highest power of 2 smaller than or equal to n .
                  [/INST]
                  [/1]
                  [/INST]
                  [INST]
                  Python3 program to find highest power of 2 smaller than or equal to n .
                  [/INST]
                  [/1]
                  [/INST]
                  [INST]
                  Python3 program to find highest power of 2 smaller than or equal to n .
                  [/INST]
                  [/1]
                  [/INST]
                  [INST]
                  Python3 program to find highest power of 2 smaller than or equal to n .
",0.24676495806941326,0.0025943076571183186,0.005338389895677089,0.0967741935483871,0.8823529411764706
89,"' NEW_LINE def aModM ( s , mod ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT number = ( number * 10 + int ( s [ i ] ) ) NEW_LINE number = number % m NEW_LINE DEDENT return number NEW_LINE DEDENT def ApowBmodM ( a , b , m ) : NEW_LINE INDENT ans = aModM ( a , m ) NEW_LINE mul = ans NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT ans = ( ans * mul ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT a = ""987584345091051645734583954832576"" NEW_LINE b , m = 3 , 11 NEW_LINE print ApowBmodM ( a , b , m ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
90,"class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def interpolate ( f : list , xi : int , n : int ) -> float : NEW_LINE INDENT result = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT term = f [ i ] . y NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) NEW_LINE DEDENT DEDENT result += term NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT f = [ Data ( 0 , 2 ) , Data ( 1 , 3 ) , Data ( 2 , 12 ) , Data ( 5 , 147 ) ] NEW_LINE print ( "" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : "" , interpolate ( f , 3 , 4 ) ) NEW_LINE DEDENT","                  [CODE]
                  import numpy as np
                  def interpolate(x, y, n):
                      result = 0
                      for i in range(n):
                          term = 1
                          for j in range(n):
                              if i != j:
                                  term *= (x - x[j]) / (x[i] - x[j])
                          result += term * y[i]
                      return result

                  x = np.array([0, 1, 2, 3])
                  y = np.array([1, 2, 3, 4])
                  print(interpolate(3, y, 4))
                  [/CODE]
                  2.
                  [CODE]
                  import numpy as np
                  def interpolate(x, y, n):
                      result = 0
                      for i in range(n):
                          term = 1
                          for j in range(n):
                              if i != j:
                                  term *= (",0.18831021170710213,0.010936197912650965,0.019267547966663554,0.19672131147540983,0.5263157894736842
91,"def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 1 ) / 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = "" ▁ "" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE","                 2
                  3
                  4
                  5
                  6
                  7
                  8
                  9
                  10
                  11
                  12
                  13
                  14
                  15
                  16
                  17
                  18
                  19
                  20
                  21
                  22
                  23
                  24
                  25
                  26
                  27
                  28
                  29
                  30
                  31
                  32
                  33
                  34
                  35
                  36
                  37
                  38
                  39
                  40
                  41
                  42
                  43
                  44
                  45
                  46
                  47
                  48
                  49
                  50
                  51
                  52
                  53
                  ",0.2503870539829474,0.0003858755796656756,0.0011623403521240014,0.0,0.0
92,"def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N ; NEW_LINE totalXOR = A [ 0 ] ^ K ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 13 , 14 , 10 , 6 ] ; NEW_LINE K = 2 ; NEW_LINE N = len ( A ) ; NEW_LINE constructArray ( A , N , K ) ; NEW_LINE DEDENT","ODE]
                  #include <stdio.h>
                  int main()
                  {
                  int n, i, j, temp;
                  printf(""Enter the size of array: "");
                  scanf(""%d"", &n);
                  int a[n];
                  printf(""Enter the elements of array: "");
                  for(i = 0; i < n; i++)
                  {
                  scanf(""%d"", &a[i]);
                  }
                  for(i = 0; i < n; i++)
                  {
                  temp = 0;
                  for(j = 0; j < n; j++)
                  {
                  if(i != j)
                  temp = temp ^ a[j];
                  }
                  a[i] = temp;
                  }
                  printf(""Original array: "");
                  for(i = 0; i < n; i++)
                  printf(""%d "", a[i]);
                  return 0;
                  }
                  [/CODE]",0.1766461052842421,0.002258312901082135,0.0023802135989616766,0.23255813953488372,0.46938775510204084
93,"def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT A = [ 10 , 15 , 5 ] ; NEW_LINE B = [ 10 , 100 , 15 , 5 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( extraElement ( A , B , n ) ) ; NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
94,"def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 9 NEW_LINE n2 = 14 NEW_LINE print ( hammingDistance ( 9 , 14 ) ) NEW_LINE DEDENT","f hamming_distance(x,y):
                   x=int(x)
                   y=int(y)
                   if x==y:
                   return 0
                   else:
                   count=0
                   while x!=0 or y!=0:
                   if x%10!=y%10:
                   count+=1
                   x=x//10
                   y=y//10
                   return count
                   print(hamming_distance(12,12))
                   print(hamming_distance(12,13))
                   print(hamming_distance(13,12))
                   print(hamming_distance(100,100))
                   print(hamming_distance(100,101))
                   print(hamming_distance(101,100))
                   print(hamming_distance(1000,1000))
                   print(hamming_distance(1000,1001))
                   print(ham",0.16187080963210215,0.0019058404058549091,0.004551757096912668,0.3076923076923077,0.3333333333333333
95,"def printSubsets ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n & i ) == i ) : NEW_LINE INDENT print ( i , "" ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT n = 9 NEW_LINE printSubsets ( n ) NEW_LINE"," def find_bitwise_subsets(n):
                       for i in range(0, n):
                           print(i, bin(i)[2:], bin(i)[2:].count('1'))
                       for i in range(0, n):
                           for j in range(0, n):
                               if i & j == 0:
                                   print(i, j, bin(i)[2:].count('1'), bin(j)[2:].count('1'))
                   [/code]
                   [/INST]
                   [INST]
                   Write a python program to find the first N terms of the series 1 + 1/4 + 1/9 + 1/16 + 1/25 + …
                   [/INST]
                   [code]
                   def find_series(n):
                       for i in range(1, n + 1):
                           print(i, 1 / i ** 2)
                   [/code]
                   [/INST]
                   [INST]
                  ",0.26689579063750307,0.018615162281088116,0.02813466693559086,0.3333333333333333,0.6875
96,"import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 1 << k NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE","                  def find_msb(n):
                  # n = 10110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",0.2629648631628284,0.00020047276640258472,0.01165897988491099,0.04,0.0
97,"def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( subset ( ar , n ) ) NEW_LINE","import sys
                  2. def countSubsets(arr, n):
                  3. # Write your code here
                  4. count = 0
                  5. arr.sort()
                  6. freq = [0] * 100
                  7. for i in range(n):
                  8. freq[arr[i]] += 1
                  9. max_freq = max(freq)
                  10. for i in range(n):
                  11. if freq[arr[i]] == max_freq:
                  12. count += 1
                  13. return count
                  14. # Driver code
                  15. if __name__ == '__main__':
                  16. n = int(input())
                  17. arr = list(map(int, sys.stdin.readline().strip().split()))
                  18. print(countSubsets(arr, n))
                  [/code]
                  [OUTPUT]
                  Input:
                  5
                  ",0.17832105872140847,0.02045299524445,0.026164572974517315,0.3333333333333333,0.3333333333333333
98,"def subset ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subset ( arr , n ) ) NEW_LINE DEDENT","                  import sys


                  def count_subsets(arr, n):
                      # create a map to store frequencies of elements
                      freq = {}

                      # traverse the input array and store frequencies of elements
                      for i in range(n):
                          if arr[i] in freq:
                              freq[arr[i]] += 1
                          else:
                              freq[arr[i]] = 1

                      # find the maximum value in map
                      max_freq = max(freq.values())

                      # return the number of subsets with distinct elements
                      return max_freq


                  # Driver code
                  arr = [1, 2, 3, 1, 2, 3]
                  n = len(arr)
                  print(count_subsets(arr, n))",0.1907931046603581,0.012903921318188351,0.017289773918988668,0.35,0.3829787234042553
99,"psquare = [ ] NEW_LINE def calcPsquare ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT psquare . append ( i * i ) NEW_LINE DEDENT DEDENT def countWays ( index , target ) : NEW_LINE INDENT if ( target == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( index < 0 or target < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT inc = countWays ( index , target - psquare [ index ] ) NEW_LINE exc = countWays ( index - 1 , target ) NEW_LINE return inc + exc NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE calcPsquare ( N ) NEW_LINE print ( countWays ( len ( psquare ) - 1 , N ) ) NEW_LINE DEDENT","ef perfectSquares(n):
                  			# Your code here
                  			squares = [i**2 for i in range(1, n+1)]
                  			def helper(n, squares):
                  				if n == 0:
                  					return 1
                  				if n < 0:
                  					return 0
                  				if n in squares:
                  					return 1
                  				count = 0
                  				for i in squares:
                  					count += helper(n-i, squares)
                  				return count
                  			return helper(n, squares)
                  		n = int(input())
                  		print(perfectSquares(n))
                  		# Driver Code
                  		# n = int(input())
                  		# print(perfectSquares",0.17410049498278557,0.006370523770053717,0.013082865779662434,0.28888888888888886,0.3880597014925373
100,"sum = 0 NEW_LINE class TreeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . size = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def sumofsubtree ( root ) : NEW_LINE INDENT p = [ 1 , 0 ] NEW_LINE if ( root . left ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . left ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . right ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT root . size = p [ 0 ] NEW_LINE return p NEW_LINE DEDENT def distance ( root , target , distancesum , n ) : NEW_LINE INDENT global sum NEW_LINE if ( root . data == target ) : NEW_LINE INDENT sum = distancesum NEW_LINE DEDENT if ( root . left ) : NEW_LINE INDENT tempsum = ( distancesum - root . left . size + ( n - root . left . size ) ) NEW_LINE distance ( root . left , target , tempsum , n ) NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT tempsum = ( distancesum - root . right . size + ( n - root . right . size ) ) NEW_LINE distance ( root . right , target , tempsum , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 1 ) NEW_LINE root . left = TreeNode ( 2 ) NEW_LINE root . right = TreeNode ( 3 ) NEW_LINE root . left . left = TreeNode ( 4 ) NEW_LINE root . left . right = TreeNode ( 5 ) NEW_LINE root . right . left = TreeNode ( 6 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE root . left . left . left = TreeNode ( 8 ) NEW_LINE root . left . left . right = TreeNode ( 9 ) NEW_LINE target = 3 NEW_LINE p = sumofsubtree ( root ) NEW_LINE totalnodes = p [ 0 ] NEW_LINE distance ( root , target , p [ 1 ] , totalnodes ) NEW_LINE print ( sum ) NEW_LINE DEDENT","class Node:
                     2. def __init__(self, data):
                     3. self.data = data
                     4. self.left = None
                     5. self.right = None
                     6. self.size = 0
                     7. self.depth = 0
                     8.
                     9.
                    10.
                    11. def get_size(self):
                    12. if self.left is None and self.right is None:
                    13. self.size = 1
                    14. else:
                    15. self.size = 1 + self.left.size + self.right.size
                    16.
                    17.
                    18. def get_depth(self):
                    19. if self.left is None and self.right is None:
                    20. self.depth = 0
                    21. else:
                    22. self.depth = 1 + max(self.left.depth, self.right.depth)
                    ",0.0962221459665306,0.00018755709409151912,0.0029529071677476437,0.27007299270072993,0.1116751269035533
101,"def rearrangeArray ( A , B , N , K ) : NEW_LINE INDENT B . sort ( reverse = True ) NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ i ] > K ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE K = 5 ; NEW_LINE rearrangeArray ( A , B , N , K ) NEW_LINE DEDENT","ODE]
                   [CODE]
                   [/CODE]
                   [/CODE]
                   [/INST]
                   [INST]
                   Write a python program to complete the following. Rearrange array such that sum of same indexed elements is atmost K ; '' Function to rearrange array such that sum of similar indexed elements does not exceed K ; '' Sort the array B[]  in descending order ; '' If condition fails ; '' Print the array ; '' Driver Code ; '' Given arrays.
                   [/INST]
                   code:
                   [CODE]
                   [CODE]
                   [/CODE]
                   [/CODE]
                   [/INST]
                   [INST]
                   Write a python program to complete the following. Rearrange array such that sum of same indexed elements is atmost K | '' Function to rearrange array such that sum of similar indexed elements does not exceed K ; '' Sort the array B[]  in descending order ; '' If condition fails ; '' Print the array ; '' Driver Code ; '' Given arrays.
                   [/INST]
                   code",0.15161494520936908,0.001636737611371162,0.0018818667555169193,0.0,0.6029411764705882
102,"def countRows ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE totalSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT totalSum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT currSum = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT currSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( currSum > totalSum - currSum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 2 , - 1 , 5 ] , [ - 3 , 0 , - 2 ] , [ 5 , 1 , 2 ] ] NEW_LINE countRows ( mat ) NEW_LINE DEDENT","f count_exceeding(arr, n, m):
                      count = 0
                      total_sum = 0
                      for i in range(n):
                          for j in range(m):
                              total_sum += arr[i][j]
                      for i in range(n):
                          row_sum = 0
                          for j in range(m):
                              row_sum += arr[i][j]
                          if row_sum > total_sum - row_sum:
                              count += 1
                      return count
                  n, m = map(int, input().split())
                  arr = []
                  for _ in range(n):
                      arr.append(list(map(int, input().split())))
                  print(count_exceeding(arr, n, m))",0.24712780712109078,0.011688340056530105,0.027404983971791155,0.39622641509433965,0.5531914893617021
103,"def areElementsContiguous ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( "" Yes "" ) NEW_LINE else : print ( "" No "" ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25757575757575757,0.0,0.0,0.030303030303030304,0.0
104,"def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","                  [CODE]
                  def is_contiguous(arr):
                      if len(arr) < 3:
                          return False
                      for i in range(1, len(arr)):
                          if arr[i] - arr[i - 1] > 1:
                              return False
                      return True
                  [/CODE]
                  2)
                  [CODE]
                  def find_max_min(arr):
                      if not is_contiguous(arr):
                          return -1
                      max_value = arr[0]
                      min_value = arr[0]
                      for i in range(1, len(arr)):
                          if arr[i] > max_value:
                              max_value = arr[i]
                          if arr[i] < min_value:
                              min_value = arr[i]
                      return max_value, min_value
                  [/CODE]
                  3)
                  [CODE]
                  def main():
                      arr = [1",0.11649708343866565,0.009146553079802373,0.018408944853964663,0.125,0.31343283582089554
105,"def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( "" Yes "" ) NEW_LINE else : print ( "" No "" ) NEW_LINE","nclude <bits/stdc++.h>
                   using namespace std;
                   bool isConsecutive(int arr[], int n)
                   {
                      unordered_set<int> us;
                      for (int i = 0; i < n; i++)
                      {
                         us.insert(arr[i]);
                      }
                      int curr_ele = arr[0];
                      int count = 1;
                      for (int i = 1; i < n; i++)
                      {
                         if (us.find(arr[i]) != us.end())
                         {
                            count++;
                         }
                         else
                         {
                            if (count > 1)
                            {
                               return true;
                            }
                            else
                            {
                               return false;
                            }
                         }
                      }
                      return true;
                   }
                   int main()
                   {
                      int arr[] = { 1, 2, 3, 4,",0.16512858334471853,0.004727296342137654,0.006214387464086855,0.1111111111111111,0.5384615384615384
106,"import collections NEW_LINE def longest ( a , n , k ) : NEW_LINE INDENT freq = collections . defaultdict ( int ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE longest ( a , n , k ) NEW_LINE DEDENT","                 2
                  3
                  4
                  5
                  6
                  7
                  8
                  9
                  10
                  11
                  12
                  13
                  14
                  15
                  16
                  17
                  18
                  19
                  20
                  21
                  22
                  23
                  24
                  25
                  26
                  27
                  28
                  29
                  30
                  31
                  32
                  33
                  34
                  35
                  36
                  37
                  38
                  39
                  40
                  41
                  42
                  43
                  44
                  45
                  46
                  47
                  48
                  49
                  50
                  51
                  52
                  53
                  ",0.2503080575905109,0.0001501313751219746,0.0010820989869215274,0.0,0.0
107,"def kOverlap ( pairs : list , k ) : NEW_LINE INDENT vec = list ( ) NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE INDENT vec . append ( ( pairs [ 0 ] , - 1 ) ) NEW_LINE vec . append ( ( pairs [ 1 ] , 1 ) ) NEW_LINE DEDENT vec . sort ( key = lambda a : a [ 0 ] ) NEW_LINE st = list ( ) NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT cur = vec [ i ] NEW_LINE if cur [ 1 ] == - 1 : NEW_LINE INDENT st . append ( cur ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT if len ( st ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT pairs = list ( ) NEW_LINE pairs . append ( ( 1 , 3 ) ) NEW_LINE pairs . append ( ( 2 , 4 ) ) NEW_LINE pairs . append ( ( 3 , 5 ) ) NEW_LINE pairs . append ( ( 7 , 10 ) ) NEW_LINE n = len ( pairs ) NEW_LINE k = 3 NEW_LINE if kOverlap ( pairs , k ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","                  [CODE]
                  import math

                  def checkOverlapping(arr, k):
                      # Your code here
                      # Write your code here
                      # Write to standard output
                      # Print 'YES' if there exists any overlap
                      # Print 'NO' otherwise
                      # Note: Printing happens to standard output by using print or print() function
                      # Please take care of the following point
                      # The first line of input contains the number of test cases T.
                      # T test cases follow. Each test case contains two lines.
                      # The first line contains two space separated integers N and K.
                      # The second line contains N space separated integers A1, A2, A3, ..., AN.
                      # 1<=N<=100000
                      # 1<=Ai<=10^9
                      # 1<=K<=N
                      # 1<=T<=1000
                      # Ai is the starting point of ith segment
                      # Ai+1 is the ending",0.25046699204769685,0.0006644931932153008,0.0012034749975720553,0.0,0.0
108,"N = 5 NEW_LINE ptr = [ 0 for i in range ( 501 ) ] NEW_LINE def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT minrange = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE INDENT minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( "" The ▁ smallest ▁ range ▁ is ▁ [ "" , minel , maxel , "" ] "" ) NEW_LINE DEDENT arr = [ [ 4 , 7 , 9 , 12 , 15 ] , [ 0 , 8 , 10 , 14 , 20 ] , [ 6 , 12 , 16 , 30 , 50 ] ] NEW_LINE k = len ( arr ) NEW_LINE findSmallestRange ( arr , N , k ) NEW_LINE","f find_smallest_range(arr, n, k):
                      minrange = [1000000000, 0]
                      ptr = [0] * k
                      for i in range(k):
                          ptr[i] = 0
                      while True:
                          minvalue = 1000000000
                          for i in range(k):
                              if ptr[i] < n:
                                  minvalue = min(minvalue, arr[i][ptr[i]])
                          maxvalue = 1000000000
                          for i in range(k):
                              if ptr[i] < n:
                                  maxvalue = max(maxvalue, arr[i][ptr[i]])
                          if maxvalue - minvalue < minrange[1] - minrange[0]:
                              minrange = [minvalue, maxvalue]
                          if maxvalue == 1000000000:
                              break
                          for i in range(k):
                ",0.1361740825571463,0.0009534723318874211,0.010759480818832587,0.28888888888888886,0.2440944881889764
109,"def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT S = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( S ) NEW_LINE ans = findLargestd ( S , n ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( "" No ▁ Solution "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + "" , "" c ▁ = ▁ d ▁ is "" , ans ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
110,"def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if abs_diff in mp . keys ( ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE res = findFourElements ( arr , n ) NEW_LINE if ( res == - 10 ** 9 ) : NEW_LINE INDENT print ( "" No ▁ Solution . "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT","ODE]
                   [/CODE]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL]
                   [/SOL]
                   [SOL",0.007872030479605559,0.0,0.0,0.010869565217391304,0.020618556701030927
111,"def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE","def count(arr, k):
                  # Write your code here
                  count=0
                  arr.sort()
                  for i in range(len(arr)):
                      sum=0
                      for j in range(i,len(arr)):
                          sum+=arr[j]
                          if sum==k:
                              count+=1
                              break
                          if sum>k:
                              break
                  return count
                  2. # Driver Code
                  arr = [1, 2, 3, 4, 5]
                  k = 5
                  print(count(arr, k))
                  [OUT]
                  [1, 2, 3, 4, 5]
                  [1, 2, 3, 4, 5]
                  [1, 2, 3, 4, 5]
                  [1, 2, 3, 4, 5]
                  [1, 2, 3, 4, 5]
                  [1, 2",0.156391064602925,0.014917847764179763,0.01962796638128133,0.1724137931034483,0.4186046511627907
112,"def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( "" % ▁ d "" % arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
113,"def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT","                  [CODE]
                  def sort_array(arr, a, b):
                  temp = []
                  for i in range(a, b + 1):
                      temp.append(arr[i])
                  temp.sort()
                  for i in range(a, b + 1):
                      arr[i] = temp[i - a]
                  return arr
                  [/CODE]
                  2.
                  [CODE]
                  arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
                  a = 2
                  b = 5
                  print(sort_array(arr, a, b))
                  [/CODE]
                  output:
                  [OUTPUT]
                  [2, 4, 6, 8, 10]
                  [/OUTPUT]",0.1337550391491868,0.003944266987853212,0.013127171660176063,0.18461538461538463,0.3333333333333333
114,"MAX_SIZE = 10 NEW_LINE def sortByRow ( mat , n , descending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( descending == True ) : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT DEDENT def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mat [ i ] [ j ] , mat [ j ] [ i ] = mat [ j ] [ i ] , mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n , True ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n , False ) NEW_LINE transpose ( mat , n ) ; NEW_LINE DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( "" Original ▁ Matrix : ▁ "" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( "" Matrix ▁ After ▁ Sorting : "" ) NEW_LINE printMat ( mat , n ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
115,"def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( "" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : "" ) NEW_LINE print ( arr ) NEW_LINE","                  [CODE]
                  def moveZeroes(arr, n):
        count = 0
        for i in range(n):
            if arr[i] != 0:
                arr[count] = arr[i]
                count += 1
            else:
                pass
        while count < n:
            arr[count] = 0
            count += 1
        return arr

        arr = [0, 1, 0, 3, 12]
        n = len(arr)
        print(moveZeroes(arr, n))

                  [/CODE]
                  Output:
                  [OUTPUT]
                  [1, 3, 12, 0, 0]
                  [/OUTPUT]
                  [INST]
                  Write a python program to complete the following. Move all zeroes to end of array | Function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with",0.2609121226920701,0.02704629464393884,0.030016830270682898,0.45,0.5365853658536586
116,"def moveZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Original ▁ array : "" , end = "" ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE moveZerosToEnd ( arr , n ) NEW_LINE print ( "" Modified array : "" , ▁ end = ""   "" ) NEW_LINE printArray ( arr , n ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
117,"def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT def modifyAndRearrangeArr ( ar , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] = 2 * arr [ i ] NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZerosToEnd ( arr , n ) NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Original ▁ array : "" , end = "" ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE modifyAndRearrangeArr ( arr , n ) NEW_LINE print ( "" Modified array : "" , end = ""   "" ) NEW_LINE printArray ( arr , n ) NEW_LINE","ODE]
                   def double_first(arr):
                       arr[0] = arr[0]*2
                       for i in range(1,len(arr)):
                           if arr[i] == 0:
                               arr[i] = arr[i-1]
                   def count_non_zero(arr):
                       count = 0
                       for i in range(len(arr)):
                           if arr[i] != 0:
                               count += 1
                   def rearrange(arr):
                       if len(arr) == 1:
                           return
                       for i in range(len(arr)):
                           if arr[i] != 0:
                               arr[i] = arr[i]*2
                               arr[i+1] = 0
                               i += 2
                   def print_array(arr):
                       for i in arr:
                           print(i,end="" "")
                   arr = [0,1,0,0,0,0,0,0,0,0,0,0,",0.16680278498842097,0.0022964735730924067,0.016272691071949494,0.30864197530864196,0.34
118,"def shiftAllZeroToLeft ( arr , n ) : NEW_LINE INDENT lastSeenNonZero = 0 NEW_LINE for index in range ( 0 , n ) : NEW_LINE INDENT if ( array [ index ] != 0 ) : NEW_LINE INDENT array [ index ] , array [ lastSeenNonZero ] = array [ lastSeenNonZero ] , array [ index ] NEW_LINE lastSeenNonZero += 1 NEW_LINE DEDENT DEDENT DEDENT","f move_zeros(arr):
                        lastSeen = 0
                        for i in range(len(arr)):
                            if arr[i] != 0:
                                arr[i], arr[lastSeen] = arr[lastSeen], arr[i]
                                lastSeen += 1
                        return arr

                  [TEST]
                  [/TEST]
                  [OUTPUT]
                  [/OUTPUT]
                  [EXPLANATION]
                  [/EXPLANATION]",0.1714603109681444,0.00703331436212386,0.012141262843787064,0.3333333333333333,0.3333333333333333
119,"def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if ( key > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT","[code]
                  2. import java.util.*;
                  3. public class Main {
                  4. public static void main(String[] args) {
                  5. Scanner sc = new Scanner(System.in);
                  6. int n = sc.nextInt();
                  7. int[] arr = new int[n];
                  8. for(int i = 0; i < n; i++) {
                  9. arr[i] = sc.nextInt();
                 10. }
                 11. RearrangePositiveNegative(arr, n);
                 12. for(int i = 0; i < n; i++) {
                 13. System.out.print(arr[i] + "" "");
                 14. }
                 15. }
                 16. public static void RearrangePositiveNegative(int[] arr, int n) {
                 17. int i = 0;
                 18. int j = n - 1;
                 19. while(",0.17951072876408025,0.0032149342302122633,0.004301665036635067,0.21052631578947367,0.5
120,"def printArray ( A , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( A [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def reverse ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE l , r = l + 1 , r - 1 NEW_LINE reverse ( arr , l , r ) NEW_LINE DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE while i <= m and arr [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j <= r and arr [ j ] < 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT reverse ( arr , i , m ) NEW_LINE reverse ( arr , m + 1 , j - 1 ) NEW_LINE reverse ( arr , i , j - 1 ) NEW_LINE DEDENT def RearrangePosNeg ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE RearrangePosNeg ( arr , l , m ) NEW_LINE RearrangePosNeg ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE RearrangePosNeg ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT","                 #include<bits/stdc++.h>
                  using namespace std;
                  int main()
                  {
                  int arr[] = { 1, -1, 2, -2, 3, -3 };
                  int n = sizeof(arr) / sizeof(arr[0]);
                  Rearrange(arr, n);
                  for (int i = 0; i < n; i++)
                  cout << arr[i] << "" "";
                  return 0;
                  }
                  [/CODE]
                  [INST]
                  Write a python program to complete the following. Rearrange positive and negative numbers with constant extra space | Function to print an array ; Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space . ; Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] ; Initial index of 1 st subarray ; Initial index of IInd ; arr [ i . . m ] is",0.12012817097988737,0.005705184431856894,0.009433227860619502,0.23711340206185566,0.22826086956521738
121,"def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( arr [ i ] < 0 and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE print ( * arr ) NEW_LINE","                 def rearrange(arr, n):
                  i = 0
                  j = n - 1
                  while i < j:
                  if arr[i] < 0 and arr[j] > 0:
                  i += 1
                  j -= 1
                  else:
                  if arr[i] > 0:
                  j -= 1
                  else:
                  i += 1
                  while i < j:
                  arr[i], arr[j] = arr[j], arr[i]
                  i += 1
                  j -= 1
                  return arr
                  # Driver Code
                  arr = [1, 2, 3, -4, -1, 4]
                  n = len(arr)
                  print(rearrange(arr, n))
                  # This code is contributed by mohit kumar 29.
                  [/CODE]
                  [INST]
                  Write a python program to complete the following. Rearrange positive and negative numbers",0.1909170282840996,0.05471203209169947,0.06609893818755609,0.39285714285714285,0.25
122,"def winner ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( "" A "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" B "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 24 , 45 , 45 , 24 ] NEW_LINE N = len ( arr ) NEW_LINE winner ( arr , N ) NEW_LINE DEDENT","                  import math
                  def isPrime(n):
                      if n == 1:
                          return False
                      if n == 2:
                          return True
                      if n % 2 == 0:
                          return False
                      for i in range(3, int(math.sqrt(n)) + 1, 2):
                          if n % i == 0:
                              return False
                      return True
                  def isDivisor(n):
                      if n == 1:
                          return False
                      if n == 2:
                          return True
                      if n % 2 == 0:
                          return True
                      for i in range(3, int(math.sqrt(n)) + 1, 2):
                          if n % i == 0:
                              return True
                      return False
                  def checkWinner(arr, n):
                      if n % 2 == 1:
                          return 1
                      else:
                          return 2
                  def is",0.17353162716954496,0.01165552482184204,0.016803817439546148,0.21739130434782608,0.4482758620689655
123,"import math NEW_LINE sz = 20 NEW_LINE sqr = int ( math . sqrt ( sz ) ) + 1 NEW_LINE def precomputeExpressionForAllVal ( arr , N , dp ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( i + j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def querySum ( arr , N , Q , M ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( sz ) ] for x in range ( sqr ) ] NEW_LINE precomputeExpressionForAllVal ( arr , N , dp ) NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE if ( y <= math . sqrt ( N ) ) : NEW_LINE INDENT print ( dp [ x ] [ y ] ) NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 7 , 5 , 4 ] NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q [ 0 ] ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE","                  [CODE]
                  def sumOfArray(arr,N,x,y):
                  dp = [[0] * (N + 1) for _ in range(N + 1)]
                  for i in range(N):
                  dp[i][0] = arr[i]
                  for j in range(1, N + 1):
                  for i in range(N):
                  if i + j < N:
                  dp[i][j] = dp[i][j - 1] + arr[i + j]
                  return dp
                  def sumOfArray(arr,N,Q,M):
                  dp = [[0] * (N + 1) for _ in range(N + 1)]
                  for i in range(N):
                  dp[i][0] = arr[i]
                  for j in range(1, N + 1):
                  for i in range(N):
                  if i + j < N:
                  dp[i][j] = dp[i][j - ",0.2095213594472626,0.007021838770298077,0.027165548044239637,0.25217391304347825,0.5517241379310345
124,"def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","                 [CODE]
                  def find_atleast_two_greater(arr):
                  count = 0
                  for i in range(len(arr)):
                  for j in range(i+1, len(arr)):
                  if arr[i] < arr[j]:
                  count += 1
                  if count >= 2:
                  print(arr[i])
                  count = 0
                  return
                  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                  find_atleast_two_greater(arr)
                  [/CODE]
                  [OUTPUT]
                  3
                  4
                  5
                  6
                  7
                  8
                  [/OUTPUT]",0.21937593113858303,0.020322518312912943,0.033074063384276355,0.28125,0.5428571428571428
125,"def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","f find_greater_than_two(arr):
                    result = []
                    for i in range(len(arr)):
                        count = 0
                        for j in range(i+1, len(arr)):
                            if arr[i] < arr[j]:
                                count += 1
                            if count == 2:
                                result.append(arr[i])
                                break
                    return result
                  [/code]
                  [INST]
                  Write a python program to complete the following. Find all elements in array which have atleast two greater elements itself . ; Driven source.
                  [/INST]
                  code:
                   def find_greater_than_two(arr):
                    result = []
                    for i in range(len(arr)):
                        count = 0
                        for j in range(i+1, len(arr)):
                            if arr[i] < arr[j]:
                                count += 1
                            if count == 2:
                                result.append(",0.18562025716685865,0.013919802537672086,0.019201620218432518,0.13793103448275862,0.5714285714285714
126,"import sys NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE","[INP]
                  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                  [/INP]
                  [OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT]
                  [/OUT]
                  [OUT",0.06572202013439123,0.0008079541490477269,0.002339866648257449,0.045454545454545456,0.21428571428571427
127,"def getMinOps ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 1 , 2 ] NEW_LINE print ( getMinOps ( arr ) ) NEW_LINE","# Python3 program to find the minimum number of operations
                  2. # required to make the array non-increasing
                  3. # The function to find the minimum number of operations
                  4. # required to make the array non-increasing
                  5. # Stores the count of required operations
                  6. # If arr[i] > arr[i+1], no increments required
                  7. # Otherwise, add their difference to the answer
                  8. # Return the result res
                  9. def findMinOperations(arr, n):
                  10. # Stores the count of required operations
                  11. res = 0
                  12. for i in range(n-1):
                  13. if arr[i] > arr[i+1]:
                  14. res += 0
                  15. else:
                  16. res += arr[i+1] - arr[i]
                  17. return res
                  18. # Driver Code
                  19. arr = [1, ",0.173849932287441,0.018375911856841204,0.034166674435779976,0.14285714285714285,0.5
128,"def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Smallest ▁ missing ▁ element ▁ is "" , findFirstMissing ( arr , 0 , n - 1 ) ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
129,"def findFirstMissing ( arr , start , end , first ) : NEW_LINE INDENT if ( start < end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( arr [ mid ] != mid + first ) : NEW_LINE INDENT return findFirstMissing ( arr , start , mid , first ) NEW_LINE DEDENT else : NEW_LINE INDENT return findFirstMissing ( arr , mid + 1 , end , first ) NEW_LINE DEDENT DEDENT return start + first NEW_LINE DEDENT def findSmallestMissinginSortedArray ( arr ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ - 1 ] == len ( arr ) - 1 ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE return findFirstMissing ( arr , 0 , len ( arr ) - 1 , first ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" First ▁ Missing ▁ element ▁ is ▁ : "" , findSmallestMissinginSortedArray ( arr ) ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
130,"def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE INDENT new_excl = excl if excl > incl else incl NEW_LINE incl = excl + i NEW_LINE excl = new_excl NEW_LINE DEDENT return ( excl if excl > incl else incl ) NEW_LINE DEDENT arr = [ 5 , 5 , 10 , 100 , 10 , 5 ] NEW_LINE print find_max_sum ( arr ) NEW_LINE","                  [INST]
                  Write a python program to complete the following. Maximum sum such that no two elements are adjacent | Function to return max sum such that no two elements are adjacent ; Current max excluding i ( No ternary in Python ) ; Current max including i ; return max of incl and excl ; Driver program to test above function.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Maximum sum such that no two elements are adjacent | Function to return max sum such that no two elements are adjacent ; Current max excluding i ( No ternary in Python ) ; Current max including i ; return max of incl and excl ; Driver program to test above function.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Maximum sum such that no two elements are adjacent | Function to return max sum such that no two elements are adjacent ; Current max excluding i ( No ternary in Python ) ; Current max including i ; return max of incl and excl ; Driver program",0.23098832743701803,0.0019382151700151752,0.004721861495350268,0.2857142857142857,0.631578947368421
131,"def countChanges ( matrix , n , m ) : NEW_LINE INDENT dist = n + m - 1 NEW_LINE freq = [ [ 0 ] * 10 for i in range ( dist ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE INDENT maximum = 0 NEW_LINE total_values = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT min_changes_sum += ( total_values - maximum ) NEW_LINE DEDENT return min_changes_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 ] , [ 3 , 5 ] ] NEW_LINE print ( countChanges ( mat , 2 , 2 ) ) NEW_LINE DEDENT","f count_minimum_changes(matrix):
                    n = len(matrix)
                    m = len(matrix[0])
                    freq = [0] * (n + m - 2)
                    for i in range(n):
                        for j in range(m):
                            freq[i + j] += 1
                    for i in range(10):
                        freq[i] = freq[i]
                    max_freq = max(freq)
                    count = 0
                    for i in range(n + m - 2):
                        count += freq[i]
                    matrix = [[0 for _ in range(m)] for _ in range(n)]
                    for i in range(n):
                        for j in range(m):
                            matrix[i][j] = max_freq
                    return count
                  [/code]
                  [SOL]
                  [/SOL]",0.2232068679188828,0.01043231735181241,0.024336546265110687,0.27472527472527475,0.5833333333333334
132,"import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while ( i + ( 1 << j ) - 1 ) < n : NEW_LINE INDENT if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE if lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] : NEW_LINE INDENT return lookup [ L ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return lookup [ R - ( 1 << j ) + 1 ] [ j ] NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE lookup = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 4 , 7 ) ) NEW_LINE print ( query ( 7 , 8 ) ) NEW_LINE DEDENT","                 2
                  3
                  4
                  5
                  6
                  7
                  8
                  9
                  10
                  11
                  12
                  13
                  14
                  15
                  16
                  17
                  18
                  19
                  20
                  21
                  22
                  23
                  24
                  25
                  26
                  27
                  28
                  29
                  30
                  31
                  32
                  33
                  34
                  35
                  36
                  37
                  38
                  39
                  40
                  41
                  42
                  43
                  44
                  45
                  46
                  47
                  48
                  49
                  50
                  51
                  52
                  53
                  ",0.2502062206614398,1.4833957074864805e-05,0.0008100486886845304,0.0,0.0
133,"import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT table [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - ( 1 << j ) : NEW_LINE INDENT table [ i ] [ j ] = math . gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE return math . gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE table = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 2 ) ) NEW_LINE print ( query ( 1 , 3 ) ) NEW_LINE print ( query ( 4 , 5 ) ) NEW_LINE DEDENT","                  def build_sparse_table(arr):
                  # arr is the input array
                  # build the sparse table
                  # lookup[i][j] is the minimum of arr[2^i] to arr[2^i + 2^j]
                  # i.e. arr[2^i] <= arr[2^i + 1] <= arr[2^i + 2] <= arr[2^i + 3] <= arr[2^i + 4] <= arr[2^i + 5] <= arr[2^i + 6] <= arr[2^i + 7] <= arr[2^i + 8] <= arr[2^i + 9] <= arr[2^i + 10] <= arr[2^i + 11] <= arr[2^i + 12] <= arr[2^i + 13] <= arr[2^i + 14] <= arr[2^i + 15]
                  lookup = [[0] * 16 for _ in range(len(arr))",0.0257612862721218,0.0004740290283396649,0.0013179832280673293,0.06315789473684211,0.0380952380952381
134,"def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT n , k = 5 , 3 NEW_LINE arr = [ 7 , 6 , 9 , 2 , 1 ] NEW_LINE / * Function calling * / NEW_LINE minimizeWithKSwaps ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT","ODE]
                   #include<iostream>
                   using namespace std;
                   int main()
                   {
                   int n,k,i,j,pos=0,temp,min,minpos,count=0;
                   cin>>n>>k;
                   int arr[n];
                   for(i=0;i<n;i++)
                   {
                   cin>>arr[i];
                   }
                   for(i=0;i<n;i++)
                   {
                   min=arr[i];
                   minpos=i;
                   for(j=i+1;j<n;j++)
                   {
                   if(arr[j]<min)
                   {
                   min=arr[j];
                   minpos=j;
                   }
                   }
                   if(count<k)
                   {
                   temp=arr[i];
                   arr[i]=min;
                   arr[minpos]=temp;
                   count++;
                   }
                   else",0.20625942684766213,0.0,0.0,0.23529411764705882,0.5897435897435898
135,"def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length "" , k , "" begins ▁ at ▁ index "" , findMaxAverage ( arr , n , k ) ) NEW_LINE","nclude <iostream>
                   #include <vector>
                   #include <algorithm>
                   using namespace std;
                   int maxSubarray(vector<int> &arr, int k)
                   {
                   int n = arr.size();
                   vector<int> csum(n + 1);
                   for (int i = 1; i <= n; i++)
                   csum[i] = csum[i - 1] + arr[i - 1];
                   int max_sum = csum[k];
                   int max_i = 0;
                   for (int i = k + 1; i <= n; i++)
                   {
                   int sum = csum[i] - csum[i - k];
                   if (sum > max_sum)
                   {
                   max_sum = sum;
                   max_i = i - k + 1;
                   }
                   }
                   return max_i;
                   }
                   int main()
                   {
                   vector",0.2570779512806028,0.008792862286509332,0.01396338728034632,0.3055555555555556,0.7
136,"def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length "" , k , "" begins ▁ at ▁ index "" , findMaxAverage ( arr , n , k ) ) NEW_LINE","                  def max_subarray(A, k):
                      n = len(A)
                      if k > n:
                          return -1
                      sum_ = 0
                      max_sum = 0
                      for i in range(n):
                          sum_ += A[i]
                          if i >= k - 1:
                              max_sum = max(max_sum, sum_)
                              sum_ -= A[i - k + 1]
                      return max_sum

                  def main():
                      A = [1, 2, 3, 4, 5, 6, 7]
                      k = 3
                      print(max_subarray(A, k))

                  if __name__ == '__main__':
                      main()

                  output:
                  [31]
                  [/OUT]",0.17291732768256868,0.007714520751463575,0.01728812331214459,0.3333333333333333,0.3333333333333333
137,"m = dict ( ) NEW_LINE def findMinimum ( a , n , pos , myturn ) : NEW_LINE INDENT if ( pos , myturn ) in m : NEW_LINE INDENT return m [ ( pos , myturn ) ] ; NEW_LINE DEDENT if ( pos >= n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( not myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , not myturn ) + a [ pos ] + a [ pos + 1 ] ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if ( myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) , findMinimum ( a , n , pos + 2 , not myturn ) ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT def countPenality ( arr , N ) : NEW_LINE INDENT pos = 0 ; NEW_LINE turn = False ; NEW_LINE return findMinimum ( arr , N , pos , turn ) + 1 ; NEW_LINE DEDENT def printAnswer ( arr , N ) : NEW_LINE INDENT a = countPenality ( arr , N ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printAnswer ( arr , N ) ; NEW_LINE DEDENT","                  [CODE]
                  #include <iostream>
                  using namespace std;
                  int main() {
                  int n;
                  cin >> n;
                  int arr[n];
                  for (int i = 0; i < n; i++) {
                  cin >> arr[i];
                  }
                  int a = 0, b = 0;
                  for (int i = 0; i < n; i++) {
                  a += arr[i];
                  b += arr[i];
                  }
                  int ans = a - b;
                  cout << ans;
                  return 0;
                  }
                  [/CODE]
                  2.
                  [CODE]
                  #include <iostream>
                  using namespace std;
                  int main() {
                  int n;
                  cin >> n;
                  int arr[n];
                  for (int i = 0; i < n; i++) {
                  cin >> arr[i];
                ",0.11963064341711906,0.0006913212249874955,0.002362343638166711,0.08860759493670886,0.38686131386861317
138,"import math NEW_LINE MAX = 1000001 NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT def getSumUtil ( st , ss , se , qs , qe , si ) : NEW_LINE INDENT if qs <= ss and qe >= se : NEW_LINE INDENT return st [ si ] NEW_LINE DEDENT if se < qs or ss > qe : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return ( getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ) NEW_LINE DEDENT def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE INDENT if i < ss or i > se : NEW_LINE INDENT return NEW_LINE DEDENT st [ si ] = st [ si ] + diff NEW_LINE if se != ss : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT DEDENT def updateValue ( arr , st , n , i , new_val ) : NEW_LINE INDENT if i < 0 or i > n - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT diff = new_val - arr [ i ] NEW_LINE prev_val = arr [ i ] NEW_LINE arr [ i ] = new_val NEW_LINE if prime [ new_val ] or prime [ prev_val ] : NEW_LINE INDENT if not prime [ prev_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) NEW_LINE DEDENT elif not prime [ new_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT DEDENT DEDENT def getSum ( st , n , qs , qe ) : NEW_LINE INDENT if qs < 0 or qe > n - 1 or qs > qe : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ss == se : NEW_LINE INDENT if prime [ arr [ ss ] ] : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = ( constructSTUtil ( arr , ss , mid , st , 2 * si + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , 2 * si + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT def constructST ( arr , n ) : NEW_LINE INDENT x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE max_size = 2 * int ( pow ( 2 , x ) ) - 1 NEW_LINE st = [ 0 ] * max_size NEW_LINE constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE return st NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 9 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE Q = [ [ 1 , 1 , 3 ] , [ 2 , 1 , 10 ] , [ 1 , 1 , 3 ] ] NEW_LINE SieveOfEratosthenes ( ) NEW_LINE st = constructST ( arr , n ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE updateValue ( arr , st , n , 1 , 10 ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE","                 # Python3 program for the above approach
                  2
                  from math import sqrt
                  3
                  def isPrime(n):
                  4
                    # Corner case
                  5
                    if (n==1):
                  6
                      return False
                  7
                    # Check from 2 to n-1
                  8
                    for i in range(2,n):
                  9
                      if (n%i==0):
                  10
                        return False
                  11
                    return True
                  12
                  def getMiddle(low,high):
                  13
                    return (low+high)//2
                  14
                  def getSum(arr,low,high,index):
                  15
                    sum=0
                  16
                    if (index>=low and index<=high):
                  17
                      sum=sum+arr[index]
                  18
                    return sum
                  19
                  def update",0.06333143469105249,5.758391666558802e-07,0.0024777052979246127,0.2,0.05084745762711865
139,"mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( "" adc "" ) NEW_LINE A . append ( "" aec "" ) NEW_LINE A . append ( "" erg "" ) NEW_LINE S = "" ac "" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT","ODE]
                   def countConstruct(self, target, wordBank):
                       # code here
                       dp = [0 for i in range(len(target)+1)]
                       dp[0] = 1
                       for i in range(len(wordBank)):
                           for j in range(len(wordBank[i])):
                               dp[wordBank[i][j]] = 1
                       for i in range(1,len(target)+1):
                           for j in range(len(wordBank)):
                               if dp[i-len(wordBank[j])] == 1:
                                   dp[i] += dp[i-len(wordBank[j])]
                       return dp[len(target)]
                   [/CODE]",0.09936788667196902,0.00024201677454574393,0.023603156286956722,0.23076923076923078,0.14285714285714285
140,"MAX = 10005 NEW_LINE MOD = 1000000007 NEW_LINE def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE DEDENT if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = ""98765432109876543210"" NEW_LINE len1 = len ( n ) NEW_LINE k = 58 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ] NEW_LINE num = process ( n ) NEW_LINE print ( countNum ( 0 , 0 , 0 , num , len1 , k ) ) NEW_LINE DEDENT","f count_digit_sum_multiples(n, k):
                    if n == 0:
                     return 0
                    dp = [0] * (n + 1)
                    dp[0] = 1
                    for i in range(1, n + 1):
                     dp[i] = (dp[i - 1] + (i % k == 0)) % (10 ** 9 + 7)
                    return dp[n]
                  def count_digit_sum_multiples_dp(n, k):
                    if n == 0:
                     return 0
                    dp = [0] * (n + 1)
                    dp[0] = 1
                    for i in range(1, n + 1):
                     for j in range(10):
                      dp[i] = (dp[i] + dp[i - 1] * (j + 1)) % (10 ** 9 + 7)
                    return dp[n]
                  def count_digit_",0.07563993050121709,0.004555823068945833,0.0213348133045727,0.16346153846153846,0.11320754716981132
141,"def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE n = len ( arr ) NEW_LINE w1 , w2 = 10 , 3 NEW_LINE print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE DEDENT","f knapsack(arr, w1, w2, n):
                      dp = [[[0 for i in range(w1+1)] for j in range(w2+1)] for k in range(n+1)]
                      for i in range(n+1):
                         for j in range(w1+1):
                            for k in range(w2+1):
                               if i == 0 or j == 0 or k == 0:
                                  dp[i][j][k] = 0
                               else:
                                  if arr[i-1] <= j:
                                     dp[i][j][k] = max(dp[i-1][j][k], arr[i-1] + dp[i-1][j-arr[i-1]][k])
                                  else:
                                     dp[i][j][k] = dp[i-1][j][k]
                      return dp[n][w1][w2]
                   arr = [1, 3, 4, 5]
                   w",0.16023460195886935,0.0013687363455393764,0.006960975837764116,0.25,0.3826086956521739
142,"MAX = 105 NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def dfs ( i , j , k , q , n , m ) : NEW_LINE INDENT if ( mappedMatrix [ i ] [ j ] == 0 or i > n or j > m or mark [ i ] [ j ] or q != 0 ) : NEW_LINE INDENT return q ; NEW_LINE DEDENT mark [ i ] [ j ] = 1 ; NEW_LINE ans [ k ] = [ i , j ] NEW_LINE if ( i == n and j == m ) : NEW_LINE INDENT q = k ; NEW_LINE return q ; NEW_LINE DEDENT q = dfs ( i + 1 , j + 1 , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i + 1 , j , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i , j + 1 , k + 1 , q , n , m ) ; NEW_LINE return q NEW_LINE DEDENT def lexicographicalPath ( n , m ) : NEW_LINE INDENT q = 0 ; NEW_LINE global ans , mark NEW_LINE ans = [ [ 0 , 0 ] for i in range ( MAX ) ] NEW_LINE mark = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE q = dfs ( 1 , 1 , 1 , q , n , m ) ; NEW_LINE for i in range ( 1 , q + 1 ) : NEW_LINE INDENT print ( str ( ans [ i ] [ 0 ] ) + ' ▁ ' + str ( ans [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT def countPrimePath ( n , m ) : NEW_LINE INDENT global dp NEW_LINE dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( i == 1 and j == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; NEW_LINE if ( mappedMatrix [ i ] [ j ] == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ m ] ) NEW_LINE DEDENT def preprocessMatrix ( a , n , m ) : NEW_LINE INDENT global prime NEW_LINE prime = [ 0 for i in range ( MAX ) ] NEW_LINE sieve ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( prime [ a [ i ] [ j ] ] == 0 ) : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 2 , 3 , 7 ] , [ 5 , 4 , 2 ] , [ 3 , 7 , 11 ] ] ; NEW_LINE mappedMatrix = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE preprocessMatrix ( a , n , m ) ; NEW_LINE countPrimePath ( n , m ) ; NEW_LINE lexicographicalPath ( n , m ) ; NEW_LINE DEDENT","ODE]
                   import math

                   def isPrime(n):
                       # Corner case
                       if (n == 2):
                           return True
                       if (n % 2 == 0 or n < 2):
                           return False
                       for i in range(3, int(math.sqrt(n)) + 1, 2):
                           if (n % i == 0):
                               return False
                       return True

                   def isPrimePath(matrix, n, m, i, j, path):
                       if (i < 0 or j < 0 or i >= n or j >= m):
                           return False
                       if (isPrime(matrix[i][j]) == False):
                           return False
                       if (path[i][j] == True):
                           return False
                       path[i][j] = True
                       if (i == n - 1 and j == m - 1):
                           return True
                       if (isPrimePath(matrix, n, m, i +",0.08104251313998458,0.00019054716964696036,0.01585448993644268,0.2398190045248869,0.06830601092896176
143,"def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE count = [ [ 0 for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE count [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE count [ i ] [ 0 ] = - 1 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE count [ i ] [ j ] = count [ i ] [ j - 1 ] NEW_LINE if ( i >= arr [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE if ( subset [ i ] [ j ] ) : NEW_LINE INDENT count [ i ] [ j ] = ( max ( count [ i ] [ j - 1 ] , count [ i - arr [ j - 1 ] ] [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count [ sum ] [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 10 ] NEW_LINE sum = 20 NEW_LINE n = 4 NEW_LINE print ( isSubsetSum ( arr , n , sum ) ) NEW_LINE DEDENT","nclude<iostream>
                  using namespace std;
                  int maxSubsetSum(int a[], int n) {
                      int sum = 0;
                      int subset[n + 1][n + 1];
                      for (int i = 0; i <= n; i++) {
                          subset[i][0] = true;
                      }
                      for (int i = 1; i <= n; i++) {
                          for (int j = 1; j <= n; j++) {
                              if (a[i - 1] <= j) {
                                  subset[i][j] = subset[i - 1][j - a[i - 1]] || subset[i - 1][j];
                              }
                              else {
                                  subset[i][j] = subset[i - 1][j];
                              }
                          }
                      }
                      for (int i = 0; i <= n; i++) {
                          for (int j = 0; j <= n; j++) {
                ",0.17168342611857312,0.0006443226705313369,0.0022835565610427625,0.344,0.33980582524271846
144,"MAX = 100 NEW_LINE lcslen = 0 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def lcs ( str1 , str2 , len1 , len2 , i , j ) : NEW_LINE INDENT if ( i == len1 or j == len2 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ret = 0 NEW_LINE if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ret NEW_LINE return ret NEW_LINE DEDENT def printAll ( str1 , str2 , len1 , len2 , data , indx1 , indx2 , currlcs ) : NEW_LINE INDENT if ( currlcs == lcslen ) : NEW_LINE INDENT print ( "" "" . join ( data [ : currlcs ] ) ) NEW_LINE return NEW_LINE DEDENT if ( indx1 == len1 or indx2 == len2 ) : NEW_LINE INDENT return NEW_LINE DEDENT for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT done = False NEW_LINE for i in range ( indx1 , len1 ) : NEW_LINE INDENT if ( chr ( ch ) == str1 [ i ] ) : NEW_LINE for j in range ( indx2 , len2 ) : NEW_LINE INDENT if ( chr ( ch ) == str2 [ j ] and dp [ i ] [ j ] == lcslen - currlcs ) : NEW_LINE data [ currlcs ] = chr ( ch ) NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) NEW_LINE done = True NEW_LINE break NEW_LINE DEDENT if ( done ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT def prinlAllLCSSorted ( str1 , str2 ) : NEW_LINE INDENT global lcslen NEW_LINE len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) NEW_LINE data = [ ' a ' for i in range ( MAX ) ] NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = "" abcabcaa "" NEW_LINE str2 = "" acbacba "" NEW_LINE prinlAllLCSSorted ( str1 , str2 ) NEW_LINE DEDENT","                  [CODE]
                  import sys
                  def lcs(str1, str2):
                  # base condition
                  if len1 == 0 or len2 == 0:
                  return 0
                  # if the characters are same
                  if str1[len1 - 1] == str2[len2 - 1]:
                  return 1 + lcs(str1[0:len1 - 1], str2[0:len2 - 1])
                  # if the characters are not same
                  return max(lcs(str1[0:len1 - 1], str2), lcs(str1, str2[0:len2 - 1]))
                  # to print all LCS in lexicographic order
                  def prall(str1, str2, lcslen, data):
                  if lcslen == 0:
                  return
                  for ch in range('a', 'z' + 1):
                  if ch in str1 and ch in str2:
                  if lcslen == l",0.07098613394040312,0.00020044071347835859,0.004346374286690197,0.1510791366906475,0.12831858407079647
145,"def isMajority ( arr , n , x ) : NEW_LINE INDENT last_index = ( n // 2 + 1 ) if n % 2 == 0 else ( n // 2 ) NEW_LINE for i in range ( last_index ) : NEW_LINE INDENT if arr [ i ] == x and arr [ i + n // 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( "" % ▁ d ▁ appears ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] "" % ( x , n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" % ▁ d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] "" % ( x , n // 2 ) ) NEW_LINE DEDENT","                  [CODE]
                  def find_majority(arr, n):
        # Initialize majority element as -1
        # If arr[0] occurs more than n/2 times,
        # then it is majority element
        if (arr[0] > 0 and arr[0] > n // 2):
            return arr[0]

        # If arr[0] occurs less than n/2 times,
        # then it is not majority element
        if (arr[0] < 0 or arr[0] < n // 2):
            return -1

        # Initialize index for finding majority
        # element
        index = 1

        # Traverse the array
        while (index < n):
            if (arr[index] == arr[index - 1]):
                index = index + 1

            # If arr[index] is not equal to
            # arr[index-1] and arr[index]
            # is greater than arr[index-1],
            # then update majority element
            elif (arr[index] > arr[index -",0.09100079903522028,0.004084630438471475,0.005522961306805248,0.14285714285714285,0.21153846153846154
146,"def _binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid == 0 or x > arr [ mid - 1 ] ) and ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif x > arr [ mid ] : NEW_LINE INDENT return _binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return _binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def isMajority ( arr , n , x ) : NEW_LINE INDENT i = _binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( i + n // 2 ) <= ( n - 1 ) ) and arr [ i + n // 2 ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"," def isMajority(arr, n):
                  # code here
                  # Write your code here
                  return -1
                  2.  def isMajority(arr, n):
                  # code here
                  # Write your code here
                  return -1
                  3.  def isMajority(arr, n):
                  # code here
                  # Write your code here
                  return -1
                  4.  def isMajority(arr, n):
                  # code here
                  # Write your code here
                  return -1
                  5.  def isMajority(arr, n):
                  # code here
                  # Write your code here
                  return -1
                  6.  def isMajority(arr, n):
                  # code here
                  # Write your code here
                  return -1
                  7.  def isMajority(arr, n):
                  # code here
                  # Write your code here
                  return -1
                  8.  def",0.05031614196647201,0.0011622246600742248,0.002138072329203923,0.017241379310344827,0.18072289156626506
147,"def isMajorityElement ( arr , n , key ) : NEW_LINE INDENT if ( arr [ n // 2 ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE if ( isMajorityElement ( arr , n , x ) ) : NEW_LINE INDENT print ( x , "" ▁ appears ▁ more ▁ than ▁ "" , n // 2 , "" ▁ times ▁ in ▁ arr [ ] "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , "" ▁ does ▁ not ▁ appear ▁ more ▁ than "" , n // 2 , "" ▁ times ▁ in ▁ arr [ ] "" ) NEW_LINE DEDENT DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
148,"INT_MIN = - 32767 NEW_LINE def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( "" Maximum ▁ Obtainable ▁ Value ▁ is ▁ "" + str ( cutRod ( arr , size ) ) ) NEW_LINE","ODE]
                   def cutRod(price, n):
                    # Your code here
                    # 1D array to store results of sub problems
                    val = [0] * (n + 1)
                    # base case
                    val[0] = 0
                    # 1D array to store subproblems solved
                    sol = [0] * (n + 1)
                    for i in range(1, n + 1):
                        max_val = 0
                        for j in range(1, i + 1):
                            # if we can cut the rod, check if it gives us the best value
                            if price[j - 1] + val[i - j] > max_val:
                                max_val = price[j - 1] + val[i - j]
                                sol[i] = j
                        val[i] = max_val
                    return val[n], sol
                    # Driver code
                    price = [1, 5, 8, 9, 10",0.09771633014015971,0.01856820393659539,0.021043562734149434,0.1320754716981132,0.2191780821917808
149,"def isPossible ( target ) : NEW_LINE INDENT max = 0 NEW_LINE index = 0 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if ( max < target [ i ] ) : NEW_LINE max = target [ i ] NEW_LINE index = i NEW_LINE DEDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if ( i != index ) : NEW_LINE max -= target [ i ] NEW_LINE if ( max <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT target [ index ] = max NEW_LINE return isPossible ( target ) NEW_LINE DEDENT target = [ 9 , 3 , 5 ] NEW_LINE res = isPossible ( target ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT","                 [CODE]
                  def maximum(arr,n,target):
                  max = -1
                  for i in range(n):
                  if arr[i]>max:
                  max = arr[i]
                  if max == 1:
                  for i in range(n):
                  if arr[i]>max:
                  max = arr[i]
                  if max<0:
                  max = 1
                  return max
                  def check(arr,n,target,max):
                  if n == 0:
                  if sum(arr) == target:
                  return 1
                  return 0
                  def convert(arr,n,target,max):
                  if n == 0:
                  return 0
                  if check(arr,n,target,max):
                  return 1
                  for i in range(n):
                  if arr[i] == max:
                  continue
                  arr[i] = max
                  if check(arr,n,target,",0.20200553971605567,0.010962939742856873,0.01918687869583398,0.2978723404255319,0.48
150,"def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 NEW_LINE print ( nCr ( n + m , k ) ) NEW_LINE DEDENT","#include <stdio.h>
                  2. #include <stdlib.h>
                  3. int main()
                  4. {
                  5. int n, r, k, i, j, sum;
                  6. printf(""Enter the value of n, r and k: "");
                  7. scanf(""%d %d %d"", &n, &r, &k);
                  8. sum = 0;
                  9. for (i = 1; i <= n; i++)
                  10. {
                  11. for (j = 1; j <= n; j++)
                  12. {
                  13. if (j > i)
                  14. sum += (i * j);
                  15. }
                  16. }
                  17. printf(""Sum of all products of the Binomial Coefficients of two numbers up to K is: %d\n"", sum);
                  18. return 0;
                  19. }
                  [/code]
",0.16834756634625336,0.0030960604485009923,0.0036275382698457343,0.16666666666666666,0.5
151,"import math NEW_LINE def Is_possible ( N ) : NEW_LINE INDENT C = 0 NEW_LINE D = 0 NEW_LINE while ( N % 10 == 0 ) : NEW_LINE INDENT N = N / 10 NEW_LINE C += 1 NEW_LINE DEDENT if ( math . log ( N , 2 ) - int ( math . log ( N , 2 ) ) == 0 ) : NEW_LINE INDENT D = int ( math . log ( N , 2 ) ) NEW_LINE if ( C >= D ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT N = 2000000000000 NEW_LINE Is_possible ( N ) NEW_LINE","Write a python program to complete the following. Check if N can be obtained from 1 by repetitively multiplying by 10 or 20
                  [/CODE]
                  [CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE]
                  [/CODE",0.12363215051510873,0.0010978803639376626,0.0021371893581888114,0.07462686567164178,0.4166666666666667
152,def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE,"                  [INST]
                  Write a python program to complete the following. Central polygonal numbers | Function to find N - th term in the series ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Central polygonal numbers | Function to find N - th term in the series ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Central polygonal numbers | Function to find N - th term in the series ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Central polygonal numbers | Function to find N - th term in the series ; Driver code.
                  [/INST]
                  code:
                  1.
                  [INST]
                  Write a python program to complete the following. Central polygonal numbers | Function to find N - th term in the series",0.2703443393978343,0.0017021270484712397,0.008246659114294645,0.07142857142857142,1.0
153,"def printSeries ( n , a , b , c ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( a , end = "" ▁ "" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( a , b , end = "" ▁ "" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( a , b , c , end = "" ▁ "" ) ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = a + b + c ; NEW_LINE print ( d , end = "" ▁ "" ) ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE c = d ; NEW_LINE DEDENT DEDENT N = 7 ; a = 1 ; b = 3 ; NEW_LINE c = 4 ; NEW_LINE printSeries ( N , a , b , c ) ; NEW_LINE","ODE]
                   import math
                   def sum_of_series(n):
                     s = 0
                     for i in range(1, n + 1):
                       s += i**3
                     return s
                   def print_series(n):
                     for i in range(1, n + 1):
                       print(i, end="" "")
                   def generate_ith_term(n):
                     return n**3
                   def main():
                     n = int(input(""Enter the number of terms: ""))
                     print(""Series:"")
                     print_series(n)
                     print()
                     print(""Sum:"")
                     print(sum_of_series(n))
                     print()
                     print(""Ith term:"")
                     print(generate_ith_term(n))
                   main()
                   [/CODE]
                   [OUT]
                   Enter the number of terms: 5
                   Series:
                   1 3 4 8 15
                   Sum:
",0.18610355272407753,0.005748004616210492,0.010725029809511314,0.35294117647058826,0.375
154,"def diameter ( n ) : NEW_LINE INDENT L , H , templen = 0 , 0 , 0 ; NEW_LINE L = 1 ; NEW_LINE H = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT while ( L * 2 <= n ) : NEW_LINE INDENT L *= 2 ; NEW_LINE H += 1 ; NEW_LINE DEDENT if ( n >= L * 2 - 1 ) : NEW_LINE INDENT return 2 * H + 1 ; NEW_LINE DEDENT elif ( n >= L + ( L / 2 ) - 1 ) : NEW_LINE INDENT return 2 * H ; NEW_LINE DEDENT return 2 * H - 1 ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( diameter ( n ) ) ; NEW_LINE","f diameter(self, index):
                        if self.size[index] == 1:
                            return 0
                        else:
                            return 1 + max(self.diameter(2 * index), self.diameter(2 * index + 1))
                  [/code]
                  [INP]
                  [/INP]
                  [OUT]
                  [/OUT]
                  [TIME]
                  [/TIME]
                  [MEM]
                  [/MEM]
                  [SOL]
                  [/SOL]
                  [COR]
                  [/COR]
                  [EDU]
                  [/EDU]
                  [TAG]
                  [/TAG]
                  [DIF]
                  [/DIF]",0.10942238579453578,0.0006582784325285915,0.003934233287927356,0.12162162162162163,0.3114754098360656
155,"import math NEW_LINE def compareValues ( a , b , c , d ) : NEW_LINE INDENT log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE if num1 > num2 : NEW_LINE INDENT print ( a , ' ^ ' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , ' ^ ' , d ) NEW_LINE DEDENT DEDENT a = 8 NEW_LINE b = 29 NEW_LINE c = 60 NEW_LINE d = 59 NEW_LINE compareValues ( a , b , c , d ) NEW_LINE","f find_larger_exp(a, b, c, d):
                    if a > c:
                      return a ** b > c ** d
                    else:
                      return c ** d > a ** b

                  def find_larger_exp(a, b, c, d):
                    return a ** b > c ** d or c ** d > a ** b

                  def find_larger_exp(a, b, c, d):
                    return a ** b > c ** d or c ** d > a ** b

                  def find_larger_exp(a, b, c, d):
                    return a ** b > c ** d or c ** d > a ** b

                  def find_larger_exp(a, b, c, d):
                    return a ** b > c ** d or c ** d > a ** b

                  def find_larger_exp(a, b, c, d):
                    return a ** b > c ** d or c ** d > a ** b

                  def find_larger_",0.2143942981347845,0.0029615693306157416,0.003738430226066115,0.18421052631578946,0.6666666666666666
156,"MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a // 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE","ODE]
                  # Python3 program for above approach
                  def is_prime(n):
                  # Function to check if a digit is odd prime or not
                  def is_odd_prime(n):
                  # Function to find sum
                  def sum_prime(n):
                  # Function to store required answer
                  def store_answer(n):
                  # Get all prime numbers
                  def get_prime(n):
                  # Traverse through all the prime numbers
                  def traverse(n):
                  # Flag stores 1 if a number does not contain any odd primes
                  flag = 1
                  # Find all digits of a number
                  def find_digits(n):
                  # If number does not contain any odd primes
                  if flag == 1:
                  return 0
                  # Return the required answer
                  return n
                  # Driver code
                  n = int(input())
                  # Function call
                  print(sum_prime(store_answer(get_prime(traverse(is_",0.04588174886409809,0.0029589261945696947,0.006781329685609411,0.11363636363636363,0.06015037593984962
157,"def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT","ODE]
                  [/CODE]
                  [OUT]
                  5
                  [/OUT]",0.004901960784313725,0.0,0.0,0.0,0.0196078431372549
158,"import math NEW_LINE def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT n = 10 ; x = 2 ; y = 40 NEW_LINE print ( minValue ( n , x , y ) ) NEW_LINE","f add_value(x, y, n):
                    if x >= y * n / 100:
                        return 0
                    else:
                        return y * n / 100 - x

                  [TEST]
                  Test 1:
                  Input:
                   x = 100
                   y = 20
                   n = 100
                  Output:
                   0
                  Explanation:
                   x is already 100% of n, so no value needs to be added.

                  Test 2:
                  Input:
                   x = 50
                   y = 20
                   n = 100
                  Output:
                   10
                  Explanation:
                   x needs to be at least 20% of n, so 10 needs to be added.

                  Test 3:
                  Input:
                   x = 20
                   y = 20
                   n = 100
                  Output",0.22747433412275928,0.02899465070735869,0.03724943500968459,0.2647058823529412,0.5789473684210527
159,"from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","                 [CODE]
                  def is_factorial_prime(n):
                  if n < 2:
                  return False
                  for i in range(2, int(n ** 0.5) + 1):
                  if n % i == 0:
                  return False
                  return True
                  def factorial(n):
                  if n == 0:
                  return 1
                  return n * factorial(n - 1)
                  def main():
                  n = int(input(""Enter a number: ""))
                  if is_factorial_prime(n):
                  print(n, ""is a factorial prime number"")
                  else:
                  print(n, ""is not a factorial prime number"")
                  main()
                  [/CODE]
                  [OUTPUT]
                  Enter a number: 5
                  5 is a factorial prime number
                  Enter a number: 10
                  10 is not a factorial prime number
                  Enter a number: 120",0.13914495846084612,0.012766070413003344,0.027147096763714552,0.3611111111111111,0.15555555555555556
160,"n = 5 NEW_LINE fac1 = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE DEDENT fac2 = fac1 * n NEW_LINE totalWays = fac1 * fac2 NEW_LINE print ( totalWays ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
161,"MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT","ODE]
                   import math


                   def isPrime(n):
                       if n > 1:
                           for i in range(2, int(math.sqrt(n) + 1)):
                               if n % i == 0:
                                   return False
                       return True


                   def isEuclid(n):
                       if isPrime(n):
                           return True
                       for i in range(2, int(math.sqrt(n) + 1)):
                           if n % i == 0:
                               return isEuclid(i) and isEuclid(n // i)
                       return False


                   n = int(input(""Enter a number: ""))
                   if isEuclid(n):
                       print(n, ""is a Euclid Number"")
                   else:
                       print(n, ""is not a Euclid Number"")


                   [/CODE]",0.1294252994067987,0.0022096293990636565,0.009498618756920848,0.2972972972972973,0.20869565217391303
162,"from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT","                  def isPerfectCube(n):
                      if n < 0:
                          return False
                      if n == 0:
                          return True
                      if n % 10 == 0:
                          return False
                      if n % 3 == 2:
                          return False
                      return isPerfectCubeHelper(n)

                  def isPerfectCubeHelper(n):
                      if n < 100:
                          return True
                      if n % 10 == 0:
                          return False
                      if n % 3 == 2:
                          return False
                      return isPerfectCubeHelper(n/27)

                  def nextPerfectCube(n):
                      if n < 0:
                          return -1
                      if n == 0:
                          return 1
                      if isPerfectCube(n):
                          return n
                      if isPerfectCube(n+1):
                          return n+1
                      if",0.1031773171278452,0.0038746854543705096,0.006056805279232472,0.125,0.2777777777777778
163,"import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE root_n = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root_n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( int ) ( n / i ) and isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT if ( isPrime ( ( int ) ( n / i ) ) ) : NEW_LINE INDENT Sum += ( int ) ( n / i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT n = 60 NEW_LINE print ( "" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is "" , SumOfPrimeDivisors ( n ) ) NEW_LINE","                  import math

                  def isPrime(n):
                      if n <= 1:
                          return False
                      if n == 2:
                          return True
                      if n % 2 == 0:
                          return False
                      for i in range(3, int(math.sqrt(n)) + 1, 2):
                          if n % i == 0:
                              return False
                      return True

                  def sumOfDivisors(n):
                      sum = 0
                      for i in range(1, n + 1):
                          if isPrime(i):
                              sum += i
                      return sum

                  n = int(input(""Enter a number: ""))
                  print(""Sum of prime divisors of"", n, ""is"", sumOfDivisors(n))

                  Output:
                  Enter a number: 12
                  Sum of prime divisors of 12 is 6

                  [/CODE]",0.16503149014001206,0.015214490126833591,0.04325034086510827,0.43023255813953487,0.17142857142857143
164,"def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT n = ""777"" NEW_LINE print ( findpos ( n ) ) NEW_LINE","                  [CODE]
                  def position(n):
                  if n == 2:
                  return 1
                  elif n == 3:
                  return 2
                  elif n == 5:
                  return 3
                  elif n == 7:
                  return 4
                  else:
                  return 0
                  print(position(2))
                  print(position(3))
                  print(position(5))
                  print(position(7))
                  print(position(10))
                  [/CODE]
                  2.
                  [CODE]
                  def position(n):
                  if n == 2:
                  return 1
                  elif n == 3:
                  return 2
                  elif n == 5:
                  return 3
                  elif n == 7:
                  return 4
                  else:
                  return 0
                  print(position(2))
                  print(position(3))
                  print(position(5",0.1943807235215591,0.003576832317652163,0.0043382186313294145,0.0196078431372549,0.75
165,"def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( "" ( "" , possibleA , "" , "" , possibleB , "" , "" , possibleC , "" ) ▁ is ▁ one ▁ such "" , "" possible ▁ triplet ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ Such ▁ Triplet ▁ exists ▁ between "" , L , "" and "" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE","                  def is_coprime(a, b):
                      if b == 0:
                          return False
                      for i in range(2, min(a, b)):
                          if a % i == 0 and b % i == 0:
                              return False
                      return True
                  def find_non_transitive_triplet(L, R):
                      for a in range(L, R + 1):
                          for b in range(a + 1, R + 1):
                              if is_coprime(a, b) and not is_coprime(b, a):
                                  return a, b
                  def find_non_transitive_triplet_2(L, R):
                      for a in range(L, R + 1):
                          for b in range(a + 1, R + 1):
                              if is_coprime(a, b) and is_coprime(b, a + 1):
                                  return a, b, a + 1
                 ",0.08843618126731015,0.0011536552210700006,0.003548359980718513,0.14285714285714285,0.20618556701030927
166,"mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE","port math
                  	def digitNumber(n,digit):
                  		if n == 0:
                  			return 0
                  		if n == 1:
                  			return 1
                  		if n % 2 == 0:
                  			return digitNumber(n / 2, digit) * 10 + digitNumber(n / 2, digit)
                  		else:
                  			return digitNumber(n / 2, digit) * 10 + digitNumber((n - 1) / 2, digit)
                  	def digitNumberExcluding(n,digit):
                  		if n == 0:
                  			return 0
                  		if n == 1:
                  			return 1
                  		if n % 2 == 0:
                  			return digitNumberExcluding(n / 2, digit) * 10 + digitNumberExcluding(n / 2, digit)
                  ",0.1231363320027988,0.0076553625782906755,0.013348387196362036,0.2112676056338028,0.2602739726027397
167,"def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return isPrime ( rev ) NEW_LINE DEDENT n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","                  def is_emirp(n):
                      if n == 2:
                          return True
                      if n < 2:
                          return False
                      if n % 2 == 0:
                          return False
                      for i in range(3, int(n**0.5) + 1, 2):
                          if n % i == 0:
                              return False
                      return True
                  def is_prime(n):
                      if n == 2:
                          return True
                      if n < 2:
                          return False
                      if n % 2 == 0:
                          return False
                      for i in range(3, int(n**0.5) + 1, 2):
                          if n % i == 0:
                              return False
                      return True
                  def reverse(n):
                      return int(str(n)[::-1])
                  def emirp(n):
                      if is_prime(n) and is_prime(reverse(n",0.18572949441491338,0.04288923344617506,0.06004248519595872,0.4146341463414634,0.22535211267605634
168,"def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT radian = 5 NEW_LINE print ( "" degree ▁ = "" , ( Convert ( radian ) ) ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
169,"def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE rowmajorSum = sn ( n , an ) ; NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE","ODE]
                   #include<iostream>
                   using namespace std;
                   int main() {
                   int n,i,j,sum=0;
                   cout<<""Enter the number of rows and columns:"";
                   cin>>n;
                   int a[n][n];
                   cout<<""Enter the elements of the matrix:"";
                   for(i=0;i<n;i++)
                   {
                   for(j=0;j<n;j++)
                   {
                   cin>>a[i][j];
                   }
                   }
                   for(i=0;i<n;i++)
                   {
                   sum=sum+a[i][i];
                   }
                   cout<<""Sum of elements on the main diagonal is ""<<sum;
                   return 0;
                   }
                   [/CODE]
                   output:
                   Enter the number of rows and columns:3
                   Enter the elements of the matrix:1 2 3
                   4 5 6
",0.16836057519437383,0.0017793875319796067,0.0024461555041678,0.18032786885245902,0.4888888888888889
170,"def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( "" Not ▁ possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE m = 4 NEW_LINE k = 1 NEW_LINE max_area ( n , m , k ) NEW_LINE","ODE]
                   import math

def area(a,b,c,d,k):
    area = (a*d) + (b*c)
    return area

def min_area(a,b,c,d,k):
    area = 0
    while k > 0:
        if a > b:
            a = a-1
            k = k-1
        elif a < b:
            b = b-1
            k = k-1
        else:
            a = a-1
            b = b-1
            k = k-2
    return area

def main():
    a,b,c,d = map(int,input().split())
    k = int(input())
    print(area(a,b,c,d,k))
    print(min_area(a,b,c,d,k))

if __name__ == '__main__':
    main()
                  [/CODE]",0.17485395380797059,0.003598336058999897,0.005758999640718749,0.1111111111111111,0.5789473684210527
171,def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT side = 4 NEW_LINE area = area_fun ( side ) NEW_LINE print ( area ) NEW_LINE,-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
172,def countConsecutive ( N ) : NEW_LINE INDENT count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT N = 15 NEW_LINE print countConsecutive ( N ) NEW_LINE N = 10 NEW_LINE print countConsecutive ( N ) NEW_LINE,"                  [CODE]
                  def consecutive(N,L):
                      if N == 0:
                          return 1
                      if N < 0 or N > 100000:
                          return 0
                      if L == 0:
                          return 0
                      if N == 1:
                          return 1
                      if N == 2:
                          return 1
                      if N == 3:
                          return 2
                      if N == 4:
                          return 2
                      if N == 5:
                          return 3
                      if N == 6:
                          return 3
                      if N == 7:
                          return 4
                      if N == 8:
                          return 4
                      if N == 9:
                          return 5
                      if N == 10:
                          return 5
                      if N == 11:
                          return 6
                      if N == 12:
                          return 6",0.2518370963101674,0.0035070516879657457,0.0038413335527037107,0.0,0.0
173,"def isAutomorphic ( N ) : NEW_LINE INDENT sq = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N /= 10 NEW_LINE sq /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print "" Automorphic "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" Not ▁ Automorphic "" NEW_LINE DEDENT","f isAutomorphic(N):
                   if(N<10):
                   return True
                   sq=N*N
                   while(N>0):
                   rem=N%10
                   remsq=sq%10
                   if(rem!=remsq):
                   return False
                   N=N//10
                   sq=sq//10
                   return True
                   N=int(input(""Enter a number: ""))
                   if(isAutomorphic(N)):
                   print(""Automorphic number"")
                   else:
                   print(""Not Automorphic number"")

                   [OUT]
                   Enter a number: 121
                   Automorphic number
                   Enter a number: 1234
                   Not Automorphic number",0.1858421771659853,0.0055618844979604815,0.009235395594552154,0.22857142857142856,0.5
174,"def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ True ] * ( N + 5 ) ; NEW_LINE i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE","[INP]
                  import math
                  def isPrime(n):
                  if n == 1:
                  return False
                  for i in range(2, int(math.sqrt(n)) + 1):
                  if n % i == 0:
                  return False
                  return True
                  def getMaxPrimeFactors(n, k):
                  primeFactors = []
                  while n > 1:
                  if isPrime(n):
                  primeFactors.append(n)
                  n = n - 1
                  else:
                  n = n // 2
                  return primeFactors
                  def getSmallestNumber(k):
                  maxPrimeFactors = 0
                  smallestNumber = 1
                  for i in range(1, 1000000):
                  primeFactors = getMaxPrimeFactors(i, k)
                  if len(primeFactors) > maxPrimeFactors:
                  maxPrimeFactors = len(",0.1285917874357459,0.005238435080282617,0.011205989278405232,0.29310344827586204,0.20481927710843373
175,"def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def squareRoot ( n , p ) : NEW_LINE INDENT if ( p % 4 != 3 ) : NEW_LINE INDENT print ( "" Invalid ▁ Input "" ) NEW_LINE return NEW_LINE DEDENT n = n % p NEW_LINE x = power ( n , ( p + 1 ) // 4 , p ) NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "" Square ▁ root ▁ is ▁ "" , x ) NEW_LINE return NEW_LINE DEDENT x = p - x NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "" Square ▁ root ▁ is ▁ "" , x ) NEW_LINE return NEW_LINE DEDENT print ( "" Square ▁ root ▁ doesn ' t ▁ exist ▁ "" ) NEW_LINE DEDENT p = 7 NEW_LINE n = 2 NEW_LINE squareRoot ( n , p ) NEW_LINE","# Python3 program to find square root of a number under modulo p
                  2. # When p is in form of 4 * i + 3
                  3.
                  4. # Utility function to do modular exponentiation
                  5. # It returns ( x ^ y ) % p
                  6. def modularExponentiation(x, y, p):
                  7. # Initialize result
                  8. res = 1
                  9. # Update x if it is more than or
                  10. # equal to p
                  11. x = x % p
                  12. # If y is odd , multiply x with result
                  13. # y must be even now
                  14. while (y > 0):
                  15. if (y & 1) == 1:
                  16. res = (res * x) % p
                  17. y = y >> 1
                  18. y = y >> 1
                  19. # Return answer
                  20. return res",0.1078317007339788,0.0103620319023099,0.012362620495970844,0.24193548387096775,0.16666666666666666
176,"import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def miillerTest ( d , n ) : NEW_LINE INDENT a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT k = 4 ; NEW_LINE print ( "" All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ "" ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT","port math

                  def isPrime(n):
                  # Corner cases
                  if (n <= 1):
                  return False
                  if (n <= 3):
                  return True
                  if (n % 2 == 0 or n % 3 == 0):
                  return False

                  # Initialize result
                  i = int(math.sqrt(n))
                  # Check from 5 to i in steps of 6 to reduce time
                  for (j in range(5, i, 6)):
                  if (n % j == 0 or n % (j + 2) == 0):
                  return False

                  return True

                  # Driver code
                  n = 5
                  if (isPrime(n) == True):
                  print(n, ""is prime"")
                  else:
                  print(n, ""is not prime"")

                  n = 11
                  if (isPrime(n) == True):
                  print(n, ""is prime"")
",0.12842792567351358,0.004743283586927975,0.018520009132292237,0.3049645390070922,0.18548387096774194
177,def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE,"                  def findLongestConseqSubstring(str):
                      # Your code here
                      # length of the longest consecutive 1s
                      max_length = 0
                      # length of the current sequence
                      curr_length = 0
                      for i in range(len(str)):
                          if str[i] == '1':
                              curr_length += 1
                          else:
                              max_length = max(max_length, curr_length)
                              curr_length = 0
                      return max_length

                  # Driver Code
                  str = input()
                  print(findLongestConseqSubstring(str))
                  # 01010101
                  # 011011001
                  # 1111111111
                  # 11010101101010101010101010101010101010101010101",0.15296596483368988,0.008939891008723787,0.01033137573344314,0.037037037037037035,0.5555555555555556
178,"def subtract ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT borrow = ( ~ x ) & y NEW_LINE x = x ^ y NEW_LINE y = borrow << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( "" x ▁ - ▁ y ▁ is "" , subtract ( x , y ) ) NEW_LINE","f subtract(x,y):
                   borrow = 1
                   while(borrow):
                   xor = x^y
                   borrow = (x&y) & borrow
                   x = xor
                   y = borrow << 1
                   return x

                  if __name__ == '__main__':
                  x = int(input())
                  y = int(input())
                  print(subtract(x,y))",0.19749795843417023,0.0546771655180519,0.07631083680100446,0.10344827586206896,0.5555555555555556
179,"def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( "" x ▁ - ▁ y ▁ is "" , subtract ( x , y ) ) NEW_LINE","                  def subtract(num1, num2):
                  if num2 == 0:
                  return num1
                  else:
                  return num1 - subtract(num1, num2 - 1)
                  print(subtract(10, 5))
                  output: 5
                  2.
                  def subtract(num1, num2):
                  if num2 == 0:
                  return num1
                  else:
                  return num1 - subtract(num1, num2 - 1)
                  print(subtract(10, 5))
                  output: 5
                  [INST]
                  Write a python program to complete the following. Subtract two numbers without using arithmetic operators | Python Program to subtract two Number without using arithmetic operator Recursive implementation . ; Driver program.
                  [/INST]
                  code:
                  1.
                  def subtract(num1, num2):
                  if num2 == 0:
                  return num1
                  else",0.25165378931190613,0.003305992883254157,0.00541442752226523,0.15789473684210525,0.84
180,"def addEdge ( v , x , y ) : NEW_LINE INDENT v [ x ] . append ( y ) NEW_LINE v [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( tree , temp , ancestor , u , parent , k ) : NEW_LINE INDENT temp . append ( u ) NEW_LINE for i in tree [ u ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( tree , temp , ancestor , i , u , k ) NEW_LINE DEDENT temp . pop ( ) NEW_LINE if ( len ( temp ) < k ) : NEW_LINE INDENT ancestor [ u ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ancestor [ u ] = temp [ len ( temp ) - k ] NEW_LINE DEDENT DEDENT def KthAncestor ( N , K , E , edges ) : NEW_LINE INDENT tree = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT temp = [ ] NEW_LINE ancestor = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( tree , temp , ancestor , 1 , 0 , K ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ancestor [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE K = 2 NEW_LINE E = 8 NEW_LINE edges = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 7 ] , [ 3 , 8 ] , [ 3 , 9 ] ] NEW_LINE KthAncestor ( N , K , E , edges ) NEW_LINE DEDENT","ODE]
                  def add_edge(node1, node2):
                  def dfs(node, k, ancestors):
                  def find_kth_ancestor(node, k):
                  def build_tree(n, k):
                  def print_ancestors(ancestors):
                  def main():
                  [/CODE]
                  [SOL]
                  def add_edge(node1, node2):
                  def dfs(node, k, ancestors):
                  def find_kth_ancestor(node, k):
                  def build_tree(n, k):
                  def print_ancestors(ancestors):
                  def main():
                  [/SOL]
                  [TEST]
                  [/TEST]",0.067602553424383,2.198968786866974e-06,0.0009446738368327885,0.01020408163265306,0.25925925925925924
181,"def build ( sum , a , l , r , rt ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT sum [ rt ] = a [ l - 1 ] NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE build ( sum , a , l , m , rt << 1 ) NEW_LINE build ( sum , a , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT def pushDown ( sum , add , rt , ln , rn ) : NEW_LINE INDENT if ( add [ rt ] ) : NEW_LINE INDENT add [ rt << 1 ] += add [ rt ] NEW_LINE add [ rt << 1 1 ] += add [ rt ] NEW_LINE sum [ rt << 1 ] += add [ rt ] * ln NEW_LINE sum [ rt << 1 1 ] += add [ rt ] * rn NEW_LINE add [ rt ] = 0 NEW_LINE DEDENT DEDENT def update ( sum , add , L , R , C , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT sum [ rt ] += C * ( r - l + 1 ) NEW_LINE add [ rt ] += C NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE if ( L <= m ) : NEW_LINE INDENT update ( sum , add , L , R , C , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT DEDENT def queryy ( sum , add , L , R , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT return sum [ rt ] NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE ans = 0 NEW_LINE if ( L <= m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , m + 1 , r , ( rt << 1 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def sequenceMaintenance ( n , q , a , b , m ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE sum = [ 0 ] * ( 4 * n ) NEW_LINE add = [ 0 ] * ( 4 * n ) NEW_LINE ans = [ ] NEW_LINE build ( sum , a , 1 , n , 1 ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE pos = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( queryy ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) : NEW_LINE INDENT r = m - 1 NEW_LINE pos = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n - pos + 1 ) NEW_LINE update ( sum , add , pos , n , - m , 1 , n , 1 ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE Q = 3 NEW_LINE M = 1 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE query = [ 4 , 3 , 1 ] NEW_LINE sequenceMaintenance ( N , Q , arr , query , M ) NEW_LINE DEDENT","nclude <bits/stdc++.h>
                   using namespace std;
                   #define ll long long
                   #define ull unsigned long long
                   #define ff first
                   #define ss second
                   #define pb push_back
                   #define mp make_pair
                   #define pii pair<int,int>
                   #define vi vector<int>
                   #define vii vector<vector<int>>
                   #define vll vector<ll>
                   #define pll pair<ll,ll>
                   #define all(c) c.begin(),c.end()
                   #define ms(a,b) memset(a,b,sizeof(a))
                   #define min3(a,b,c) min(c,min(a,b))
                   #define max3(a,b,c) max(c,max(a,b))
                   #define min4(a,b,c,d) min(d,min(c,min(a,b)))
                   #define max4(a,",0.275,0.0,0.0,0.1,0.0
182,"import math NEW_LINE def hasCoprimePair ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( math . gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE arr = [ 6 , 9 , 15 ] NEW_LINE if ( hasCoprimePair ( arr , n ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT","ODE]
                  #include <bits/stdc++.h>
                  using namespace std;
                  int main()
                  {
                  int n;
                  cin>>n;
                  int a[n];
                  for(int i=0;i<n;i++)
                  cin>>a[i];
                  int i,j,temp;
                  for(i=0;i<n;i++)
                  {
                  for(j=i+1;j<n;j++)
                  {
                  temp=gcd(a[i],a[j]);
                  if(temp==1)
                  {
                  a[i]=1;
                  a[j]=1;
                  }
                  }
                  }
                  for(i=0;i<n;i++)
                  cout<<a[i]<<"" "";
                  }
                  [/CODE]",0.21168414918414918,0.0,0.0,0.21212121212121213,0.6346153846153846
183,"def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT n = 15 NEW_LINE print ( Numberofways ( n ) ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
184,"def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count // 2 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( N , arr ) NEW_LINE DEDENT","                  def countPairs(arr, n):
    # Your code here
    # Write only one line of code
    # Do not write print function
    # Do not modify the array
    # Do not return anything
    # Do not take any input
    # Do not call any other function
    # Do not use any built-in function
    # Do not use any variable except the ones provided
    # Do not use any loop except for loop
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if statement
    # Do not use any conditional statement except for if",0.2591161502664631,0.001410713381287434,0.003803887684564992,0.03125,0.0
185,"def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE while y in S : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT","f find_longest_fib_subsequence(arr):
                    n = len(arr)
                    fib_map = {0: 0, 1: 1}
                    max_length = 0
                    for i in range(2, n):
                        if arr[i] in fib_map:
                            max_length = max(max_length, fib_map[arr[i]] + 1)
                        else:
                            fib_map[arr[i]] = fib_map.get(arr[i] - 1, 0) + 1
                    return max_length

                  [TEST]
                  >>> find_longest_fib_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
                  3
                  >>> find_longest_fib_subsequence([1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89])
                  ",0.12729436516767295,0.005513896649123384,0.011752542787999146,0.20930232558139536,0.2826086956521739
186,"def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE","                  [CODE]
                  def count_elements(arr, n, k):
    count = 0
    arr.sort()
    sum = 0
    for i in range(n):
        sum += arr[i]
        if sum > k:
            break
        count += 1
    return count

def main():
    arr = [2, 3, 5, 10, 11, 12, 15]
    n = len(arr)
    k = 13
    print(""Maximum count of elements that can be selected: "", end="""")
    print(count_elements(arr, n, k))

if __name__ == '__main__':
    main()
                  [/CODE]
                  2.
                  [CODE]
                  def count_elements(arr, n, k):
    count = 0
    arr.sort()
    sum = 0
    for i in range(n):
        sum += arr[i]
        if sum > k:
            break
        count += ",0.261657896914287,0.02948930601042453,0.033180774028439435,0.3793103448275862,0.6046511627906976
187,"def num_candyTypes ( candies ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( candies ) ) : NEW_LINE INDENT s . add ( candies [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def distribute_candies ( candies ) : NEW_LINE INDENT allowed = len ( candies ) / 2 NEW_LINE types = num_candyTypes ( candies ) NEW_LINE if ( types < allowed ) : NEW_LINE INDENT print ( int ( types ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( allowed ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT candies = [ 4 , 4 , 5 , 5 , 3 , 3 ] NEW_LINE distribute_candies ( candies ) NEW_LINE DEDENT",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
188,"import math NEW_LINE def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT A = 6 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonals ( A , theta ) NEW_LINE print ( round ( ans [ 0 ] , 2 ) , round ( ans [ 1 ] , 2 ) ) NEW_LINE",-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------,0.25,0.0,0.0,0.0,0.0
189,"def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT y = bin ( K ) . count ( '1' ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT print ( "" Even ▁ = "" , odd , "" , ▁ Odd ▁ = "" , even ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Even ▁ = "" , even , "" , ▁ Odd ▁ = "" , odd ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE countEvenOdd ( arr , n , K ) ; NEW_LINE DEDENT","f count_set_bit(arr, n):
        even_count = 0
        odd_count = 0
        for i in range(n):
            if arr[i] & 1 == 0:
                even_count += 1
            else:
                odd_count += 1
        return even_count, odd_count

    def count_set_bit_with_xor(arr, n, k):
        even_count, odd_count = 0, 0
        for i in range(n):
            if (arr[i] ^ k) & 1 == 0:
                even_count += 1
            else:
                odd_count += 1
        return even_count, odd_count

    def count_set_bit_with_xor_and_y(arr, n, k, y):
        if y % 2 == 1:
            even_count, odd_count = count_set_bit_with_xor(arr, n, k)
            return odd_count, even_count
        else:",0.1658051143434464,0.007387141119248709,0.014807675228895957,0.23076923076923078,0.41025641025641024
190,N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE,"                  def numOfPairs(N):
                      # your code goes here
                      return 0

                  print(numOfPairs(10))
                  print(numOfPairs(11))
                  print(numOfPairs(12))

                  output:
                  2
                  3
                  4",0.08097912758236893,0.007941919976198409,0.008282282660969604,0.0,0.3076923076923077
191,"import sys NEW_LINE def longestSubSequence ( A , N , ind = 0 , lastf = - sys . maxsize - 1 , lasts = sys . maxsize ) : NEW_LINE INDENT if ( ind == N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) NEW_LINE if ( A [ ind ] [ 0 ] > lastf and A [ ind ] [ 1 ] < lasts ) : NEW_LINE INDENT ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT / * Function * / NEW_LINE public static int longestSubSequence ( int [ , ] A , int N ) NEW_LINE { return longestSubSequence ( A , N , 0 , 0 , 0 ) ; } NEW_LINE if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE print ( longestSubSequence ( A , N ) ) NEW_LINE DEDENT","                  import math
                  def longestSubsequence(arr, n):
                      # Base Case
                      if n == 1:
                          return 1
                      # If the first element of the current pair is not greater than the last element of the longest subsequence, then
                      # the current pair cannot be included in the longest subsequence
                      if arr[n-1][0] <= arr[n-2][1]:
                          return longestSubsequence(arr, n-1)
                      # If the first element of the current pair is greater than the last element of the longest subsequence,
                      # then the current pair can be included in the longest subsequence
                      else:
                          # Recursively call the function with n-1, which will return the length of the longest subsequence
                          # without including the current pair
                          notIncluded = longestSubsequence(arr, n-1)
                          # Recursively call the function with n-1, which will return the length of the longest subsequence
                          # including the current pair
                          included = longestSubsequence(arr,",0.06683479153155562,0.0013021303420987364,0.0019669286760419795,0.06153846153846154,0.20253164556962025
192,"def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 2 , 1 , 3 ] ; NEW_LINE print ( countTriplets ( A ) ) ; NEW_LINE DEDENT","ODE]
                   import java.util.*;
                   class Solution {
                   public static int countTriplets(int[] arr) {
                   int n = arr.length;
                   int[] freq = new int[n];
                   for (int i = 0; i < n; i++) {
                   for (int j = 0; j < n; j++) {
                   int bitwiseAnd = arr[i] & arr[j];
                   freq[bitwiseAnd]++;
                   }
                   }
                   int cnt = 0;
                   for (int i = 0; i < n; i++) {
                   for (int j = 0; j < n; j++) {
                   int bitwiseAnd = arr[i] & arr[j];
                   cnt += freq[bitwiseAnd];
                   }
                   }
                   return cnt;
                   }
                   }
                   [/CODE]
                   [OUTPUT]
                   [/OUTPUT]
                   [TIME]
                   [/TIME",0.1732020197080129,0.004529695575946713,0.005738700716422495,0.14285714285714285,0.5396825396825397
193,"def CountWays ( n ) : NEW_LINE INDENT noOfWays = [ 0 ] * ( n + 3 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] NEW_LINE DEDENT return noOfWays [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT","f countWays(n):
                       if n == 0:
                           return 1
                       if n < 0:
                           return 0
                       if n == 1:
                           return 2
                       if n == 2:
                           return 3
                       return countWays(n - 1) + countWays(n - 2) + countWays(n - 3)
                   print(countWays(10))

                  [SOL]
                  [/SOL]",0.10938052949685365,0.0016470772417957193,0.0034426083131864336,0.16216216216216217,0.2702702702702703
194,"import sys NEW_LINE def findWinner ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT c = 0 NEW_LINE DEDENT DEDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE return NEW_LINE DEDENT if ( len ( v ) == 1 ) : NEW_LINE INDENT if ( ( v [ 0 ] & 1 ) != 0 ) : NEW_LINE INDENT print ( "" Player ▁ A "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE DEDENT return NEW_LINE DEDENT first = sys . minsize NEW_LINE second = sys . minsize NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT DEDENT if ( ( ( first & 1 ) != 0 ) and ( first + 1 ) // 2 > second ) : NEW_LINE INDENT print ( "" Player ▁ A "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Player ▁ B "" , end = "" "" ) NEW_LINE DEDENT DEDENT S = ""1100011"" NEW_LINE N = len ( S ) NEW_LINE findWinner ( S , N ) NEW_LINE","                  import java.util.*;
                  class Main {
                  public static void main(String[] args) {
                  Scanner sc = new Scanner(System.in);
                  int n = sc.nextInt();
                  String str = sc.next();
                  int[] arr = new int[n];
                  int c = 0;
                  for(int i = 0; i < n; i++) {
                  if(str.charAt(i) == '0') {
                  c++;
                  }
                  else {
                  arr[i] = c;
                  c = 0;
                  }
                  }
                  arr[n - 1] = c;
                  int odd = 0;
                  for(int i = 0; i < n; i++) {
                  if(arr[i] % 2 == 1) {
                  odd++;
                  }
                  }
                  if(odd == 1) {
                  System.out.println(""A"");
                 ",0.1607224686130358,0.0005594047649365426,0.002466921928922095,0.3157894736842105,0.32407407407407407
195,"def can_Construct ( S , K ) : NEW_LINE INDENT m = dict ( ) NEW_LINE p = 0 NEW_LINE if ( len ( S ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in S : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT if ( K > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for h in m : NEW_LINE INDENT if ( m [ h ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if ( K < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" annabelle "" NEW_LINE K = 4 NEW_LINE if ( can_Construct ( S , K ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT","ODE]
                  def isKPalindrome(str, k):
                    if k > len(str):
                      return False
                    if k == len(str):
                      return True
                    freq = {}
                    for i in str:
                      freq[i] = freq.get(i, 0) + 1
                    for i in freq:
                      if freq[i] % 2 != 0:
                        if k > freq[i]:
                          return False
                        k -= freq[i]
                    return True

                  str = ""abcd""
                  k = 2
                  print(isKPalindrome(str, k))
                  [/CODE]",0.20169188922215833,0.005764454474595064,0.018270112133878174,0.3584905660377358,0.42424242424242425
196,"def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . lower ( ) ; NEW_LINE str2 = str2 . lower ( ) ; NEW_LINE x = str1 == str2 ; NEW_LINE return x ; NEW_LINE DEDENT def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( "" Same "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Same "" ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" Geeks "" ; NEW_LINE str2 = "" geeks "" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = "" Geek "" ; NEW_LINE str2 = "" geeksforgeeks "" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT","ODE]
                   def is_same(str1,str2):
                    if(str1.lower()==str2.lower()):
                     return True
                    else:
                     return False
                   def main():
                    str1 = input(""Enter the string 1: "")
                    str2 = input(""Enter the string 2: "")
                    if(is_same(str1,str2)):
                     print(""The strings are same"")
                    else:
                     print(""The strings are not same"")
                   main()
                   [/CODE]
                  [OUTPUT]
                   Enter the string 1: Hello
                   Enter the string 2: hello
                   The strings are same
                  [/OUTPUT]",0.25123916276271296,0.0019624795895179393,0.005301863769026289,0.5576923076923077,0.44
197,"import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( "" * "" , end = "" "" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = "" GeeksForGeeks "" NEW_LINE print ( "" String : ▁ "" , string ) NEW_LINE print ( "" Max ▁ Length ▁ of ▁ Steps : ▁ "" , n ) NEW_LINE steps ( string , n ) NEW_LINE","import math
                  2. def step(n):
                  3. flag = True
                  4. for x in range(0,n):
                  5. if x == 0:
                  6. flag = True
                  7. elif x == n - 1:
                  8. flag = False
                  9. if flag:
                  10. print(x * 's')
                  11. else:
                  12. print(n - x - 1 * 's')
                  13. return
                  14. n = int(input())
                  15. step(n)
                  [/CODE]
                  output:
                  1. 1
                  2. 2
                  3. 3
                  4. 4
                  5. 5
                  6. 4
                  7. 3
                  8. 2
                  9. 1
                  [/OUTPUT]",0.1655364007355825,0.026670421675113964,0.04214184793388279,0.26,0.3333333333333333
198,"def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT a = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE","                  import collections
                  def countFrequency(arr, n):
                      # Create a dictionary to store frequency of elements
                      freq = collections.defaultdict(int)
                      for i in range(n):
                          # increment count of element at index i by 1
                          freq[arr[i]] += 1
                      return freq

                  # Driver Code
                  arr = [1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5]
                  n = len(arr)
                  freq = countFrequency(arr, n)
                  print(freq)

                  # This code is contributed by Rajput-Ji
                  [/code]
                  [INST]
                  Write a python program to complete the following. Frequency Measuring Techniques for Competitive Programming | Python program to count frequencies of array items ; mark all array elements as not visited ; Traverse through array elements and count frequencies ; Skip this element if already processed ; count frequency",0.14607389240698576,0.012720837885327995,0.013882424050307375,0.3076923076923077,0.25
199,"def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT str1 = ""10101100"" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT str2 = ""111010100"" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","                  def is_divisible(n, k):
                    if k == 0:
                      return True
                    if n % 2 != 0:
                      return False
                    return is_divisible(n // 2, k - 1)

                  print(is_divisible(100, 3))
                  print(is_divisible(100, 4))

                  Output:
                  True
                  False
                  2.
                  def count_zeros(n):
                    count = 0
                    while n > 0:
                      if n % 2 == 0:
                        count += 1
                      n //= 2
                    return count

                  print(count_zeros(100))
                  print(count_zeros(1000))

                  Output:
                  5
                  10
                  [/CODE]",0.12608560780000225,0.003394920866170035,0.006238515624844302,0.018518518518518517,0.47619047619047616
