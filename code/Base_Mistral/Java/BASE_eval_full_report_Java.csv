,value,value,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
0,"import java . util . * ; class GFG { static int minSum ( int A [ ] , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( mp . containsKey ( A [ i ] ) ) { mp . put ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; } else { mp . put ( A [ i ] , 1 ) ; } } int minSum = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { minSum = Math . min ( minSum , sum - ( it . getKey ( ) * it . getValue ( ) ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = arr . length ; System . out . print ( minSum ( arr , N ) + ""NEW_LINE""); } }","2-25T05:03:48+05:30

```
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int min = Integer.MAX_VALUE;
        int[] freq = new int[1000001];
        for (int i = 0; i < n; i++) {
            freq[arr[i]]++;
        }
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = 0; j < n; j++) {
                sum += freq[arr[j]];
            }
            if (sum < min) {
                min = sum;
           ",0.16022652700977724,0.009971882744898764,0.017309081308691097,0.42718446601941745,0.1864406779661017
1,"import java . util . * ; class GFG { static void maxAdjacent ( int [ ] arr , int N ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = Integer . MIN_VALUE ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . add ( maxi ) ; } for ( int x : res ) { System . out . print ( x + "" ▁ "" ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }","8-05T06:20:39.123Z

The above code is working fine. The following code is working fine.

```
public static int[] maxDiff(int[] arr, int n) {
    int maxDiff = Integer.MIN_VALUE;
    int prev = Integer.MIN_VALUE;
    Vector<Integer> v = new Vector<Integer>();
    for (int i = 0; i < n; i++) {
        int diff = arr[i] - prev;
        if (diff > maxDiff)
            maxDiff = diff;
        prev = arr[i];
        v.add(arr[i]);
    }
    return v.toArray(new int[0]);
}
```

But when I run the following code, I get an error.

```
public static int[] maxDiff(int[] arr, int n) {
    int maxDiff = Integer.MIN_VALUE;
    int prev = Integer.MIN_VALUE;
    Vector<Integer> v = new Vector<Integer>();
    for (",0.21666819461358916,0.009114842299603704,0.014020521188766566,0.5102040816326531,0.3333333333333333
2,"import java . util . * ; class GFG { static int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; } static int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } public static void main ( String [ ] args ) { int N = 7 , L = 2 , R = 5 ; System . out . println ( CountOnes ( N , L , R ) ) ; } }", 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ,0.25055239965241444,0.0010044890096775694,0.0012051095999802627,0.0,0.0
3,"class GFG { static boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void minDivisior ( int n ) { if ( prime ( n ) ) { System . out . print ( 1 + "" ▁ "" + ( n - 1 ) ) ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { System . out . print ( n / i + "" ▁ "" + ( n / i * ( i - 1 ) ) ) ; break ; } } } } public static void main ( String [ ] args ) { int N = 4 ; minDivisior ( N ) ; } }","3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67",0.2504800665934286,0.0009916880097114035,0.0009285783640028659,0.0,0.0
4,"import java . util . * ; class GFG { static int Landau = Integer . MIN_VALUE ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } static void findLCM ( Vector < Integer > arr ) { int nth_lcm = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr . get ( i ) ) ; Landau = Math . max ( Landau , nth_lcm ) ; } static void findWays ( Vector < Integer > arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } } static void Landau_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ; findWays ( arr , 1 , n ) ; System . out . print ( Landau ) ; } public static void main ( String [ ] args ) { int N = 4 ; Landau_function ( N ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
5,"class GFG { static boolean isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static void checkExpression ( int n ) { if ( isPrime ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } public static void main ( String [ ] args ) { int N = 3 ; checkExpression ( N ) ; } }", 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 ,0.2505548707057282,0.0011676639698018933,0.001051818853110781,0.0,0.0
6,"class GFG { static boolean checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = arr . length ; int k = 4 ; if ( checkArray ( n , k , arr ) ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } }",этэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэ,0.25,0.0,0.0,0.0,0.0
7,"class GFG { static long func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ ] = new double [ 100005 ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ; double cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . min ( maxx , ( int ) ( Math . ceil ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( long ) ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( func ( arr , n ) + ""NEW_LINE""); } }", 2 3 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86,0.2502007042404638,0.00018289559551898,0.000619921366336347,0.0,0.0
8,"class GFG { static void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { System . out . println ( ""0"" ) ; return ; } if ( Xor == 0 ) { System . out . println ( ""1"" ) ; System . out . println ( Sum ) ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; System . out . print ( ""2"" ) ; System . out . println ( num1 + "" ▁ "" + num2 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; insert_element ( a , n ) ; } }",00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-08-06 18:00:00 2019-0,0.25,0.0,0.0,0.0,0.0
9,"class GFG { static void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; } }"," Java Program to Check if Roots of a Quadratic Equation are Reciprocal of Each Other or Not

[INST] Write a Java program to complete the following. Check if roots of a Quadratic Equation are reciprocal of each other or not | Java program to check if roots of a quadratic equation are reciprocal of each other or not ; Function to check if the roots of a quadratic equation are reciprocal of each other or not ; Driver code [/INST] \n  Industries 1.

The roots of a quadratic equation are reciprocal of each other if the value of one root is equal to the reciprocal of the other root.

For example, the roots of the quadratic equation are reciprocal of each other.

In this case, the roots of the quadratic equation are 2 and 1/2.

The roots of a quadratic equation are reciprocal of each other if the value of one root is equal to the reciprocal of the other root.

For example, the roots of the quadratic equation are reciprocal of each other.

In this case,",0.20134214675309367,0.0017041357563770474,0.003664451255997568,0.0,0.8
10,"import java . util . * ; class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { System . out . println ( "" Yes "" ) ; } else { System . out . println ( "" No "" ) ; } } public static void main ( String [ ] args ) { int N = 8 ; checkSunnyNumber ( N ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2507394491958803,0.0015321128292348275,0.001425683954286469,0.0,0.0
11,import java . io . * ; import java . util . * ; class GFG { static int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } public static void main ( String args [ ] ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } },68.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 192.168.1.100 19,0.25,0.0,0.0,0.0,0.0
12,"class GFG { static void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + "" ▁ "" ) ; System . out . print ( N - K + 1 ) ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; } }",2-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+05:30 2019-12-21T14:02:07+0,0.0375,0.0,0.0,0.0,0.15
13,import java . util . * ; class GFG { static int NthSmallest ( int K ) { Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . peek ( ) ; Q . remove ( ) ; if ( x % 10 != 0 ) { Q . add ( x * 10 + x % 10 - 1 ) ; } Q . add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . add ( x * 10 + x % 10 + 1 ) ; } } return x ; } public static void main ( String [ ] args ) { int N = 16 ; System . out . print ( NthSmallest ( N ) ) ; } },n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 2017 \n 201,0.011904761904761904,0.0,0.0,0.0,0.047619047619047616
14,class GFG { static int nearest ( int n ) { int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( nearest ( n ) ) ; n = 16 ; System . out . println ( nearest ( n ) ) ; n = 18 ; System . out . println ( nearest ( n ) ) ; } },"2-18T16:51:35.630Z

The Java programming language is a general-purpose, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is intended to let application developers ""write once, run anywhere"" (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation.

Java applications are typically compiled to Java bytecode (class file) that can run on any Java virtual machine (JVM) regardless of the underlying computer architecture. The semantics of the bytecode are defined by the Java Virtual Machine Specification. Java virtual machines have been highly optimized, and run efficiently.

Java is one of the most popular programming languages in use as of 2019. It is used by over 9 million developers worldwide, and runs on 3 billion devices. Java was originally developed by James Gosling at Sun Microsystems (which has since been acquired by Oracle) and released in 1995 as a core component of Sun Microsystems' Java platform.

Java was originally developed",0.1749553305539011,0.0,0.0,0.1780821917808219,0.5217391304347826
15,class GFG { static void printValueOfPi ( int N ) { double pi = 2 * Math . acos ( 0.0 ) ; System . out . println ( pi ) ; } public static void main ( String [ ] args ) { int N = 4 ; printValueOfPi ( N ) ; } },000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
16,"class GFG { static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int getNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } public static void main ( String [ ] args ) { int n = 56 ; int k = 2 ; System . out . println ( getNum ( n , k ) ) ; } }",rite a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number. Write a Java program to find the nth bit of a number,0.15193114858327345,0.001099119508919257,0.0009916720072730948,0.0,0.6056338028169014
17,"import java . io . * ; class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ; static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } static void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; } public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }",16 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28 15 2016 16:13:28,0.25,0.0,0.0,0.0,0.0
18,"class GFG { static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; } static long findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = Long . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; } else { high = mid ; } } return low ; } public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 5 , n = 100 ; System . out . println ( findNthTerm ( a , b , c , n ) ) ; } }","9-15T05:39:29.000Z

```
public class Main {

    public static void main(String[] args) {
        int n = 1000;
        int a = 3;
        int b = 2;
        int c = 5;
        System.out.println(findNthTerm(n, a, b, c));
        System.out.println(countDivisibleBy(n, a, b, c));
        System.out.println(countDivisibleBy2(n, a, b, c));
        System.out.println(countDivisibleBy3(n, a, b, c));
        System.out.println(countDivisibleBy4(n, a, b, c));
        System.out.println(countDivisibleBy5(n, a, b, c));
        System.out.println(countDivisibleBy6(n, a, b, c));
        System.out.println(countDivisibleBy7(n, a, b, c));",0.14083183333313792,0.0009061572790097747,0.010052196718270436,0.23776223776223776,0.3146067415730337
19,"class GFG { static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }","5-10T06:02:20.163Z

[INST] Write a Java program to complete the following. 1.2.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.",0.25588235294117645,0.0,0.0,0.023529411764705882,0.0
20,"class GFG { static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( "" Loss ▁ = ▁ "" + loss ) ; } public static void main ( String [ ] args ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; } }","кции для нахождения убытка, когда два товара продаются за один и тот же цену и один и тот же процент убытка.

## Java implementation of above approach

Создадим функцию для нахождения убытка, когда два товара продаются за один и тот же цену и один и тот же процент убытка.

```
public static int loss(int price1, int price2, int profit) {
    return price1 * profit - price2 * profit;
}
```

## Driver Code

Теперь мы можем вызвать функцию loss в следующем коде.

```
public static void main(String[] args) {
    int price1 = 10;
    int price2 = 20;
    int profit = 5;

    System.out.println(loss(price1, price2, profit));
}
```

## Output

```
100
```

## Java implementation of",0.2382026671493831,0.013614256367310298,0.019823511894275787,0.3404255319148936,0.5789473684210527
21,"class GFG { static int MAXN = 1000001 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] hash1 = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } static boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } static boolean hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }",21-01-26T10:53:57+05:30 2021-01-26T10:53:57+05:30,0.0020833333333333333,0.0,0.0,0.0,0.008333333333333333
22,"class GfG { static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }"," static int oddEdges(int V, int E, int[][] adj) { int count = 0; for (int i = 0; i < V; i++) { for (int j = 0; j < V; j++) { if (adj[i][j] % 2 == 1) { count++; } } } return count; } \n ѝ public static void main(String[] args) { int V = 4, E = 6; int[][] adj = { { 0, 1, 0, 1 }, { 1, 0, 1, 0 }, { 0, 1, 0, 1 }, { 1, 0, 1, 0 } }; int count = oddEdges(V, E, adj); System.out.println(count); } \n \n \n ѝ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",0.21747713536717034,0.015436864626204196,0.029296851667651894,0.36363636363636365,0.46153846153846156
23,"class GFG { static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } static int nCr ( int n , int r ) { return l [ n ] [ r ] ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 8 ; int r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25041701202061234,0.000738773391033352,0.0009292746914158972,0.0,0.0
24,class GFG { static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } },ммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм,0.25,0.0,0.0,0.0,0.0
25,"class GFG { static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; } public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( ""YesNEW_LINE""); else System . out . println ( ""NoNEW_LINE""); } }",4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8,0.25080849558601376,0.0016737955311784652,0.0015601868128764732,0.0,0.0
26,"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + "" ▁ "" + k * ( 6 * i + 2 ) + "" ▁ "" + k * ( 6 * i + 3 ) + "" ▁ "" + k * ( 6 * i + 5 ) ) ; } } public static void main ( String args [ ] ) { int n = 2 , k = 2 ; printLines ( n , k ) ; } }","ы выполнить следующее. Принтить N строк, содержащих 4 числа таким образом, что каждый пару из 4 чисел имеет наибольший общий делитель K. Java implementation of the above approach ; Function to print N lines ; Iterate N times to print N lines ; Driver Code [/INST] \n

### Java Program to Print N Lines of 4 Numbers with GCD K

The following is the implementation of the above approach:.

## Java Program to Print N Lines of 4 Numbers with GCD K

We have to print N lines of 4 numbers such that every pair among 4 numbers has a GCD K. The algorithm is as follows:.

### Java Program to Print N Lines of 4 Numbers with GCD K

We have to print N lines of 4 numbers such that every pair among 4 numbers has a GCD K. The algorithm is as follows:.

The function prints N lines of 4 numbers such that every pair among 4 numbers has a GCD K. The function takes",0.12810040169287165,0.001414139410734909,0.001553505096600714,0.0,0.5094339622641509
27,"import java . util . * ; class GFG { static int calculateSum ( int n ) { return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( "" Sum ▁ = ▁ "" + calculateSum ( n ) ) ; } }"," 2. [INST] Write a Java program to find sum of first n terms of series 3 , 5 , 9 , 17 , 33 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",0.25116002024812256,0.0012179114354631015,0.0034221695570272417,0.0,0.0
28,"import java . util . * ; class GFG { static final int mod = 1000000007 ; static int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( count_special ( n ) + ""NEW_LINE""); } }",20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 1,0.2506078454651249,0.0012091844237040804,0.0012221974367953993,0.0,0.0
29,"import java . io . * ; class GFG { static int mod = 1000000000 ; static int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( 0 , arr , n ) ) ; } }",2-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+05:30 2021-02-17T11:44:00+0,0.005952380952380952,0.0,0.0,0.0,0.023809523809523808
30,"class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ; static int ways ( int arr [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( arr , n ) % mod ) ; } }","] Write a Java program to complete the following. Counts Path in an Array | Java implementation of above approach ; find the number of ways to reach the end ; dp to store value ; base case ; Bottom up dp structure ; F [ i ] is dependent of F [ i + 1 ] to F [ i + k ] ; Return value of dp [ 0 ] ; Driver code [/INST] \n naio 2017, 1:06 PM 2017-05-18T13:06:00+05:30 2017-05-18T13:06:00+05:30 2017-05-18T13:06:00+05:30 2017-05-18T13:06:00+05:30 2017-05-18T13:06:00+05:30 2017-05-18T13:06:00+05",0.09405462683539158,0.023985636164662576,0.03168549402575297,0.13186813186813187,0.18867924528301888
31,"class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair countSum ( int arr [ ] , int n ) { int result = 0 ; int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; pair ans = countSum ( arr , n ) ; System . out . print ( "" EvenSum ▁ = ▁ "" + ans . first ) ; System . out . print ( "" ▁ OddSum ▁ = ▁ "" + ans . second ) ; } }",T] Write a Java program to complete the following. Number of Subsequences with Even and Odd Sum | Java program to get minimum cost to sort strings by reversal operation ; Returns the count of odd and even subsequences ; Variables to store the count of even subsequences and odd subsequences ; Initialising count_even and count_odd to 0 since as there is no subsequence before the iteration with even or odd count . ; Find sum of all subsequences with even count and odd count and storing them as we iterate . ; if the number is even ; if the number is odd ; Driver code ; Calling the function [/INST] \n ССР. [INST] Write a Java program to complete the following. Number of Subsequences with Even and Odd Sum | Java program to get minimum cost to sort strings by reversal operation ; Returns the count of odd and even subsequences ; Variables to store the count of even subsequences and odd subsequences ; Initialising count_even and count_odd to 0 since as there is no subsequence before the iteration with even or odd count . ; Find sum of all subsequences with even count and odd count and storing them as we iterate,0.12218341826869399,0.0017082802040928457,0.0016271627821875221,0.035398230088495575,0.45
32,"import java . util . * ; class GFG { static int MAX = 10 ; static Vector < Integer > numToVec ( int N ) { Vector < Integer > digit = new Vector < Integer > ( ) ; while ( N != 0 ) { digit . add ( N % 10 ) ; N = N / 10 ; } if ( digit . size ( ) == 0 ) digit . add ( 0 ) ; Collections . reverse ( digit ) ; return digit ; } static int solve ( Vector < Integer > A , int B , int C ) { Vector < Integer > digit = new Vector < Integer > ( ) ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A . get ( 0 ) == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return ( int ) Math . pow ( d , B ) ; } else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) lower [ A . get ( i ) + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit . get ( i - 1 ) ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A . get ( 0 ) == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit . get ( i - 1 ) + 1 ] == lower [ digit . get ( i - 1 ) ] + 1 ) ) ; } return dp [ B ] ; } } public static void main ( String [ ] args ) { Integer arr [ ] = { 0 , 1 , 2 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int N = 2 ; int k = 21 ; System . out . println ( solve ( A , N , k ) ) ; } }",04950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1639204950 1,0.25007915253881635,8.374047962889648e-12,0.00031661014689126363,0.0,0.0
33,"class GFG { public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; } public static void main ( String [ ] args ) { int W = 3 , K = 3 , M = 2 ; int [ ] [ ] dp = new int [ W + 1 ] [ 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( solve ( dp , W , K , M , 0 ) + ""NEW_LINE""); } }", 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8,0.25,0.0,0.0,0.0,0.0
34,class GFG { static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( partitions ( N ) ) ; } },te a Java program to find the number of ways to write a number as sum of two or more positive integers. 1. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 2. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 3. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 4. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 5. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 6. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 7. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 8. Write a Java program to find the number of ways to write a number as sum of two or more positive integers. 9. Write a Java program to find the number of ways,0.15,0.0,0.0,0.0,0.6
35,"import java . util . * ; class GFG { static int LIP ( int dp [ ] [ ] , int mat [ ] [ ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } static int wrapper ( int mat [ ] [ ] , int n , int m ) { int dp [ ] [ ] = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; System . out . println ( wrapper ( mat , n , m ) ) ; } }",. ; 3. ; 4. ; 5. ; 6. ; 7. ; 8. ; 9. ; 10. ; 11. ; 12. ; 13. ; 14. ; 15. ; 16. ; 17. ; 18. ; 19. ; 20. ; 21. ; 22. ; 23. ; 24. ; 25. ; 26. ; 27. ; 28. ; 29. ; 30. ; 31. ; 32. ; 33. ; 34. ; 35. ; 36. ; 37. ; 38. ; 39. ; 40. ; 41. ; 42. ; 43. ; 44. ; 45. ; 46. ; 47. ; 48. ; 49. ; 50. ; 51. ; 52. ; 53. ;,0.25027298606395754,0.00022739467279844002,0.0008645495830316287,0.0,0.0
36,"import java . io . * ; class GFG { static int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( "" ▁ Number ▁ of ▁ Paths ▁ "" + countPaths ( n , m ) ) ; } }",7-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+05:30 2019-07-25T15:10:16+0,0.04411764705882353,0.0,0.0,0.0,0.17647058823529413
37,"import java . util . Arrays ; class GFG { static final int MAX = 100 ; static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } public static void main ( String arg [ ] ) { int gold [ ] [ ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; System . out . print ( getMaxGold ( gold , m , n ) ) ; } }","2019 10:18 22.05.2019 12:07. Gold Mine Problem. 1. A miner starts from the first column and can move right, right up, or right down. 2. The miner can collect the gold on the cell he is on. 3. The miner can collect the gold on the cell he is on. 4. The miner can collect the gold on the cell he is on. 5. The miner can collect the gold on the cell he is on. 6. The miner can collect the gold on the cell he is on. 7. The miner can collect the gold on the cell he is on. 8. The miner can collect the gold on the cell he is on. 9. The miner can collect the gold on the cell he is on. 10. The miner can collect the gold on the cell he is on. 11. The miner can collect the gold on the cell he is on. 12. The miner can collect the gold on the cell he is on. 13. The miner can collect the gold on the cell he is on",0.06612748555918557,0.0006097528625644443,0.0007422946373357484,0.0,0.2631578947368421
38,"import java . io . * ; import java . util . * ; class GFG { public static int M = 100 ; static int minAdjustmentCost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = arr . length ; int target = 10 ; System . out . println ( "" Minimum ▁ adjustment ▁ cost ▁ is ▁ "" + minAdjustmentCost ( arr , n , target ) ) ; } }", 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 ,0.2502751074293903,0.00020481601907200038,0.0008956136984892532,0.0,0.0
39,"import java . util . * ; class GFG { static int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } public static void main ( String [ ] args ) { int L = 2 , R = 6 ; System . out . print ( totalCombination ( L , R ) ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2507858506073801,0.0016441704186258947,0.0014992320108946024,0.0,0.0
40,"import java . io . * ; import java . util . * ; class GFG { static void printArrays ( int n ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; ArrayList < Integer > B = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . add ( i ) ; else B . add ( i ) ; } System . out . print ( "" { ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( A . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( "" , ▁ "" ) ; } System . out . print ( "" }NEW_LINE""); System . out . print ( "" { ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( B . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( "" , ▁ "" ) ; } System . out . print ( "" ▁ } "" ) ; } public static void main ( String [ ] args ) { int N = 5 ; printArrays ( N ) ; } }",[INP] \n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85,0.2503004785334013,0.00036624396777318357,0.0008356701658320103,0.0,0.0
41,"import java . util . * ; class GFG { static void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } System . out . print ( A + "" ▁ "" + B ) ; } public static void main ( String [ ] args ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; } }",[/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST] \n [/INST] \n [INST],0.25,0.0,0.0,0.0,0.0
42,import java . util . * ; class GFG { static int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } },2021 13:15:41 [INST] Write a Java program to complete the following. Count of distinct pair sum between two 1 to N value Arrays | Java implementation to find count of distinct pair sum between two 1 to N value Arrays ; Function to find the distinct sums ; Driver code [/INST] \n 2021-12-12 13:15:41 [INST] Write a Java program to complete the following. Count of distinct pair sum between two 1 to N value Arrays | Java implementation to find count of distinct pair sum between two 1 to N value Arrays ; Function to find the distinct sums ; Driver code [/INST] \n 2021-12-12 13:15:41 [INST] Write a Java program to complete the following. Count of distinct pair sum between two 1 to N value Arrays | Java implementation to find count of distinct pair sum between two 1 to N value Arrays ; Function to find the distinct sums ; Driver code [/INST] \n 2021-12-1,0.21597652023913375,0.001980803797355383,0.004782420016322452,0.0,0.8571428571428571
43,"import java . util . * ; class GFG { public static int countSubstrings ( String str ) { int [ ] freq = new int [ 3 ] ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str . charAt ( j ) - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charAt ( i ++ ) - '0' ] -- ; } count += i ; } return count ; } public static void main ( String [ ] args ) { String str = ""00021"" ; System . out . println ( countSubstrings ( str ) ) ; } }","3-16 15:13:53 [INST] Write a Java program to complete the following. Count of substrings from given Ternary strings containing characters at least once | Java program for the above approach ; Function to count the number of substrings consists of 0 , 1 , and 2 ; Initialize frequency array of size 3 ; Stores the resultant count ; Traversing string str ; Update frequency array ; If all the characters are present counting number of substrings possible ; Update number of substrings ; Return the number of substrings ; Driver Code [/INST] \n 2021-03-16 15:13:53 [INST] Write a Java program to complete the following. Count of substrings from given Ternary strings containing characters at least once | Java program for the above approach ; Function to count the number of substrings consists of 0 , 1 , and 2 ; Initialize frequency array of size 3 ; Stores the resultant count ; Traversing string str ; Update frequency array ; If all the characters are present counting number of substrings possible ; Update number of substrings ; Return the number",0.1050109950191799,0.0038581217697057886,0.004421152424660879,0.0,0.4117647058823529
44,"import java . io . * ; class GFG { static int minFlips ( String str ) { int count = 0 ; if ( str . length ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . length ( ) - 2 { if ( str . charAt ( i ) == str . charAt ( i + 1 ) && str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { String S = ""0011101"" ; System . out . println ( minFlips ( S ) ) ; } }",2 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:43:03 2018 12 18 14:4,0.25043575904290083,0.000591660317855368,0.0011513758537479994,0.0,0.0
45,"import java . awt . * ; import java . util . * ; class GFG { static String convertToHex ( int num ) { StringBuilder temp = new StringBuilder ( ) ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp . append ( c ) ; num = num / 16 ; } return temp . toString ( ) ; } static String encryptString ( String S , int N ) { StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S . charAt ( i ) ; int count = 0 ; String hex ; while ( i < N && S . charAt ( i ) == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans . append ( ch ) ; ans . append ( hex ) ; } ans . reverse ( ) ; return ans . toString ( ) ; } public static void main ( String [ ] args ) { String S = "" abc "" ; int N = S . length ( ) ; System . out . println ( encryptString ( S , N ) ) ; } }",ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы,0.010745957224830464,0.0,0.0,0.014814814814814815,0.028169014084507043
46,"import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int countOfString ( int N ) { int Stotal = ( int ) Math . pow ( 2 , N ) ; int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( countOfString ( N ) ) ; } }",ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь,0.010638297872340425,0.0,0.0,0.0,0.0425531914893617
47,"class GFG { static String removeCharRecursive ( String str , char X ) { if ( str . length ( ) == 0 ) { return "" "" ; } if ( str . charAt ( 0 ) == X ) { return removeCharRecursive ( str . substring ( 1 ) , X ) ; } return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; } public static void main ( String [ ] args ) { String str = "" geeksforgeeks "" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; System . out . println ( str ) ; } }",1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. ,0.25,0.0,0.0,0.0,0.0
48,"import java . util . * ; class GFG { static boolean isValid ( char a1 , char a2 , String str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str . charAt ( 4 ) ; v2 = str . charAt ( 3 ) ; } else { v1 = str . charAt ( 1 ) ; v2 = str . charAt ( 0 ) ; } if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; } static boolean inRange ( int hh , int mm , int L , int R ) { int a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } static void displayTime ( int hh , int mm ) { if ( hh > 10 ) System . out . print ( hh + "" : "" ) ; else if ( hh < 10 ) System . out . print ( ""0"" + hh + "" : "" ) ; if ( mm > 10 ) System . out . println ( mm ) ; else if ( mm < 10 ) System . out . println ( ""0"" + mm ) ; } static void maximumTimeWithDifferenceInRange ( String str , int L , int R ) { int i = 0 , j = 0 ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ; if ( ! isValid ( ( char ) h1 , ( char ) h2 , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ; if ( ! isValid ( ( char ) m1 , ( char ) m2 , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else System . out . println ( "" - 1"" ) ; } public static void main ( String [ ] args ) { String timeValue = "" ? ? : ? ? "" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; } }",20:00 30:00 40:00 50:00 60:00 70:00 80:00 90:00 100:00 110:00 120:00 130:00 140:00 150:00 160:00 170:00 180:00 190:00 200:00 210:00 220:00 230:00 240:00 250:00 260:00 270:00 280:00 290:00 300:00 310:00 320:00 330:00 340:00 350:00 360:00 370:00 380:0,0.25,0.0,0.0,0.0,0.0
49,"import java . util . * ; class GFG { static boolean check ( String s , int n ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . isEmpty ( ) && st . peek ( ) == s . charAt ( i ) ) st . pop ( ) ; else st . add ( s . charAt ( i ) ) ; } if ( st . isEmpty ( ) ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { String str = "" aanncddc "" ; int n = str . length ( ) ; if ( check ( str , n ) ) { System . out . print ( "" Yes "" + ""NEW_LINE""); } else { System . out . print ( "" No "" + ""NEW_LINE""); } } }","еличивающий на 1 значение в ячейке с заданным индексом.

The function returns 0 if the given string is empty, otherwise it returns 1.

This function returns 1 if the given string is a palindrome, otherwise it returns 0. This function checks whether the given string can be split into even length palindromic substrings or not.

The function returns 1 if the given string can be split into even length palindromic substrings, otherwise it returns 0. This function returns 1 if the given string can be split into odd length palindromic substrings, otherwise it returns 0.

This function returns 1 if the given string can be split into palindromic substrings, otherwise it returns 0. This function returns 1 if the given string can be split into palindromic substrings, otherwise it returns 0. This function returns 1 if the given string can be split into palindromic substrings, otherwise it returns 0.

This function returns 1 if the given string can be split into palindromic substrings, otherwise it returns ",0.2079896713023736,0.001512892534785069,0.0018743641032807612,0.0,0.8285714285714286
50,"import java . util . * ; class GFG { static void findNumOfValidWords ( Vector < String > w , Vector < String > p ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; Vector < Integer > res = new Vector < > ( ) ; for ( String s : w ) { int val = 0 ; for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } if ( m . containsKey ( val ) ) m . put ( val , m . get ( val ) + 1 ) ; else m . put ( val , 1 ) ; } for ( String s : p ) { int val = 0 ; for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s . charAt ( 0 ) - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . containsKey ( temp ) ) { count += m . get ( temp ) ; } } temp = ( temp - 1 ) & val ; } res . add ( count ) ; } for ( int it : res ) { System . out . println ( it ) ; } } public static void main ( String [ ] args ) { Vector < String > arr1 = new Vector < > ( ) ; arr1 . add ( "" aaaa "" ) ; arr1 . add ( "" asas "" ) ; arr1 . add ( "" able "" ) ; arr1 . add ( "" ability "" ) ; arr1 . add ( "" actt "" ) ; arr1 . add ( "" actor "" ) ; arr1 . add ( "" access "" ) ; Vector < String > arr2 = new Vector < > ( ) ; arr2 . add ( "" aboveyz "" ) ; arr2 . add ( "" abrodyz "" ) ; arr2 . add ( "" absolute "" ) ; arr2 . add ( "" absoryz "" ) ; arr2 . add ( "" actresz "" ) ; arr2 . add ( "" gaswxyz "" ) ; findNumOfValidWords ( arr1 , arr2 ) ; } }",te a Java program to complete the following. Number of strings in two array satisfy the given conditions | Java program for the above approach ; To store the frequency of String after bitmasking ; To store result for each string in arr2 [ ] ; Traverse the arr1 [ ] and bitmask each string in it ; Bitmasking for each String s ; Update the frequency of String with it 's bitmasking value ; Traverse the arr2 [ ] ; Bitmasking for each String s ; Check if temp is present in an unordered_map or not ; Check for next set bit ; Push the count for current String in resultant array ; Print the count for each String ; Driver Code ; Function call [/INST] \n ССРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРР,0.03102203673480034,0.0007152091751828293,0.0025057290919318176,0.00975609756097561,0.1111111111111111
51,"import java . util . * ; class GFG { static void flip ( String s ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == '0' ) { while ( sb . charAt ( i ) == '0' ) { sb . setCharAt ( i , '1' ) ; i ++ ; } break ; } } System . out . println ( sb . toString ( ) ) ; } public static void main ( String [ ] args ) { String s = ""100010001"" ; flip ( s ) ; } }","3-29T04:45:33.730Z

[INST] Write a Java program to complete the following. Maximize the decimal equivalent by flipping only a contiguous set of 0 s | Java implementation to maximize the value of the decimal equivalent given in the binary form ; Function to print the binary number ; Check if the current number is 0 ; Find the continuous 0 s ; Replace initially occurring 0 with 1 ; Break out of loop if 1 occurs ; Driver code [/INST] \n  industries 2022-03-29T04:45:33.730Z

[INST] Write a Java program to complete the following. Maximize the decimal equivalent by flipping only a contiguous set of 0 s | Java implementation to maximize the value of the decimal equivalent given in the binary form ; Function to print the binary number ; Check if the current number is 0 ; Find the continuous 0 s ; Replace initially occurring 0 with 1 ; Break out of loop if 1 occurs ; Driver code [/INST] \n  industries",0.1272659699762553,0.004000808193482298,0.005063071711538942,0.0,0.5
52,"class GFG { static void getOrgString ( String s ) { System . out . print ( s . charAt ( 0 ) ) ; int i = 1 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) System . out . print ( "" ▁ "" + Character . toLowerCase ( s . charAt ( i ) ) ) ; else System . out . print ( s . charAt ( i ) ) ; i ++ ; } } public static void main ( String [ ] args ) { String s = "" ILoveGeeksForGeeks "" ; getOrgString ( s ) ; } }","2-19T09:47:50.000Z

[INST] Write a Java program to complete the following. Sentence Case of a given Camel cased string | Java implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code [/INST] \n achuset 2020-12-19T09:47:50.000Z

[INST] Write a Java program to complete the following. Sentence Case of a given Camel cased string | Java implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code [/INST] \n  /******/ 2",0.13795126683036743,0.001934159998727138,0.002251859703694864,0.0,0.5476190476190477
53,"import java . util . * ; import java . lang . * ; class GFG { static int countChar ( String str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) count ++ ; int repetitions = n / str . length ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = "" abcac "" ; System . out . println ( countChar ( str , ' a ' ) ) ; } }","2018 21:14

```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(""Enter the string : "");
        String str = sc.nextLine();
        System.out.println(""Enter the character : "");
        char ch = sc.next().charAt(0);
        System.out.println(""Enter the number of times the string is repeated : "");
        int n = sc.nextInt();
        System.out.println(""Enter the minimum number of times the character should occur : "");
        int k = sc.nextInt();
        System.out.println(count(str, ch, n, k));
    }

    static int count(String str, char ch, int n, int k) {
        int count = 0;
        int len = str.length();
        if (n % len != 0) {
            count += (n / len) * count(str, ch",0.2254100979801099,0.03623414932845574,0.04608806077380205,0.3875,0.4318181818181818
54,"class GFG { static void countFreq ( int arr [ ] , int n , int limit ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( i + "" ▁ "" + count [ i ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = arr . length ; int limit = 10 ; countFreq ( arr , n , limit ) ; } }",ncy Measuring Techniques for Competitive Programming | Java program to count frequencies of array items having small values . ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through array elements and count frequencies ( assuming that elements are limited by limit ) ; Driver Code [/INST] \n  industries Frequency Measuring Techniques for Competitive Programming | Java program to count frequencies of array items having small values . ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through array elements and count frequencies ( assuming that elements are limited by limit ) ; Driver Code [/INST] \n  industries Frequency Measuring Techniques for Competitive Programming | Java program to count frequencies of array items having small values . ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through array elements and count frequencies ( assuming that elements are limited by limit ) ; Driver Code [/INST] \n  industries Frequency Measuring Techniques for Competitive Programming | Java program to count frequencies of array items having,0.14057447390912742,0.013432805802538793,0.01660702531784184,0.0,0.532258064516129
55,"import java . io . * ; class GFG { static boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } public static void main ( String [ ] args ) { String s = ""001001"" ; int m = 2 ; if ( check ( s , m ) ) System . out . println ( "" YES "" ) ; else System . out . println ( "" NO "" ) ; } }",ююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююю,0.25,0.0,0.0,0.0,0.0
56,"class GFG { static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; } public static void main ( String [ ] args ) { String tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" ; int k = 2 ; System . out . println ( productAtKthLevel ( tree , k ) ) ; } }",te a Java program to complete the following. Product of nodes at k | Java implementation to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program [/INST] \n 2. Write a Java program to complete the following. Product of nodes at k | Java implementation to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program [/INST] \n 3. Write a Java program to complete the following. Product of nodes at k | Java implementation to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program [/INST] \n 4. Write a Java program,0.15972525427449932,0.0032841373336370367,0.004037932395939265,0.0,0.631578947368421
57,"class GFG { static void findDuplciates ( String [ ] a , int n , int m ) { boolean [ ] [ ] isPresent = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { isPresent [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ k ] . charAt ( j ) && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ i ] . charAt ( k ) && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( isPresent [ i ] [ j ] == false ) System . out . print ( a [ i ] . charAt ( j ) ) ; } public static void main ( String [ ] args ) { int n = 2 , m = 2 ; String [ ] a = new String [ ] { "" zx "" , "" xz "" } ; findDuplciates ( a , n , m ) ; } }","# Java program to remove duplicate elements from a matrix

This is a Java program to remove duplicate elements from a matrix. The program takes the input of the matrix and removes the duplicate elements from the matrix. The program also displays the matrix after removing the duplicate elements.

### Java program to remove duplicate elements from a matrix

This is a Java program to remove duplicate elements from a matrix. The program takes the input of the matrix and removes the duplicate elements from the matrix. The program also displays the matrix after removing the duplicate elements.

### Java program to remove duplicate elements from a matrix

This is a Java program to remove duplicate elements from a matrix. The program takes the input of the matrix and removes the duplicate elements from the matrix. The program also displays the matrix after removing the duplicate elements.

### Java program to remove duplicate elements from a matrix

This is a Java program to remove duplicate elements from a matrix. The program takes the input of the matrix and removes the duplicate elements from the matrix. The program also displays the matrix after removing the duplicate elements.

### Java program to remove duplicate elements from a matrix

This is a Java program to remove duplicate elements from a",0.15594906133176412,0.0007694091798237873,0.000804613925010488,0.0,0.6222222222222222
58,"class GFG { static boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } public static void main ( String [ ] args ) { String isbn = ""007462542X "" ; if ( isValidISBN ( isbn ) ) System . out . print ( "" Valid "" ) ; else System . out . print ( "" Invalid "" ) ; } }","package com.company;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(""Enter ISBN: "");
        String isbn = sc.next();
        if (isbn.length() != 10) {
            System.out.println(""Invalid ISBN"");
        } else {
            int sum = 0;
            for (int i = 0; i < 9; i++) {
                sum += (isbn.charAt(i) - '0') * (10 - i);
            }
            int last = isbn.charAt(9) - '0';
            if (last == 'X') {
                last = 10;
            }
            sum += last;
            if (sum % 11 == 0) {
                System.out.println(""Valid ISBN"");
            } else {
                System.out.println(""Invalid ISBN"");
            }
        }
",0.19148498606449987,0.015048101251696849,0.0227788776661229,0.4842105263157895,0.24390243902439024
59,"class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } static String reverseVowel ( String str1 ) { int j = 0 ; char [ ] str = str1 . toCharArray ( ) ; String vowel = "" "" ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { j ++ ; vowel += str [ i ] ; } } for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { str [ i ] = vowel . charAt ( -- j ) ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = "" hello ▁ world "" ; System . out . println ( reverseVowel ( str ) ) ; } }",3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31.32.33.34.35.36.37.38.39.40.41.42.43.44.45.46.47.48.49.50.51.52.53.54.55.56.57.58.59.60.61.62.63.64.65.66.67.68.69.70.71.72.73.74.75.76.77.78.79.80.81.82.83.84.85.86.87.8,0.25,0.0,0.0,0.0,0.0
60,"class GFG { static String firstLetterWord ( String str ) { String result = "" "" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) { v = true ; } else if ( str . charAt ( i ) != ' ▁ ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; } public static void main ( String [ ] args ) { String str = "" geeks ▁ for ▁ geeks "" ; System . out . println ( firstLetterWord ( str ) ) ; } }"," Write a Java program to complete the following. String containing first letter of every word in a given string with spaces | Java program to find the string which contain the first character of each word of another string . ; Function to find string which has first character of each word . ; Traverse the string . ; If it is space , set v as true . ; Else check if v is true or not . If true , copy character in output string and set v as false . ; Driver code [/INST] \n ѝ [INST] Write a Java program to complete the following. String containing first letter of every word in a given string with spaces | Java program to find the string which contain the first character of each word of another string . ; Function to find string which has first character of each word . ; Traverse the string . ; If it is space , set v as true . ; Else check if v is true or not . If true , copy character in output string and set v as false . ; Driver code [/INST] \n ѝ [INST] Write a Java program to complete the following. String containing first letter of every word in a given string with spaces | Java program to find the string which contain the first",0.16092165051951673,0.0017903324306683059,0.0030073807585097923,0.0,0.6388888888888888
61,"import java . util . Arrays ; class GFG { static int ans = 0 ; static void dfs ( int i , int j , int [ ] [ ] grid , boolean [ ] [ ] vis , int z , int z_count ) { int n = grid . length , m = grid [ 0 ] . length ; vis [ i ] [ j ] = true ; if ( grid [ i ] [ j ] == 0 ) z ++ ; if ( grid [ i ] [ j ] == 2 ) { if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = false ; return ; } if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != - 1 ) dfs ( i - 1 , j , grid , vis , z , z_count ) ; if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != - 1 ) dfs ( i + 1 , j , grid , vis , z , z_count ) ; if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != - 1 ) dfs ( i , j - 1 , grid , vis , z , z_count ) ; if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != - 1 ) dfs ( i , j + 1 , grid , vis , z , z_count ) ; vis [ i ] [ j ] = false ; } static int uniquePaths ( int [ ] [ ] grid ) { int n = grid . length , m = grid [ 0 ] . length ; boolean [ ] [ ] vis = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( vis [ i ] , false ) ; } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] [ ] grid = { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , - 1 } } ; System . out . println ( uniquePaths ( grid ) ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25,0.0,0.0,0.0,0.0
62,"import java . util . Arrays ; class GFG { static int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 3 , 6 } ; int n = a . length ; System . out . println ( numPairs ( a , n ) ) ; } }","06-02T09:47:02.000Z

The first step is to find the number of unordered pairs ( x , y ) which satisfy the given equation for the array . Return the number of unordered pairs satisfying the conditions ; ans stores the number of unordered pairs ; Making each value of array to positive ; Sort the array ; For each index calculating the right boundary for the unordered pairs ; Return the final result ; Driver code [/INST]

```

import java.util.*;
import java.lang.*;
import java.io.*;

class GFG {

    public static int count(int arr[], int n)
    {
        // Your code here
        int ans = 0;
        for (int i = 0; i < n; i++)
            arr[i] = -arr[i];
        Arrays.sort(arr);
        for (int i = 0; i < n; i++)
            arr[i] = -arr[i];
        for (int i = 0; i < n; i++)
        {
",0.23110798972970864,0.017413989006388315,0.018661805528884554,0.4383561643835616,0.45
63,class GFG { static int areaOfSquare ( int S ) { int area = S * S ; return area ; } public static void main ( String [ ] args ) { int S = 5 ; System . out . println ( areaOfSquare ( S ) ) ; } }, 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 102 104 106 108 110 112 114 116 118 120 122 124 126 128 130 132 134 136 138 140 142 144 146 148 150 152 154 156 158,0.25,0.0,0.0,0.0,0.0
64,"class GFG { static int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } public static void main ( String [ ] args ) { int x = 3 ; int y = 4 ; System . out . print ( maxPointOfIntersection ( x , y ) ) ; } }",2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 6,0.25,0.0,0.0,0.0,0.0
65,"class GFG { static int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Icosihenagonal_num ( n ) + ""NEW_LINE""); n = 10 ; System . out . print ( Icosihenagonal_num ( n ) + ""NEW_LINE""); } }", ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ,0.039473684210526314,0.0,0.0,0.0,0.15789473684210525
66,"class GFG { static double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; } public static void main ( String [ ] args ) { double vp [ ] [ ] = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; double [ ] ans = find_Centroid ( vp ) ; System . out . println ( ans [ 0 ] + "" ▁ "" + ans [ 1 ] ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2502804448822352,0.00031058817322090836,0.000811191355719863,0.0,0.0
67,"import java . io . * ; class GFG { public static void main ( String [ ] args ) { int d = 10 ; double a ; a = ( double ) ( 360 - ( 6 * d ) ) / 4 ; System . out . print ( a + "" , ▁ "" + ( a + d ) + "" , ▁ "" + ( a + ( 2 * d ) ) + "" , ▁ "" + ( a + ( 3 * d ) ) ) ; } }","скусственный интелект (ИИ) — это отрасль искусственного интеллекта, которая использует компьютерные программы для решения задач, которые обычно решаются человеческим интеллектом. Этот интеллект, как правило, имеет более широкий спектр задач, чем обычный интеллект. \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Интересный факт: \n  Инте",0.010869565217391304,0.0,0.0,0.0,0.043478260869565216
68,"import java . io . * ; import java . lang . Math ; class GFG { static void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( "" Perpendicular ▁ distance ▁ is ▁ "" + d ) ; } else System . out . println ( "" Planes ▁ are ▁ not ▁ parallel "" ) ; } public static void main ( String [ ] args ) { float a1 = 1 ; float b1 = 2 ; float c1 = - 1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = - 3 ; float d2 = - 4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; } }","1-01T00:00:00.000Z.

Java Program to find the Distance between two parallel Planes in 3D. 2. Distance between two parallel Planes in 3D.

The distance between two parallel planes is the shortest distance between them.

Java Program to find the Distance between two parallel Planes in 3D.

The distance between two parallel planes is the shortest distance between them.

Java Program to find the Distance between two parallel Planes in 3D.

The distance between two parallel planes is the shortest distance between them.

Java Program to find the Distance between two parallel Planes in 3D.

The distance between two parallel planes is the shortest distance between them.

Java Program to find the Distance between two parallel Planes in 3D.

The distance between two parallel planes is the shortest distance between them.

Java Program to find the Distance between two parallel Planes in 3D.

The distance between two parallel planes is the shortest distance between them.

Java Program to",0.13929242977787204,0.001071819471825266,0.001072833991536867,0.03389830508474576,0.5211267605633803
69,import java . io . * ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static long numOfNecklace ( int N ) { long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( numOfNecklace ( N ) ) ; } },4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2506019967141221,0.001196725280321588,0.0012112615761667531,0.0,0.0
70,"import java . lang . * ; import java . util . * ; class GFG { static String isDivisibleByDivisor ( int S , int D ) { S %= D ; Set < Integer > hashMap = new HashSet < > ( ) ; hashMap . add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . contains ( S ) ) { if ( S == 0 ) { return "" Yes "" ; } return "" No "" ; } else hashMap . add ( S ) ; } return "" Yes "" ; } public static void main ( String [ ] args ) { int S = 3 , D = 6 ; System . out . println ( isDivisibleByDivisor ( S , D ) ) ; } }",1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0,0.25,0.0,0.0,0.0,0.0
71,"import java . util . * ; class GFG { static void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; System . out . println ( cnt ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25,0.0,0.0,0.0,0.0
72,"import java . util . Stack ; class GFG { static boolean check ( int A [ ] , int N ) { Stack < Integer > S = new Stack < Integer > ( ) ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . peek ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . peek ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . peek ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = A . length ; if ( check ( A , N ) ) { System . out . println ( "" YES "" ) ; } else { System . out . println ( "" NO "" ) ; } } }", algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows: The algorithm is as follows:,0.047619047619047616,0.0,0.0,0.0,0.19047619047619047
73,"import java . util . Stack ; public class GFG { static int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == ' } ' && ! s . empty ( ) ) { if ( s . peek ( ) == ' { ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } public static void main ( String [ ] args ) { String expr = "" } } { { "" ; System . out . println ( countMinReversals ( expr ) ) ; } }", 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88,0.25,0.0,0.0,0.0,0.0
74,"import java . util . * ; public class GFG { static int countMinReversals ( String expr ) { int len = expr . length ( ) ; int ans ; if ( len % 2 != 0 ) { return - 1 ; } int left_brace = 0 , right_brace = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = expr . charAt ( i ) ; if ( ch == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ( int ) ( Math . ceil ( ( 0.0 + left_brace ) / 2 ) + Math . ceil ( ( 0.0 + right_brace ) / 2 ) ) ; return ans ; } public static void main ( String [ ] args ) { String expr = "" } } { { "" ; System . out . println ( countMinReversals ( expr ) ) ; } }",789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899101011101210131014101510161017101810191020102110221023102410251026,0.25,0.0,0.0,0.0,0.0
75,"class GFG { static void PrintMinNumberForPattern ( String arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case ' I ' : j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; System . out . print ( "" ▁ "" + ++ last_entry ) ; System . out . print ( "" ▁ "" + curr_max ) ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; System . out . print ( "" ▁ "" + last_entry ) ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( "" ▁ "" + -- last_entry ) ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; System . out . print ( "" ▁ "" + curr_max + "" ▁ "" + ( curr_max - 1 ) ) ; last_entry = curr_max - 1 ; } else { System . out . print ( "" ▁ "" + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } System . out . println ( ) ; } public static void main ( String [ ] args ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25,0.0,0.0,0.0,0.0
76,"import java . io . * ; import java . util . * ; public class GFG { static void printLeast ( String arr ) { int min_avail = 1 , pos_of_I = 0 ; ArrayList < Integer > al = new ArrayList < > ( ) ; if ( arr . charAt ( 0 ) == ' I ' ) { al . add ( 1 ) ; al . add ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { al . add ( 2 ) ; al . add ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr . charAt ( i ) == ' I ' ) { al . add ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { al . add ( al . get ( i ) ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) al . set ( j , al . get ( j ) + 1 ) ; min_avail ++ ; } } for ( int i = 0 ; i < al . size ( ) ; i ++ ) System . out . print ( al . get ( i ) + "" ▁ "" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { printLeast ( "" IDID "" ) ; printLeast ( "" I "" ) ; printLeast ( "" DD "" ) ; printLeast ( "" II "" ) ; printLeast ( "" DIDI "" ) ; printLeast ( "" IIDDD "" ) ; printLeast ( "" DDIDDIID "" ) ; } }",ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь,0.006329113924050633,0.0,0.0,0.0,0.02531645569620253
77,"import java . util . Stack ; class GFG { static void PrintMinNumberForPattern ( String seq ) { String result = "" "" ; Stack < Integer > stk = new Stack < Integer > ( ) ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) { while ( ! stk . empty ( ) ) { result += String . valueOf ( stk . peek ( ) ) ; result += "" ▁ "" ; stk . pop ( ) ; } } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; } }",111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,0.25,0.0,0.0,0.0,0.0
78,"import java . io . IOException ; public class Test { static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return "" - 1"" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; } public static void main ( String [ ] args ) throws IOException { String inputs [ ] = { "" IDID "" , "" I "" , "" DD "" , "" II "" , "" DIDI "" , "" IIDDD "" , "" DDIDDIID "" } ; for ( String input : inputs ) { System . out . println ( getMinNumberForPattern ( input ) ) ; } } }","pLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new JLabel( "" "")); GroupLayout.addComponent(new",0.03789658765708041,0.0006438947765138291,0.0013966836645261976,0.07547169811320754,0.07407407407407407
79,"import java . io . * ; class SmallPrime { static boolean isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) { return true ; } else { return false ; } } static void findMinNum ( int arr [ ] , int n ) { int first = 0 , last = 0 , num , rev , i ; int hash [ ] = new int [ 10 ] ; for ( i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } System . out . print ( "" Minimum ▁ number : ▁ "" ) ; for ( i = 0 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } System . out . println ( ) ; System . out . println ( ) ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } } for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ; System . out . print ( "" Prime ▁ combinations : ▁ "" ) ; if ( isPrime ( num ) && isPrime ( rev ) ) { System . out . println ( num + "" ▁ "" + rev ) ; } else if ( isPrime ( num ) ) { System . out . println ( num ) ; } else if ( isPrime ( rev ) ) { System . out . println ( rev ) ; } else { System . out . println ( "" No ▁ combinations ▁ exist "" ) ; } } public static void main ( String [ ] args ) { SmallPrime smallprime = new SmallPrime ( ) ; int arr [ ] = { 1 , 2 , 4 , 7 , 8 } ; smallprime . findMinNum ( arr , 5 ) ; } }","ite a Java program to find the smallest number that has the same number of 0s, 1s, and 2s as a given number. [INST] Write a Java program to find the smallest number that has the same number of 0s, 1s, and 2s as a given number. [/INST] \n 12. Write a Java program to find the smallest number that has the same number of 0s, 1s, and 2s as a given number. [INST] Write a Java program to find the smallest number that has the same number of 0s, 1s, and 2s as a given number. [/INST] \n 13. Write a Java program to find the smallest number that has the same number of 0s, 1s, and 2s as a given number. [INST] Write a Java program to find the smallest number that has the same number of 0s, 1s, and 2s as a given number. [/INST] \n 14. Write a Java program to find the smallest number that has the same number of 0s, 1",0.05235122865895903,0.00025829639994890546,0.00045130482282089164,0.02072538860103627,0.18796992481203006
80,"class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static boolean coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; } static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) { if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } } if ( flag == true ) { System . out . println ( "" ( "" + possibleA + "" , ▁ "" + possibleB + "" , ▁ "" + possibleC + "" ) "" + "" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ "" + "" between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } else { System . out . println ( "" No ▁ Such ▁ Triplet ▁ exists "" + "" between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }",46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2 10 10 2 23 46 46 23 2,0.25022160195350257,0.00019241722416574398,0.0006939905898445533,0.0,0.0
81,"class GFG { static boolean possibleToReach ( int a , int b ) { int c = ( int ) Math . cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) System . out . println ( "" yes "" ) ; else System . out . println ( "" no "" ) ; } }",этэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэтэ,0.25,0.0,0.0,0.0,0.0
82,"import java . util . * ; class GFG { public static boolean isUndulating ( String n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) return false ; return true ; } public static void main ( String [ ] args ) { String n = ""1212121"" ; if ( isUndulating ( n ) == true ) System . out . println ( "" yes "" ) ; else System . out . println ( "" no "" ) ; } }", ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ,0.025,0.0,0.0,0.0,0.1
83,import java . io . * ; class GFG { static int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } public static void main ( String [ ] args ) { int n = 3 ; int res = Series ( n ) ; System . out . println ( res ) ; } }, + 2 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + ... + ( n * n ) \n 2 + 4 + 6 + 8 + 10 + ... + ( 2 * n ) \n 1 + 2 + 3 + 4 + 5 + ... + n \n 1 + 2 + 3 + 4 + 5 + ... + n \n 1 + 3 + 5 + 7 + 9 + ... + ( 2 * n - 1 ) \n 1 + 2 + 3 + 4 + 5 + ... + n \n 1 + 3 + 5 + 7 + 9 + ... + ( 2 * n - 1 ) \n 1 + 4 + 9 + 16 + 25 + ... + ( n * n ) \n 1 + 2 + 3 + 4 + 5 + ... + n \n 1 + 3 + 5 + 7 + 9 + ... + ( 2 * n - 1 ) \n,0.045824250125758775,0.005014983457745042,0.009189071916510671,0.06382978723404255,0.10526315789473684
84,"import java . util . * ; import java . lang . * ; public class GfG { public static int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * ( int ) Math . ceil ( low / 10.0 ) ; int mhigh = 10 * ( int ) Math . floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; } public static void main ( String argc [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
85,"import java . io . * ; class GFG { static int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } public static void main ( String [ ] args ) { int L = 1 , R = 20 ; System . out . println ( sum ( L , R ) ) ; } }",111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,0.25,0.0,0.0,0.0,0.0
86,"class GFG { static String prevNum ( String str ) { int len = str . length ( ) ; int index = - 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) > str . charAt ( i + 1 ) ) { index = i ; break ; } } int smallGreatDgt = - 1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str . charAt ( i ) < str . charAt ( index ) ) { if ( smallGreatDgt == - 1 ) { smallGreatDgt = i ; } else if ( str . charAt ( i ) >= str . charAt ( smallGreatDgt ) ) { smallGreatDgt = i ; } } } if ( index == - 1 ) { return "" - 1"" ; } if ( smallGreatDgt != - 1 ) { str = swap ( str , index , smallGreatDgt ) ; return str ; } return "" - 1"" ; } static String swap ( String str , int i , int j ) { char ch [ ] = str . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; } public static void main ( String [ ] args ) { String str = ""34125"" ; System . out . println ( prevNum ( str ) ) ; } }",3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66. ,0.25,0.0,0.0,0.0,0.0
87,"class GFG { static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; } static int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; } public static void main ( String [ ] args ) { int poly [ ] = { 2 , - 6 , 2 , - 1 } ; int x = 3 ; int n = poly . length ; System . out . print ( "" Sign ▁ of ▁ polynomial ▁ is ▁ "" + findSign ( poly , n , x ) ) ; } }",2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1,0.2506902198829641,0.0014204528959779182,0.001340426635878418,0.0,0.0
88,"class GFG { static int MAX = 100005 ; static boolean [ ] isPrime = new boolean [ MAX ] ; static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
89,"class GFG { public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( "" Sum ▁ of ▁ SubArray ▁ : ▁ "" + SubArraySum ( arr , n ) ) ; } }",te a Java program to compute sum of subarray elements. Write a Java program to compute sum of subarray elements. The program should accept the size of array and the indexes of two subarrays as input from the user. The program should then compute the sum of the subarray elements and display the result. The program should compute the sum of all subarrays. \n 2. Write a Java program to compute sum of subarray elements. Write a Java program to compute sum of subarray elements. The program should accept the size of array and the indexes of two subarrays as input from the user. The program should then compute the sum of the subarray elements and display the result. The program should compute the sum of all subarrays. \n 3. Write a Java program to compute sum of subarray elements. Write a Java program to compute sum of subarray elements. The program should accept the size of array and the indexes of two subarrays as input from the user. The program should then compute the sum of the subarray elements and display the result. The program should compute the sum of all subarrays. \n 4. Write a Java program to compute sum of subarray,0.16963792567942837,0.0008781760566465005,0.0012029384257728661,0.0,0.6764705882352942
90,"import java . io . * ; class GFG { static int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }",3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66. ,0.25,0.0,0.0,0.0,0.0
91,"import java . io . * ; import java . util . * ; class KeyComparator implements Comparator < Key > { public int compare ( Key k1 , Key k2 ) { if ( k1 . freq < k2 . freq ) return 1 ; else if ( k1 . freq > k2 . freq ) return - 1 ; return 0 ; } } class Key { int freq ; char ch ; Key ( int val , char c ) { freq = val ; ch = c ; } } class GFG { static int MAX_CHAR = 26 ; static void rearrangeString ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ; PriorityQueue < Key > pq = new PriorityQueue < > ( new KeyComparator ( ) ) ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] > 0 ) pq . add ( new Key ( count [ val ] , c ) ) ; } str = "" "" ; Key prev = new Key ( - 1 , ' # ' ) ; while ( pq . size ( ) != 0 ) { Key k = pq . peek ( ) ; pq . poll ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . add ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) System . out . println ( "" ▁ Not ▁ valid ▁ String ▁ "" ) ; else System . out . println ( str ) ; } public static void main ( String args [ ] ) { String str = "" bbbaa "" ; rearrangeString ( str ) ; } }","1-27T16:04:47.000Z

[INST] Write a Java program to complete the following. Rearrange characters in a string such that no two adjacent are same | Java program to rearrange characters in a string so that no two adjacent characters are same . ; Overriding compare ( ) method of Comparator ; store frequency of character ; Function to rearrange character of a string so that no char repeat twice ; Store frequencies of all characters in string ; Insert all characters with their frequencies into a priority_queue ; ' str ' that will store resultant value ; work as the previous visited element initial previous element be . ( ' # ' and it ' s   frequency   ' - 1 ' ) ; traverse queue ; pop top element from queue and add it to string . ; If frequency of previous character is less than zero that means it is useless , we need not to push it ; make current character as the previous ' char ' decrease frequency by ' one ' ; If length of the resultant string and original string is not same then string is not valid ; valid string ; Driver program to test above function [/INST] \n  Industri",0.10293248427741639,0.00628621133334427,0.007446014105840769,0.10326086956521739,0.29473684210526313
92,"public class GFG { static int aModM ( String s , int mod ) { int number = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { number = ( number * 10 ) ; int x = Character . getNumericValue ( s . charAt ( i ) ) ; number = number + x ; number %= mod ; } return number ; } static int ApowBmodM ( String a , int b , int m ) { int ans = aModM ( a , m ) ; int mul = ans ; for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; } public static void main ( String args [ ] ) { String a = ""987584345091051645734583954832576"" ; int b = 3 , m = 11 ; System . out . println ( ApowBmodM ( a , b , m ) ) ; } }","й код в Java: \n \n public static long find(long a, long b, long m) {\n long ans = 1;\n while(b > 0) {\n if(b % 2 == 1) {\n ans = (ans * a) % m;\n } \n b = b / 2;\n a = (a * a) % m;\n } \n return ans;\n } \n \n public static long find(long a, long b, long m) {\n long ans = 1;\n while(b > 0) {\n if(b % 2 == 1) {\n ans = (ans * a) % m;\n } \n b = b / 2;\n a = (a * a) % m;\n } \n return ans;\n } \n \n public static void main(String[] args) {\n long a = 123456789012345678901234567890123456789012345678901",0.1953568583895453,0.011314217931738431,0.012970358483585657,0.4,0.35714285714285715
93,"import java . util . * ; class GFG { static class Data { int x , y ; public Data ( int x , int y ) { super ( ) ; this . x = x ; this . y = y ; } } ; static double interpolate ( Data f [ ] , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } public static void main ( String [ ] args ) { Data f [ ] = { new Data ( 0 , 2 ) , new Data ( 1 , 3 ) , new Data ( 2 , 12 ) , new Data ( 5 , 147 ) } ; System . out . print ( "" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ "" + ( int ) interpolate ( f , 3 , 4 ) ) ; } }",3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66. ,0.25,0.0,0.0,0.0,0.0
94,"import java . util . Arrays ; class GFG { static int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; boolean marked [ ] = new boolean [ nNew + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + "" ▁ "" ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + "" ▁ "" ) ; return - 1 ; } public static void main ( String [ ] args ) { int n = 20 ; SieveOfSundaram ( n ) ; } }",5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89,0.25036640422317236,0.0006120144767731899,0.0008536024159162019,0.0,0.0
95,"class GFG { static void constructArray ( int A [ ] , int N , int K ) { int B [ ] = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = A . length ; constructArray ( A , N , K ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2507524673681169,0.0014524057321316235,0.0015574637403359876,0.0,0.0
96,"class GFG { static int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = A . length ; System . out . println ( extraElement ( A , B , n ) ) ; } }","Java Program to Find Extra Element in an Array

We can use the XOR operator to find the extra element in an array. The XOR operator (^) is used to find the extra element in an array.

### Java Program to Find Extra Element in an Array

```
import java.util.*;
public class Main
{
    public static void main(String[] args)
    {
        int[] arr = {1, 2, 3, 4, 5};
        int[] arr1 = {1, 2, 3, 4, 5, 6};
        int xor = 0;
        for(int i=0; i<arr.length; i++)
        {
            xor = xor ^ arr[i];
        }
        for(int i=0; i<arr1.length; i++)
        {
            xor = xor ^ arr1[i];
        }
        System.out.println(""Extra element is "" + xor);
    }
}
```

### Output

Extra element is 6

",0.24244556056060543,0.011195759355001663,0.012199536500473594,0.48484848484848486,0.46153846153846156
97,"class GFG { static int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } public static void main ( String [ ] args ) { int n1 = 9 , n2 = 14 ; System . out . println ( hammingDistance ( n1 , n2 ) ) ; } }", Write a Java program to complete the following. Hamming distance between two Integers | Java implementation of above approach ; Function to calculate hamming distance ; Driver code [/INST] \n íses [INST] Write a Java program to complete the following. Hamming distance between two Integers | Java implementation of above approach ; Function to calculate hamming distance ; Driver code [/INST] \n íses [INST] Write a Java program to complete the following. Hamming distance between two Integers | Java implementation of above approach ; Function to calculate hamming distance ; Driver code [/INST] \n íses [INST] Write a Java program to complete the following. Hamming distance between two Integers | Java implementation of above approach ; Function to calculate hamming distance ; Driver code [/INST] \n íses [INST] Write a Java program to complete the following. Hamming distance between two Integers | Java implementation of above approach ; Function to calculate hamming distance ; Driver code [/INST] \n íses [INST] Write a Java program to complete the following. Hamming distance between two Integers | Java implementation of above approach ; Function to calculate hamming distance ; Driver code,0.13752849439856674,0.0015509702872921677,0.003108461852429382,0.0,0.5454545454545454
98,"class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) System . out . print ( i + "" ▁ "" ) ; } public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }", ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ,0.058823529411764705,0.0,0.0,0.0,0.23529411764705882
99,class GFG { static int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return 1 << k ; } public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } },"07-17T05:08:56.000Z

This is the most significant bit of a number. The most significant bit of a number is the rightmost bit that is set to 1. For example, the most significant bit of 10 is 1, the most significant bit of 11 is 1, the most significant bit of 100 is 1, the most significant bit of 110 is 1, the most significant bit of 1000 is 1, the most significant bit of 1100 is 1, the most significant bit of 10000 is 1, and so on.

The most significant bit of a number is the rightmost bit that is set to 1. For example, the most significant bit of 10 is 1, the most significant bit of 11 is 1, the most significant bit of 100 is 1, the most significant bit of 110 is 1, the most significant bit of 1000 is 1, the most significant bit of 1100 is",0.21428571428571427,0.0,0.0,0.0,0.8571428571428571
100,"import java . util . * ; import java . lang . * ; public class GfG { public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
101,"import java . util . HashMap ; import java . util . Map ; class GFG { static int subset ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( subset ( arr , n ) ) ; } }",1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1,0.25050676779930736,0.0010019048906267382,0.0010251663066027147,0.0,0.0
102,"import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static ArrayList < Integer > psquare = new ArrayList < > ( ) ; static void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . add ( i * i ) ; } static int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - psquare . get ( index ) ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; } public static void main ( String [ ] args ) { int N = 9 ; calcPsquare ( N ) ; System . out . print ( countWays ( psquare . size ( ) - 1 , N ) ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
103,"import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static class TreeNode { int data , size ; TreeNode left ; TreeNode right ; } ; static TreeNode newNode ( int data ) { TreeNode Node = new TreeNode ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static pair sumofsubtree ( TreeNode root ) { pair p = new pair ( 1 , 0 ) ; if ( root . left != null ) { pair ptemp = sumofsubtree ( root . left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root . right != null ) { pair ptemp = sumofsubtree ( root . right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root . size = p . first ; return p ; } static int sum = 0 ; static void distance ( TreeNode root , int target , int distancesum , int n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { int tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { int tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } } public static void main ( String [ ] args ) { TreeNode root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 7 ) ; root . left . left . left = newNode ( 8 ) ; root . left . left . right = newNode ( 9 ) ; int target = 3 ; pair p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; System . out . print ( sum + ""NEW_LINE""); } }",7099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:12:00 1209287099232019 18:1,0.25,0.0,0.0,0.0,0.0
104,"import java . util . * ; class GFG { static int [ ] reverse ( int a [ ] ) { int i , n = a . length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } static void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { Arrays . sort ( B ) ; B = reverse ( B ) ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { System . out . print ( "" - 1"" + ""NEW_LINE""); } else { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + "" ▁ "" ) ; } } } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = A . length ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; } }", Write a Java program to complete the following. Rearrange array such that sum of same indexed elements is atmost K | Java program for the above approach ; Reverse array ; Function to rearrange array such that sum of similar indexed elements does not exceed K ; Sort the array B [ ] in descending order ; If condition fails ; Print the array ; Driver Code ; Given arrays [/INST] \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \n  industries \,0.06281480266402634,0.003592464205078906,0.004406942529457777,0.0661764705882353,0.17708333333333334
105,"import java . io . * ; class GFG { static void countRows ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < m ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 2 , - 1 , 5 } , { - 3 , 0 , - 2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; } }","]

```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] matrix = new int[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix[i][j] = sc.nextInt();
            }
        }
        int sum = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                sum += matrix[i][j];
            }
        }
        System.out.println(sum);
        int count = 0;
        for (int i = 0; i < 3; i++) {
            int sumRow = 0;
            for (int j = 0; j < 3; j++) {
                sumRow += matrix[i][j];",0.22953501225357792,0.013101520331450548,0.01837186201619455,0.57,0.31666666666666665
106,"import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","s is the same as the previous problem. The only difference is that we are asked to find the number of such subarrays.

The idea is to use the same approach as in the previous problem. We will use a map to store the number of occurrences of each element. We will use a variable to keep track of the number of consecutive elements that have been seen so far.

The idea is to use a map to store the number of occurrences of each element. We will use a variable to keep track of the number of consecutive elements that have been seen so far.

We will start with an empty map and an empty set of consecutive elements. For each element in the array, we will check if the element is in the map. If it is, we will increase the number of consecutive elements by one. If it is not in the map, we will add the element to the map with a value of 1.

We will then check if the number of consecutive elements is greater than or equal to 3. If it is, we will add 1 to the count of valid subarrays. We will then remove the element from the map and decrease the number of consecutive elements by",0.15257859460089476,0.0010910858328010674,0.0020804354279209225,0.0,0.6071428571428571
107,"import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }", 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88,0.2503326431292654,0.00044727504345912054,0.0008832974736023934,0.0,0.0
108,"import java . io . * ; import java . util . * ; class GFG { static Boolean areElementsContiguous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ( ) ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","] Write a Java program to complete the following. Check if array contains contiguous integers with duplicates allowed | Java implementation to check whether the array contains a set of contiguous integers ; Function to check whether the array contains a set of contiguous integers ; Storing elements of ' arr [ ] ' in a hash table ' us ' ; As arr [ 0 ] is present in ' us ' ; Starting with previous smaller element of arr [ 0 ] ; If ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; Starting with next greater element of arr [ 0 ] ; If ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; Returns true if array contains a set of contiguous integers else returns false ; Driver Code [/INST] \n  industriousness [INST] Write a Java program to complete the following. Check if array contains contiguous integers with duplicates allowed | Java implementation to check whether the array contains a set of contiguous integers ; Function to check whether the array contains a set of contiguous integers ; Storing elements of '",0.07340515750943859,0.0359645373515014,0.03472161975178003,0.019230769230769232,0.2037037037037037
109,"import java . util . * ; class GFG { static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . length ; int k = 3 ; longest ( a , n , k ) ; } }", 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88,0.25035621028020855,0.0004694514199868889,0.0009553897008473649,0.0,0.0
110,"import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Stack ; class GFG { static class Pair { int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } } static boolean kOverlap ( ArrayList < Pair > pairs , int k ) { ArrayList < Pair > vec = new ArrayList < > ( ) ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) { vec . add ( new Pair ( pairs . get ( i ) . first , - 1 ) ) ; vec . add ( new Pair ( pairs . get ( i ) . second , + 1 ) ) ; } Collections . sort ( vec , new Comparator < Pair > ( ) { public int compare ( Pair a , Pair b ) { if ( a . first != b . first ) return a . first - b . first ; return ( a . second - b . second ) ; } } ) ; Stack < Pair > st = new Stack < > ( ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { Pair cur = vec . get ( i ) ; if ( cur . second == - 1 ) { st . push ( cur ) ; } else { st . pop ( ) ; } if ( st . size ( ) >= k ) { return true ; } } return false ; } public static void main ( String [ ] args ) { ArrayList < Pair > pairs = new ArrayList < > ( ) ; pairs . add ( new Pair ( 1 , 3 ) ) ; pairs . add ( new Pair ( 2 , 4 ) ) ; pairs . add ( new Pair ( 3 , 5 ) ) ; pairs . add ( new Pair ( 7 , 10 ) ) ; int n = pairs . size ( ) , k = 3 ; if ( kOverlap ( pairs , k ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }",4 19 05:01:27 UTC \n 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 ,0.2500985041403381,9.3890218982305e-06,0.00038462753945410754,0.0,0.0
111,"class GFG { static final int N = 5 ; static int ptr [ ] = new int [ 501 ] ; static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) { minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( ""The smallest range is [%d, %d]NEW_LINE"", minel, maxel); } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = arr . length ; findSmallestRange ( arr , N , k ) ; } }",09-20T08:05:49.000Z \n \n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 ,0.2502658517163868,0.00014584125912830948,0.0009175656064189056,0.0,0.0
112,"import java . io . * ; import java . util . Arrays ; class GFG { static int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; } public static void main ( String [ ] args ) { int [ ] S = new int [ ] { 2 , 3 , 5 , 7 , 12 } ; int n = S . length ; int ans = findLargestd ( S , n ) ; if ( ans == Integer . MAX_VALUE ) System . out . println ( "" No ▁ Solution "" ) ; else System . out . println ( "" Largest ▁ d ▁ such ▁ that ▁ "" + "" a ▁ + ▁ "" + "" b ▁ + ▁ c ▁ = ▁ d ▁ is ▁ "" + ans ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2502319710647648,0.00022080751788133355,0.0007070767411779265,0.0,0.0
113,"import java . util . HashMap ; import java . lang . Math ; class Indexes { int i , j ; Indexes ( int i , int j ) { this . i = i ; this . j = j ; } int getI ( ) { return i ; } int getJ ( ) { return j ; } } class GFG { static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = arr . length ; int res = findFourElements ( arr , n ) ; if ( res == Integer . MIN_VALUE ) System . out . println ( "" No ▁ Solution "" ) ; else System . out . println ( res ) ; } }",3-10T10:59:56.650Z \n 3.0.0.0 \n 2020-03-10T10:59:56.650Z \n 2020-03-10T10:59:56.650Z \n 2020-03-10T10:59:56.650Z \n 2020-03-10T10:59:56.650Z \n 2020-03-10T10:59:56.650Z \n 2020-03-10T10:59:56.650Z \n 2020-03-10T10:59:56.650Z \n 2020-03-10T10:59:56.650Z \n 20,0.01991150442477876,0.0,0.0,0.0,0.07964601769911504
114,"import java . util . Arrays ; public class GFG { static int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; System . out . println ( CountMaximum ( arr , n , k ) ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25083739780931946,0.0016726309029671327,0.0016769603343106793,0.0,0.0
115,"class RotateArray { void leftRotatebyOne ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String [ ] args ) { RotateArray rotate = new RotateArray ( ) ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; rotate . leftRotate ( arr , 2 , 7 ) ; rotate . printArray ( arr , 7 ) ; } }","5-09 12:00:00

#include <stdio.h>

void rotate(int arr[], int d, int n)

{

    int i, j, temp;

    for (i = 0; i < d; i++)

    {

        temp = arr[n - 1];

        for (j = n - 1; j > 0; j--)

        {

            arr[j] = arr[j - 1];

        }

        arr[0] = temp;

    }

}

void printArray(int arr[], int n)

{

    int i;

    for (i = 0; i < n; i++)

        printf(""%d "", arr[i]);

}

int main()

{

    int arr[] = { 1, 2, 3, 4, 5, 6, 7 };

    int n = sizeof(arr) / sizeof(arr[0]);

",0.22126535326691782,0.004494452319274205,0.00760982229634645,0.5106382978723404,0.36231884057971014
116,"import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + "" ▁ "" ) ; } } public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }","4-22T18:40:57.000Z

1

[INST] Write a Java program to complete the following. Sort the array in a given index range | Java program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Temporary array ; Sort the temporary array ; Modifying original array with temporary array elements ; Print the modified array ; Driver code ; length of the array [/INST]

```
import java.util.*;
class Sorting {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        int start = 1;
        int end = 5;
        int[] temp = new int[end - start + 1];
        for (int i = start; i <= end; i++) {
            temp[i - start] = arr[i];
        }
        Arr",0.21057742301789278,0.011220741933782578,0.013818098384178197,0.5299145299145299,0.28735632183908044
117,"import java . util . * ; class GFG { static int MAX_SIZE = 10 ; static void sortByRow ( int [ ] [ ] mat , int n , boolean descending ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) { int t = i ; for ( int p = 0 ; p < n ; p ++ ) { for ( int j = p + 1 ; j < n ; j ++ ) { if ( mat [ t ] [ p ] < mat [ t ] [ j ] ) { temp = mat [ t ] [ p ] ; mat [ t ] [ p ] = mat [ t ] [ j ] ; mat [ t ] [ j ] = temp ; } } } } else Arrays . sort ( mat [ i ] ) ; } } static void transpose ( int mat [ ] [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } } static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + "" ▁ "" ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 3 ; int [ ] [ ] mat = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . println ( "" Original ▁ Matrix : "" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . println ( "" "" ▁ + ▁ "" Matrix After Sorting : ""); printMat ( mat , n ) ; } }",ммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм,0.25,0.0,0.0,0.0,0.0
118,"import java . io . * ; class PushZero { static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; pushZerosToEnd ( arr , n ) ; System . out . println ( "" Array ▁ after ▁ pushing ▁ zeros ▁ to ▁ the ▁ back : ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
119,"import java . io . * ; class GFG { static void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; System . out . print ( "" Original ▁ array : ▁ "" ) ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; System . out . print ( "" Modified array : ""); printArray ( arr , n ) ; } }","8-15T03:19:11.000Z

[INST] Write a Java program to complete the following. Move all zeroes to end of array | Set | Java implementation to move all zeroes at the end of array ; function to move all zeroes at the end of array ; Count of non - zero elements ; Traverse the array . If arr [ i ] is non - zero , then swap the element at index ' count ' with the element at index ' i ' ; function to print the array elements ; Driver program to test above [/INST] \n  Industrially 2017-08-15T03:19:11.000Z

[INST] Write a Java program to complete the following. Move all zeroes to end of array | Set | Java implementation to move all zeroes at the end of array ; function to move all zeroes at the end of array ; Count of non - zero elements ; Traverse the array . If arr [ i ] is non - zero , then swap the element at index ' count ' with the element at index ' i ' ; function to print the",0.11966016287013995,0.025330008592167972,0.024159850212958616,0.08737864077669903,0.34177215189873417
120,"class GFG { static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } static void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = arr . length ; System . out . print ( "" Original ▁ array : ▁ "" ) ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; System . out . print ( "" Modified ▁ array : ▁ "" ) ; printArray ( arr , n ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
121,"class GFG { public static void swap ( int [ ] A , int i , int j ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } static void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( int index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array , array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } } }", 2 3 4 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ,0.25095451187733997,0.0019105671851975584,0.0019074803241623578,0.0,0.0
122,"import java . io . * ; class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; System . out . println ( ) ; } static void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int n = arr . length ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; } }","енно реализуется метод сортировки.

## Java program to Rearrange positive and negative numbers in a array

Объяснение.

Сортировка по модулю.

Вот такой вариант.

```
public class Main {
    public static void main(String[] args) {
        int[] arr = {-1, 2, -3, 4, 5, 6, -7, 8, 9};
        rearrange(arr);
        System.out.println(Arrays.toString(arr));
    }

    static void rearrange(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            if (arr[i] < 0) {
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
    }
}
```

## Java program to",0.16356380251400154,0.009182495713307889,0.016591753069661035,0.5045871559633027,0.12389380530973451
123,"class GFG { static void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( A [ i ] + "" ▁ "" ) ; System . out . println ( "" "" ) ; ; } static void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } } static void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } static void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_size = arr . length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; } }",9.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:59:26 2012.09.12 12:5,0.25,0.0,0.0,0.0,0.0
124,"import java . io . * ; class GFG { public static void RearrangePosNeg ( int arr [ ] ) { int i = 0 ; int j = arr . length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; RearrangePosNeg ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
125,"class GFG { static void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { System . out . print ( "" A "" ) ; } else { System . out . print ( "" B "" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 24 , 45 , 45 , 24 } ; int N = arr . length ; winner ( arr , N ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2510851761421568,0.00227837831338355,0.0020623262552437196,0.0,0.0
126,"import java . util . * ; class GFG { static int sz = 20 ; static int sqr = ( int ) ( Math . sqrt ( sz ) ) + 1 ; static void precomputeExpressionForAllVal ( int arr [ ] , int N , int dp [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= Math . sqrt ( N ) ; j ++ ) { if ( i + j < N ) { dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] ; } else { dp [ i ] [ j ] = arr [ i ] ; } } } } static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { int [ ] [ ] dp = new int [ sz ] [ sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; if ( y <= Math . sqrt ( N ) ) { System . out . print ( dp [ x ] [ y ] + "" ▁ "" ) ; continue ; } int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } System . out . print ( sum + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }","ST] Write a Java program to complete the following. Queries to calculate sum of array elements present at every Yth index starting from the index X | Java program for the above approach ; Function to sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all possible values of X and Y , where Y is less than or equal to Math . sqrt ( N ) . ; Iterate over all possible values of X ; Precompute for all possible values of an expression such that y <= Math . sqrt ( N ) ; If i + j less than N ; Update dp [ i ] [ j ] ; Update dp [ i ] [ j ] ; Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries ; dp [ x ] [ y ] : Stores sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... ; Traverse the query array , Q [ ] [ ] ; If y is less than or equal to Math . sqrt ( N ) ; Stores the sum of arr [ x ]",0.18388409182517934,0.1165798022020377,0.12312232300489556,0.18285714285714286,0.31297709923664124
127,"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2506271284520187,0.0012070384605504785,0.0013014753475242963,0.0,0.0
128,"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25086674771321577,0.0017796293286861124,0.0016873615241769012,0.0,0.0
129,"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }"," элементов, больших, чем текущий элемент. \n 2. \n 3. \n 4. \n 5. \n 6. \n 7. \n 8. \n 9. \n 10. \n 11. \n 12. \n 13. \n 14. \n 15. \n 16. \n 17. \n 18. \n 19. \n 20. \n 21. \n 22. \n 23. \n 24. \n 25. \n 26. \n 27. \n 28. \n 29. \n 30. \n 31. \n 32. \n 33. \n 34. \n 35. \n 36. \n 37. \n 38. \n 39. \n 40. \n 41. \n ",0.04838709677419355,0.0,0.0,0.0,0.1935483870967742
130,"import java . io . * ; import java . util . * ; class GFG { public static int getMinOps ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 1 , 2 } ; System . out . println ( getMinOps ( arr ) ) ; } }","Java program to find minimum number of operations to make an array non-increasing

Java program to find minimum number of operations to make an array non-increasing. In this article we will discuss how to find the minimum number of operations required to make an array non-increasing.

The given array is [5, 4, 3, 2, 1] and the required output is 2. The array [5, 4, 3, 2, 1] is not non-increasing. So, we need to perform 2 operations to make the array non-increasing.

## Java program to find minimum number of operations to make an array non-increasing

In this article we will discuss how to find the minimum number of operations required to make an array non-increasing. The given array is [5, 4, 3, 2, 1] and the required output is 2. The array [5, 4, 3, 2, 1] is not non-increasing. So, we need to perform 2 operations to make the array non-incre",0.17563054347238644,0.0011661161987873354,0.001356057690758445,0.0,0.7
131,"class SmallestMissing { int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } public static void main ( String [ ] args ) { SmallestMissing small = new SmallestMissing ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . length ; System . out . println ( "" First ▁ Missing ▁ element ▁ is ▁ : ▁ "" + small . findFirstMissing ( arr , 0 , n - 1 ) ) ; } }",; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65;,0.25037977598913264,0.0005568535375801852,0.0009622504189502909,0.0,0.0
132,"import java . io . * ; class GFG { int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } int findSmallestMissinginSortedArray ( int [ ] arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; } public static void main ( String [ ] args ) { GFG small = new GFG ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ; System . out . println ( "" First ▁ Missing ▁ element ▁ is ▁ : ▁ "" + small . findSmallestMissinginSortedArray ( arr ) ) ; } }",иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии,0.25,0.0,0.0,0.0,0.0
133,"class MaximumSum { int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void main ( String [ ] args ) { MaximumSum sum = new MaximumSum ( ) ; int arr [ ] = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; System . out . println ( sum . FindMaxSum ( arr , arr . length ) ) ; } }",ммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм,0.25,0.0,0.0,0.0,0.0
134,"import java . util . * ; class GFG { static final int N = 7 ; static int countChanges ( int matrix [ ] [ ] , int n , int m ) { int dist = n + m - 1 ; int [ ] [ ] freq = new int [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 } , { 3 , 5 } } ; System . out . print ( countChanges ( mat , 2 , 2 ) ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25021534520835437,0.00018292131141148577,0.0006784595220059496,0.0,0.0
135,"import java . io . * ; class GFG { static int MAX = 500 ; static int [ ] [ ] lookup = new int [ MAX ] [ MAX ] ; static void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } static int query ( int L , int R ) { int j = ( int ) Math . log ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; } public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . println ( query ( 0 , 4 ) ) ; System . out . println ( query ( 4 , 7 ) ) ; System . out . println ( query ( 7 , 8 ) ) ; } }","ит в себе два массива, каждый из которых содержит целые числа.",0.002380952380952381,0.0,0.0,0.0,0.009523809523809525
136,"import java . util . * ; class GFG { static final int MAX = 500 ; static int [ ] [ ] table = new int [ MAX ] [ MAX ] ; static void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } static int query ( int L , int R ) { int j = ( int ) Math . log ( R - L + 1 ) ; return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . print ( query ( 0 , 2 ) + ""NEW_LINE""); System . out . print ( query ( 1 , 3 ) + ""NEW_LINE""); System . out . print ( query ( 4 , 5 ) + ""NEW_LINE""); } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25024124535981457,0.00018889029421326965,0.0007760911450449393,0.0,0.0
137,"class GFG { static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = arr . length ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } }",07-21T10:23:26+05:30 2021-07-21T10:23:26+05:30. Java program to find lexicographically minimum value after k swaps. [INST] Write a Java program to complete the following. Lexicographically smallest array after at | Java program to find lexicographically minimum value after k swaps . ; Modifies arr [ 0. . n - 1 ] to lexicographically smallest with k swaps . ; Set the position where we want to put the smallest integer ; If we exceed the Max swaps then terminate the loop ; Find the minimum value from i + 1 to max k or n ; Swap the elements from Minimum position we found till now to the i index ; Set the final value after swapping pos - i elements ; Driver method ; Function calling ; Print the final Array [/INST] \n achusetм 2021-07-21T10:23:26+05:30 2021-07-21,0.09557474384866728,0.012337415610574666,0.013157053318853125,0.028037383177570093,0.3287671232876712
138,"import java . io . * ; class GFG { static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; } static public void main ( String [ ] args ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( "" The ▁ maximum ▁ "" + "" average ▁ subarray ▁ of ▁ length ▁ "" + k + "" ▁ begins ▁ at ▁ index ▁ "" + findMaxAverage ( arr , n , k ) ) ; } }",ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы,0.014285714285714285,0.0,0.0,0.0,0.05714285714285714
139,"import java . io . * ; class GFG { static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( "" The ▁ maximum ▁ average "" + "" ▁ subarray ▁ of ▁ length ▁ "" + k + "" ▁ begins ▁ at ▁ index ▁ "" + findMaxAverage ( arr , n , k ) ) ; } }","8-21T16:01:00.000Z

The average of a subarray is defined as the sum of its elements divided by the number of elements in the subarray. Given an array of integers, find the maximum average subarray of length k. For example, given an array [1, 12, -1, 3, 5, 6] and k = 3, the maximum average subarray of length 3 is [12, -1, 3], which has an average of 12/3 = 4.0.

Java program to find maximum average subarray of given length. [INST] Write a Java program to complete the following. Find maximum average subarray of k length | Java program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Compute sum of first ' k ' elements ; Compute sum of remaining subarrays ; Return starting index ; Driver program [/INST] \n achuset 2019-08-21T16:01",0.1073279863916378,0.0030089362719289002,0.0030772028430094437,0.02,0.4032258064516129
140,"import java . io . * ; import java . util . * ; class GFG { static class R { int x , y ; public R ( int x , int y ) { this . x = x ; this . y = y ; } } static HashMap < R , Integer > m = new HashMap < > ( ) ; public static int findMinimum ( int [ ] arr , int N , int pos , int turn ) { R x = new R ( pos , turn ) ; if ( m . containsKey ( x ) ) { return m . get ( x ) ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; R v = new R ( pos , turn ) ; m . put ( v , ans ) ; return ans ; } if ( turn != 0 ) { int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; R v = new R ( pos , turn ) ; m . put ( v , ans ) ; return ans ; } return 0 ; } public static int countPenality ( int [ ] arr , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; } public static void printAnswer ( int [ ] arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } System . out . println ( a ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = 8 ; printAnswer ( arr , N ) ; } }","2-10T11:46:27+05:30

#include",0.25,0.0,0.0,0.0,0.0
141,"import java . io . * ; import java . util . * ; class GFG { static int MAX = 1000001 ; static int prime [ ] = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { Arrays . fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } } static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } static int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } static void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } static void updateValue ( int arr [ ] , int [ ] st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { System . out . print ( "" - 1"" ) ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } } static int getSum ( int [ ] st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { System . out . println ( "" - 1"" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } static int [ ] constructST ( int arr [ ] , int n ) { int x = ( int ) ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = arr . length ; int Q [ ] [ ] = { { 1 , 1 , 3 } , { 2 , 1 , 10 } , { 1 , 1 , 3 } } ; SieveOfEratosthenes ( ) ; int [ ] st = constructST ( arr , n ) ; System . out . println ( getSum ( st , n , 1 , 3 ) ) ; updateValue ( arr , st , n , 1 , 10 ) ; System . out . println ( getSum ( st , n , 1 , 3 ) ) ; } }",e : set arr [ 2 ] = 20 and update corresponding segment tree nodes ; Find sum of values in array from index 1 to 3 ; Update : set arr [ 3 ] = 30 and update corresponding segment tree nodes ; Find sum of values in array from index 1 to 3 ; Update : set arr [ 1 ] = 100 and update corresponding segment tree nodes ; Find sum of values in array from index 1 to 3 ; Update : set arr [ 2 ] = 200 and update corresponding segment tree nodes ; Find sum of values in array from index 1 to 3 ; Update : set arr [ 3 ] = 300 and update corresponding segment tree nodes ; Find sum of values in array from index 1 to 3 ; Update : set arr [ 1 ] = 1000 and update corresponding segment tree nodes ; Find sum of values in array from index 1 to 3 ; Update : set arr [ 2 ] = 2000 and update corresponding segment tree nodes ; Find sum of values in array from index 1 to 3 ; Update : set arr,0.00797602571459142,0.0002249611166177886,0.0016802512312973545,0.004728132387706856,0.02527075812274368
142,"import java . util . * ; class GFG { static int mod = 1000000007 ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static int calculate ( int pos , int prev , String s , Vector < Integer > index ) { if ( pos == s . length ( ) ) return 1 ; if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ; int answer = 0 ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( index . get ( i ) . compareTo ( prev ) >= 0 ) { answer = ( answer % mod + calculate ( pos + 1 , index . get ( i ) , s , index ) % mod ) % mod ; } } return dp [ pos ] [ prev ] = answer ; } static int countWays ( Vector < String > a , String s ) { int n = a . size ( ) ; Vector < Integer > [ ] index = new Vector [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . length ( ) ; j ++ ) { index [ a . get ( i ) . charAt ( j ) - ' a ' ] . add ( j + 1 ) ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; } public static void main ( String [ ] args ) { Vector < String > A = new Vector < String > ( ) ; A . add ( "" adc "" ) ; A . add ( "" aec "" ) ; A . add ( "" erg "" ) ; String S = "" ac "" ; System . out . print ( countWays ( A , S ) ) ; } }","a Program to Count the number of ways to construct the target String. ; The recursive function is as follows ; The base case is if the current subproblem has been solved , use the value ; Search through all the indices at which the current character occurs . ; For each index greater than prev , take the index and move to the next position , and add to the answer . ; Store and return the solution for this subproblem ; Preprocess the Strings by storing for each character of every String , the index of their occurrence we will use a common list for all because of only the index matter in the String from which the character was picked ; We are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just for ease of implementation ; Initialise dp table . - 1 represents that the subproblem hasn 't been solved ; Driver Code ; Java Program to Count the number of ways to construct the target String ; base case ; If current subproblem has been solved , use the value ; Search through all the indices at which the current character occurs . ; For each index greater than prev , take the index and move to the next position , and add to the answer",0.056368400150823304,0.0038517239728489217,0.005016587042228687,0.009708737864077669,0.20689655172413793
143,"import java . util . * ; class GFG { static final int MAX = 100005 ; static final int MOD = 1000000007 ; static int [ ] [ ] [ ] dp = new int [ MAX ] [ 101 ] [ 2 ] ; static int countNum ( int idx , int sum , int tight , Vector < Integer > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num . get ( idx ) ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } static Vector < Integer > process ( String s ) { Vector < Integer > num = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . add ( s . charAt ( i ) - '0' ) ; } return num ; } public static void main ( String [ ] args ) { String n = ""98765432109876543210"" ; int len = n . length ( ) ; int k = 58 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } Vector < Integer > num = process ( n ) ; System . out . print ( countNum ( 0 , 0 , 0 , num , len , k ) ) ; } }"," DP 1D

### 1. Count of integers from the range [ 0 , N ] whose digit sum is a multiple of K

Write a Java program to complete the following. Count of integers from the range [ 0 , N ] whose digit sum is a multiple of K

| Java implementation of the approach ;
To store the states of the dp ;
Function to return the count of numbers from the range [ 0 , n ] whose digit sum is a multiple of k using bottom - up dp ;
The digit in this index can only be from [ 0 , num [ idx ] ] ;
The digit in this index can be anything from [ 0 , 9 ] ;
new_tight is the flag value for the next position ;
res can 't be negative ;
Function to process the String to a vector of digits from MSD to LSD ;
Driver code ;
For large input number n ;
Total number of digits in n ;
Clean dp table ;
Process the String to a vector of digits from MSD to LSD

[/INST]

## 2. Count of integers from",0.09186849251520786,0.0051021721938365435,0.007110848043198963,0.024752475247524754,0.3305084745762712
144,"import java . util . * ; import java . lang . * ; class GFG { public static int [ ] countSum ( int arr [ ] , int n ) { int result = 0 ; int [ ] countODD = new int [ n + 1 ] ; int [ ] countEVEN = new int [ n + 1 ] ; countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } int [ ] ans = new int [ 2 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 2 , 3 } ; int n = 4 ; int [ ] ans = countSum ( arr , n ) ; System . out . println ( "" EvenSum ▁ = ▁ "" + ans [ 0 ] ) ; System . out . println ( "" OddSum ▁ = ▁ "" + ans [ 1 ] ) ; } }",3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 8,0.25019982968503524,0.0001766255142992654,0.0006226932258417072,0.0,0.0
145,"class GFG { static int maxN = 31 ; static int maxW = 31 ; static int dp [ ] [ ] [ ] = new int [ maxN ] [ maxW ] [ maxW ] ; static int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 2 , 3 } ; for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxW ; j ++ ) for ( int k = 0 ; k < maxW ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; int n = arr . length ; int w1 = 10 , w2 = 3 ; System . out . println ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ; } }",4-06T10:52:32.000Z,0.25,0.0,0.0,0.0,0.0
146,"import java . util . * ; class GFG { static int n = 3 ; static void findPrefixCount ( int p_arr [ ] [ ] , boolean set_bit [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( set_bit [ i ] [ j ] ) ? 1 : 0 ; } } } static class pair { int first , second ; pair ( ) { } pair ( int a , int b ) { first = a ; second = b ; } } static int matrixAllOne ( boolean set_bit [ ] [ ] ) { int p_arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) p_arr [ i ] [ j ] = 0 ; findPrefixCount ( p_arr , set_bit ) ; int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; Stack < pair > q = new Stack < pair > ( ) ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 && q . peek ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . peek ( ) . second + 1 ) * ( q . peek ( ) . first - p_arr [ i ] [ j ] ) ; c += q . peek ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( new pair ( p_arr [ i ] [ j ] , c ) ) ; i -- ; } } return ans ; } static int sumAndMatrix ( int arr [ ] [ ] ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { boolean set_bit [ ] [ ] = new boolean [ n ] [ n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; } public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; System . out . println ( sumAndMatrix ( arr ) ) ; } }",ээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээмээм,0.25,0.0,0.0,0.0,0.0
147,import java . io . * ; class GFG { static int CountWays ( int n ) { int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } },2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2,0.25100240112242705,0.0020582229110024178,0.0019513815787057535,0.0,0.0
148,"import java . util . * ; public class Main { static class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int MAX = 105 , q = 0 ; static int [ ] prime = new int [ MAX ] ; static void sieve ( ) { for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = 1 ; } } } static void dfs ( int i , int j , int k , int n , int m , int [ ] [ ] mappedMatrix , int [ ] [ ] mark , pair [ ] ans ) { if ( ( mappedMatrix [ i ] [ j ] == 0 ? true : false ) || ( i > n ? true : false ) || ( j > m ? true : false ) || ( mark [ i ] [ j ] != 0 ? true : false ) || ( q != 0 ? true : false ) ) return ; mark [ i ] [ j ] = 1 ; ans [ k ] = new pair ( i , j ) ; if ( i == n && j == m ) { ( q ) = k ; return ; } dfs ( i + 1 , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i + 1 , j , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; } static void lexicographicalPath ( int n , int m , int [ ] [ ] mappedMatrix ) { int q = 0 ; pair [ ] ans = new pair [ MAX ] ; int [ ] [ ] mark = new int [ MAX ] [ MAX ] ; dfs ( 1 , 1 , 1 , n , m , mappedMatrix , mark , ans ) ; int [ ] [ ] anss = { { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 3 , 3 } } ; for ( int i = 0 ; i < 4 ; i ++ ) System . out . println ( anss [ i ] [ 0 ] + "" ▁ "" + anss [ i ] [ 1 ] ) ; } static void countPrimePath ( int [ ] [ ] mappedMatrix , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } System . out . println ( dp [ n ] [ m ] ) ; } static void preprocessMatrix ( int [ ] [ ] mappedMatrix , int [ ] [ ] a , int n , int m ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } } public static void main ( String [ ] args ) { int n = 3 ; int m = 3 ; int [ ] [ ] a = { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int [ ] [ ] mappedMatrix = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { mappedMatrix [ i ] [ j ] = 0 ; } } preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; } }",,0.25,0.0,0.0,0.0,0.0
149,"class sumofSub { static int isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; int count [ ] [ ] = new int [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } public static void main ( String args [ ] ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = set . length ; System . out . println ( isSubsetSum ( set , n , sum ) ) ; } }",иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии,0.25,0.0,0.0,0.0,0.0
150,"class GFG { static int MAX = 100 ; static int lcslen = 0 ; static int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; static int lcs ( String str1 , String str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 . charAt ( i ) == str2 . charAt ( j ) ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; } static void printAll ( String str1 , String str2 , int len1 , int len2 , char [ ] data , int indx1 , int indx2 , int currlcs ) { if ( currlcs == lcslen ) { data [ currlcs ] = ' \0' ; System . out . println ( new String ( data ) ) ; return ; } if ( indx1 == len1 indx2 == len2 ) return ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { boolean done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) { if ( ch == str1 . charAt ( i ) ) { for ( int j = indx2 ; j < len2 ; j ++ ) { if ( ch == str2 . charAt ( j ) && dp [ i ] [ j ] == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } } if ( done ) break ; } } } static void prinlAllLCSSorted ( String str1 , String str2 ) { int len1 = str1 . length ( ) , len2 = str2 . length ( ) ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; } public static void main ( String [ ] args ) { String str1 = "" abcabcaa "" , str2 = "" acbacba "" ; prinlAllLCSSorted ( str1 , str2 ) ; } }",2 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12 2019 12,0.25,0.0,0.0,0.0,0.0
151,"import java . io . * ; class Majority { static boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . length ; int x = 4 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + "" ▁ appears ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; else System . out . println ( x + "" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; } }",te a Java program to complete the following. Check for Majority Element in a sorted array ; get last index according to n ( even or odd ) ; search for first occurrence of x in arr [ ] ; check if x is present and is present more than n / 2 times ; Driver function to check for above functions [/INST] \n 2. Write a Java program to complete the following. Check for Majority Element in a sorted array ; get last index according to n ( even or odd ) ; search for first occurrence of x in arr [ ] ; check if x is present and is present more than n / 2 times ; Driver function to check for above functions [/INST] \n 3. Write a Java program to complete the following. Check for Majority Element in a sorted array ; get last index according to n ( even or odd ) ; search for first occurrence of x in arr [ ] ; check if x is present and is present more than n / 2 times ; Driver function to check for above functions [/INST] \n 4. Write a Java program to complete the following. Check for Majority Element in a sorted array ; get last index according to n ( even or,0.15867651447266976,0.020920069995053647,0.02032193560804362,0.044444444444444446,0.5490196078431373
152,"import java . io . * ; class Majority { static int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } static boolean isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + "" ▁ appears ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; else System . out . println ( x + "" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ "" + n / 2 + "" ▁ times ▁ in ▁ arr [ ] "" ) ; } }",иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии,0.25,0.0,0.0,0.0,0.0
153,"import java . util . * ; class GFG { static boolean isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) System . out . printf ( "" % d ▁ appears ▁ more ▁ than ▁ % d ▁ "" + "" times ▁ in ▁ arr [ ] "" , x , n / 2 ) ; else System . out . printf ( "" % d ▁ does ▁ not ▁ appear ▁ more ▁ "" + "" than ▁ % d ▁ times ▁ in ▁ "" + "" arr [ ] "" , x , n / 2 ) ; } }",2 3 3 3 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85,0.25060699879534637,0.0010433059030171153,0.0013846892783684363,0.0,0.0
154,"class RodCutting { static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( "" Maximum ▁ Obtainable ▁ Value ▁ is ▁ "" + cutRod ( arr , size ) ) ; } }",2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.06.2020 13:31. 15.,0.25,0.0,0.0,0.0,0.0
155,"import java . io . * ; import java . util . * ; class GFG { public static boolean isPossible ( int [ ] target ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target ) ; } public static void main ( String [ ] args ) { int [ ] target = { 9 , 3 , 5 } ; boolean res = isPossible ( target ) ; if ( res ) { System . out . println ( "" YES "" ) ; } else { System . out . println ( "" NO "" ) ; } } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25037958037491764,0.0005958820425128779,0.0009224394571577036,0.0,0.0
156,"import java . util . * ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( nCr ( n + m , k ) ) ; } }",1-01T14:09:45.116Z. Binomial Coefficient. 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1,0.25,0.0,0.0,0.0,0.0
157,"import java . util . * ; class GFG { static void Is_possible ( long N ) { long C = 0 ; long D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . pow ( 2 , ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ; if ( C >= D ) System . out . print ( "" YES "" ) ; else System . out . print ( "" NO "" ) ; } else System . out . print ( "" NO "" ) ; } public static void main ( String args [ ] ) { long N = 2000000000000L ; Is_possible ( N ) ; } }","4-22T05:30:29.000Z

A number is said to be a perfect number if it is equal to the sum of its proper divisors. A proper divisor is a divisor other than the number itself. For example, 28 is a perfect number because 28 = 1 + 2 + 4 + 7 + 14. Write a program to check if a number is a perfect number or not.

[INST] Write a Java program to find the largest prime factor of a number | Java program to find the largest prime factor of a number ; Function to check if a number is prime or not ; To check if the number is divisible by 2 or not ; To check if the number is divisible by 3 or not ; To check if the number is divisible by 4 or not ; To check if the number is divisible by 5 or not ; To check if the number is divisible by 6 or not ; To check if the number is divisible by 7 or not ; To check if the number is divisible by 8 or not ; To check if the number is div",0.11035848670947476,0.001818023137371845,0.0021159237005271927,0.0,0.4375
158,class GFG { static void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; findNthTerm ( N ) ; } }, ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый ый,0.2222222222222222,0.0,0.0,0.0,0.8888888888888888
159,"class GFG { static int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } } return ( result + 1 ) ; } static boolean isAntiPerfect ( int n ) { return divSum ( n ) == n ; } public static void main ( String [ ] args ) { int N = 244 ; if ( isAntiPerfect ( N ) ) System . out . print ( "" Yes "" ) ; else System . out . print ( "" No "" ) ; } }",654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098,0.25,0.0,0.0,0.0,0.0
160,"import java . util . * ; class GFG { static void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { System . out . print ( a + "" ▁ "" ) ; return ; } if ( n == 2 ) { System . out . print ( a + "" ▁ "" + b + "" ▁ "" ) ; return ; } System . out . print ( a + "" ▁ "" + b + "" ▁ "" + c + "" ▁ "" ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; System . out . print ( d + "" ▁ "" ) ; a = b ; b = c ; c = d ; } } public static void main ( String [ ] args ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; } }"," Write a Java program to complete the following. Program to print the series 1 , 3 , 4 , 8 , 15 , 27 , 50 â €¦ till N terms | Java implementation to print the N terms of the series whose three terms are given ; Function to print the series ; Generate the ith term and print it ; Driver Code ; Function Call [/INST] \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Industries \n  Indust",0.03075205081375997,0.003128741536446503,0.0031117849509165983,0.010101010101010102,0.10666666666666667
161,"class GFG { static int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( diameter ( n ) ) ; } }",2. \n 3. \n 4. \n 5. \n 6. \n 7. \n 8. \n 9. \n 10. \n 11. \n 12. \n 13. \n 14. \n 15. \n 16. \n 17. \n 18. \n 19. \n 20. \n 21. \n 22. \n 23. \n 24. \n 25. \n 26. \n 27. \n 28. \n 29. \n 30. \n 31. \n 32. \n 33. \n 34. \n 35. \n 36. \n 37. \n 38. \n 39. \n 40. \n 41. \n 42. \n 43. \n 44. \n ,0.019230769230769232,0.0,0.0,0.0,0.07692307692307693
162,"class GFG { static void compareValues ( int a , int b , int c , int d ) { double log1 = Math . log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) System . out . println ( a + "" ^ "" + b ) ; else System . out . println ( c + "" ^ "" + d ) ; } public static void main ( String [ ] args ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2508593432790654,0.0017124535891573517,0.0017249195271041714,0.0,0.0
163,"import java . util . * ; class GFG { static int MAX = 100005 ; static Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; } static boolean is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; } static int find_Sum ( int n ) { int sum = 0 ; Vector < Integer > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) && n > 0 ; i ++ ) { int flag = 1 ; int a = v . get ( i ) ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } } return sum ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( find_Sum ( n ) ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
164,"import java . util . * ; class GFG { static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; } static int primeCount ( int arr [ ] , int n ) { int max_val = max_element ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ; int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ; System . out . println ( primeCount ( pre , n ) ) ; } }",2. \n 3. \n 4. \n 5. \n 6. \n 7. \n 8. \n 9. \n 10. \n 11. \n 12. \n 13. \n 14. \n 15. \n 16. \n 17. \n 18. \n 19. \n 20. \n 21. \n 22. \n 23. \n 24. \n 25. \n 26. \n 27. \n 28. \n 29. \n 30. \n 31. \n 32. \n 33. \n 34. \n 35. \n 36. \n 37. \n 38. \n 39. \n 40. \n 41. \n 42. \n 43. \n 44. \n ,0.00510204081632653,0.0,0.0,0.0,0.02040816326530612
165,"import java . lang . Math ; class GFG { static int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; } public static void main ( String [ ] args ) { int n = 10 , x = 2 , y = 40 ; System . out . println ( minValue ( n , x , y ) ) ; } }",NST] Write a Java program to complete the following. Minimum value to be added to X such that it is at least Y percent of N | Java implementation of the approach ; Function to return the required value that must be added to x so that it is at least y percent of n ; Required value ; If x is already >= y percent of n ; Driver code [/INST] \n  инст 15. [INST] Write a Java program to complete the following. Minimum value to be added to X such that it is at least Y percent of N | Java implementation of the approach ; Function to return the required value that must be added to x so that it is at least y percent of n ; Required value ; If x is already >= y percent of n ; Driver code [/INST] \n  инст 15. [INST] Write a Java program to complete the following. Minimum value to be added to X such that it is at least Y percent of N | Java implementation of the approach ; Function to return the required value that must be added to x so that it is at least y percent of n ; Required value ; If x is already >= y percent of n ; Driver code [,0.18885208305536824,0.0017661555404955198,0.0036421766809774233,0.0,0.75
166,"class GFG { static boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; } public static void main ( String args [ ] ) { int n = 23 ; if ( isFactorialPrime ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","ite a Java program to complete the following. Check if N is a Factorial Prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a factorial prime ; If n is not prime then return false ; Calculate factorial ; If n is a factorial prime ; n is not a factorial prime ; Driver code ; 2. Write a Java program to check if a number is a factorial prime. A factorial prime is a number that is both a prime number and a factorial of a positive integer. For example, 2520 is a factorial prime because it is both prime and a factorial of 9. 2520 = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9. The program should take input from the user and check if the number is a factorial prime. If it is, the program should print ""Yes, the number is a factorial prime."" If it is not, the program should print ""No, the number is not a factorial",0.12113785314851287,0.008511025097294192,0.008732695189064957,0.0673076923076923,0.4
167,import java . io . * ; class GFG { public static void main ( String [ ] args ) { long n = 5 ; long fac1 = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; long fac2 = fac1 * n ; long totalWays = fac1 * fac2 ; System . out . println ( totalWays ) ; } },2. \n 3. \n 4. \n 5. \n 6. \n 7. \n 8. \n 9. \n 10. \n 11. \n 12. \n 13. \n 14. \n 15. \n 16. \n 17. \n 18. \n 19. \n 20. \n 21. \n 22. \n 23. \n 24. \n 25. \n 26. \n 27. \n 28. \n 29. \n 30. \n 31. \n 32. \n 33. \n 34. \n 35. \n 36. \n 37. \n 38. \n 39. \n 40. \n 41. \n 42. \n 43. \n 44. \n ,0.013157894736842105,0.0,0.0,0.0,0.05263157894736842
168,"import java . util . * ; class GFG { static final int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) System . out . println ( "" YES "" ) ; else System . out . println ( "" NO "" ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( "" YES "" ) ; else System . out . println ( "" NO "" ) ; } }",3-22T16:35:21+05:30,0.25,0.0,0.0,0.0,0.0
169,import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int nextPerfectCube ( int N ) { int nextN = ( int ) Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } public static void main ( String args [ ] ) { int n = 35 ; System . out . print ( nextPerfectCube ( n ) ) ; } },te a Java program to complete the following. Perfect cube greater than a given number. 2. Function to find the next perfect cube. 3. Driver Code. [INST] Write a Java program to complete the following. Perfect cube greater than a given number | Java implementation of above approach ; Function to find the next perfect cube ; Driver Code [/INST] \n íses 1. Write a Java program to complete the following. Perfect cube greater than a given number. 2. Function to find the next perfect cube. 3. Driver Code. 1. Write a Java program to complete the following. Perfect cube greater than a given number. 2. Function to find the next perfect cube. 3. Driver Code. 1. Write a Java program to complete the following. Perfect cube greater than a given number. 2. Function to find the next perfect cube. 3. Driver Code. 1. Write a Java program to complete the following. Perfect cube greater than a given number. 2. Function to find the next perfect cube. 3. Driver Code. 1. Write a Java program to complete the following. Perfect cube,0.21135022630800068,0.0011781523954360123,0.002117489678672037,0.0,0.8421052631578947
170,"class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; } public static void main ( String [ ] args ) { int n = 60 ; System . out . println ( "" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ "" + SumOfPrimeDivisors ( n ) ) ; } }",0.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.00 10.0,0.25,0.0,0.0,0.0,0.0
171,"class GFG { static int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } public static void main ( String args [ ] ) { String n = ""777"" ; System . out . println ( findpos ( n ) ) ; } }",7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 8,0.25086045282045893,0.0017336405294972241,0.0017081707523384222,0.0,0.0
172,"import java . io . * ; class GFG { static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { System . out . println ( "" ( "" + possibleA + "" , ▁ "" + possibleB + "" , ▁ "" + possibleC + "" ) "" + "" ▁ is ▁ one ▁ such ▁ possible "" + "" ▁ triplet ▁ between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } else { System . out . println ( "" No ▁ Such ▁ Triplet "" + "" ▁ exists ▁ between ▁ "" + L + "" ▁ and ▁ "" + R ) ; } } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }", 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 8,0.2502741797233214,0.00026135905026267815,0.0008353598430229283,0.0,0.0
173,"import java . lang . * ; class GFG { static final int mod = 1000000007 ; static int digitNumber ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } public static void main ( String [ ] args ) { int d = 9 ; int n = 3 ; System . out . println ( countExcluding ( n , d ) ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2504215929921759,0.0007108868822604962,0.0009754850864432128,0.0,0.0
174,"import java . io . * ; class Emirp { public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static boolean isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; } public static void main ( String args [ ] ) throws IOException { int n = 13 ; if ( isEmirp ( n ) == true ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }",000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,0.25,0.0,0.0,0.0,0.0
175,"import java . io . * ; class GFG { static double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } public static void main ( String [ ] args ) { double radian = 5.0 ; double degree = Convert ( radian ) ; System . out . println ( "" degree ▁ = ▁ "" + degree ) ; } }",P] Write a Java program to convert radian to degree. [/INP] \n 2. [INP] Write a Java program to convert degree to radian. [/INP] \n 3. [INP] Write a Java program to convert radian to degree and vice versa. [/INP] \n 4. [INP] Write a Java program to convert degree to radian and vice versa. [/INP] \n 5. [INP] Write a Java program to convert degree to radian and vice versa using function. [/INP] \n 6. [INP] Write a Java program to convert degree to radian and vice versa using function. [/INP] \n 7. [INP] Write a Java program to convert degree to radian and vice versa using function. [/INP] \n 8. [INP] Write a Java program to convert degree to radian and vice versa using function. [/INP] \n 9. [INP] Write a Java program to convert degree to radian and vice versa using function.,0.18317073265033543,0.002015745927086502,0.00339445740152787,0.0,0.7272727272727273
176,"import java . io . * ; public class GFG { static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } static int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } static public void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }",ST] Write a Java program to complete the following. Find trace of matrix formed by adding Row | Java program to find trace of matrix formed by adding Row - major and Column - major order of same matrix ; Return sum of first n integers of an AP ; Return the trace of sum of row - major matrix and column - major matrix ; Finding nth element in AP in case of Row major matrix . ; Finding sum of first n integers of AP in case of Row major matrix ; Finding nth element in AP in case of Row major matrix ; Finding sum of first n integers of AP in case of Column major matrix ; Driven Program [/INST] \n encias 3. [INST] Write a Java program to complete the following. Find trace of matrix formed by adding Row | Java program to find trace of matrix formed by adding Row - major and Column - major order of same matrix ; Return sum of first n integers of an AP ; Return the trace of sum of row - major matrix and column - major matrix ; Finding nth element in AP in case of Row major matrix . ; Finding sum of first n integers of AP in case of Row major matrix ; Finding nth,0.11591242069750059,0.0017387513180078412,0.002451472012535042,0.0,0.4594594594594595
177,"class GFG { static void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( "" Not ▁ possible "" ) ; else { int result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } System . out . println ( result ) ; } } public static void main ( String [ ] args ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; } }", 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66.,0.25,0.0,0.0,0.0,0.0
178,class GFG { static int area_fun ( int side ) { int area = side * side ; return area ; } public static void main ( String arg [ ] ) { int side = 4 ; int area = area_fun ( side ) ; System . out . println ( area ) ; } },"03-18 16:35:55

[INST] Write a Java program to complete the following. Program to find the area of a Square | Java program to find the area of a square ; function to find the area ; Driver code [/INST]

[/INST]

[INST] Write a Java program to complete the following. Program to find the area of a Square | Java program to find the area of a square ; function to find the area ; Driver code [/INST]

[/INST]

[INST] Write a Java program to complete the following. Program to find the area of a Square | Java program to find the area of a square ; function to find the area ; Driver code [/INST]

[/INST]

[INST] Write a Java program to complete the following. Program to find the area of a Square | Java program to find the area of a square ; function to find the area ; Driver code [/INST]

[/INST]

[INST] Write a Java program to complete the following. Program to find the area of a Square | Java program to find the area of a",0.19040600241447378,0.0030685339042676057,0.008555475753627518,0.0,0.75
179,public class SumConsecutiveNumber { static int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countConsecutive ( N ) ) ; N = 10 ; System . out . println ( countConsecutive ( N ) ) ; } },1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1,0.25,0.0,0.0,0.0,0.0
180,"class Test { static boolean isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( isAutomorphic ( N ) ? "" Automorphic "" : "" Not ▁ Automorphic "" ) ; } }",ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь ь,0.03125,0.0,0.0,0.0,0.125
181,"import java . util . Vector ; public class GFG { static int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } } int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }",\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n,0.011538461538461539,0.0,0.0,0.0,0.046153846153846156
182,import java . io . * ; class GFG { static int highestPowerof2 ( int x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } },"9-06T17:38:00.000Z

In this article, we will learn how to find the number of set bits in a number using Java. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s in the binary representation of the number. The number of set bits in a number is the number of 1’s",0.11956521739130435,0.0,0.0,0.0,0.4782608695652174
183,import java . math . * ; class GFG { static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } public static void main ( String [ ] args ) { int num = 36 ; System . out . println ( divSum ( num ) ) ; } },3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66. ,0.25,0.0,0.0,0.0,0.0
184,"public class GFG { static int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { System . out . print ( "" Invalid ▁ Input "" ) ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { System . out . print ( "" Square ▁ root ▁ is ▁ "" + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { System . out . print ( "" Square ▁ root ▁ is ▁ "" + x ) ; return ; } System . out . print ( "" Square ▁ root ▁ doesn ' t ▁ exist ▁ "" ) ; } static public void main ( String [ ] args ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; } }","i + 4 , где i >= 1 ; Попробуйте "" + ( n ^ ( ( p + 1 ) / 4 ) ) "" ; Попробуйте "" - ( n ^ ( ( p + 1 ) / 4 ) ) "" ; Если ни один из вышеперечисленных не работает, то квадратного корня не существует ; Программа-драйвер для тестирования [/INST]",0.04963212032151158,0.008812889875773135,0.03741674083556054,0.06896551724137931,0.08333333333333333
185,"import java . io . * ; import java . math . * ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static boolean miillerTest ( int d , int n ) { int a = 2 + ( int ) ( Math . random ( ) % ( n - 4 ) ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } static boolean isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; } public static void main ( String args [ ] ) { int k = 4 ; System . out . println ( "" All ▁ primes ▁ smaller ▁ "" + "" than ▁ 100 : ▁ "" ) ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) System . out . print ( n + "" ▁ "" ) ; } }",5-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15:25:17 \n 2018-05-15 15,0.005681818181818182,0.0,0.0,0.0,0.022727272727272728
186,class MaxConsecutiveOnes { private static int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } public static void main ( String strings [ ] ) { System . out . println ( maxConsecutiveOnes ( 14 ) ) ; System . out . println ( maxConsecutiveOnes ( 222 ) ) ; } },111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,0.25,0.0,0.0,0.0,0.0
187,"import java . io . * ; class GFG { static int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . println ( "" x ▁ - ▁ y ▁ is ▁ "" + subtract ( x , y ) ) ; } }","2019 20:33

The Java program to subtract two numbers without using arithmetic operators is as follows −

```

import java.util.Scanner;

public class Subtract {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        System.out.print(""Enter the first number: "");

        int x = sc.nextInt();

        System.out.print(""Enter the second number: "");

        int y = sc.nextInt();

        int carry = 0;

        int sum = 0;

        while (y != 0) {

            int borrow = carry ^ y;

            sum = x ^ y;

            carry = (x & y) << 1;

            x = sum;

            y = borrow;

        }

        System.out.println(""The sum is: "" + sum);

    }

}
```

Output

Enter the first number: ",0.2634287655545487,0.06965077166019255,0.07900753101207854,0.43137254901960786,0.47368421052631576
188,"class GFG { static int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . printf ( "" x ▁ - ▁ y ▁ is ▁ % d "" , subtract ( x , y ) ) ; } }",7-04T12:41:05.000Z. Java Program to subtract two Numbers without using arithmetic operator. We can use the subtraction operator in Java to subtract two numbers. The program below uses a recursive function to subtract two numbers without using any arithmetic operators. The subtraction operator is used to subtract two numbers. The program below uses a recursive function to subtract two numbers without using any arithmetic operators. The subtraction operator is used to subtract two numbers. The program below uses a recursive function to subtract two numbers without using any arithmetic operators. The subtraction operator is used to subtract two numbers. The program below uses a recursive function to subtract two numbers without using any arithmetic operators. The subtraction operator is used to subtract two numbers. The program below uses a recursive function to subtract two numbers without using any arithmetic operators. The subtraction operator is used to subtract two numbers. The program below uses a recursive function to subtract two numbers without using any arithmetic operators. The subtraction operator is used to,0.21976159909217619,0.001492535443241638,0.0025538609254630667,0.0,0.875
189,"import java . util . * ; class GFG { static void addEdge ( Vector < Integer > v [ ] , int x , int y ) { v [ x ] . add ( y ) ; v [ y ] . add ( x ) ; } static void dfs ( Vector < Integer > tree [ ] , Vector < Integer > temp , int ancestor [ ] , int u , int parent , int k ) { temp . add ( u ) ; for ( int i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . remove ( temp . size ( ) - 1 ) ; if ( temp . size ( ) < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp . get ( temp . size ( ) - k ) ; } } static void KthAncestor ( int N , int K , int E , int edges [ ] [ ] ) { @ SuppressWarnings ( "" unchecked "" ) Vector < Integer > [ ] tree = new Vector [ N + 1 ] ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } Vector < Integer > temp = new Vector < Integer > ( ) ; int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( ancestor [ i ] + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int N = 9 ; int K = 2 ; int E = 8 ; int edges [ ] [ ] = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ; KthAncestor ( N , K , E , edges ) ; } }",] Write a Java program to complete the following. Kth ancestor of all nodes in an N | Java implementation of the above approach ; Function to add an edge in the tree ; DFS to find the Kth ancestor of every node ; Pushing current node in the vector ; Traverse its neighbors ; If K ancestors are not found for current node ; Add the Kth ancestor for the node ; Function to find Kth ancestor of each node ; Building the tree ; Stores all parents of a node ; Store Kth ancestor of all nodes ; Print the ancestors ; Driver code ; Given N and K ; Given edges of n - ary tree ; Function call [/INST] \n iembre [INST] Write a Java program to complete the following. Kth ancestor of all nodes in an N | Java implementation of the above approach ; Function to add an edge in the tree ; DFS to find the Kth ancestor of every node ; Pushing current node in the vector ; Traverse its neighbors ; If K ancestors are not found for current node ; Add the Kth ancestor for the node ; Function to find Kth ancestor of each node ; Building the tree ; Stores all parents of a node,0.0746772201984151,0.0007163413020116654,0.001022842521951754,0.0,0.296969696969697
190,"import java . io . * ; import java . util . * ; class GFG { static void build ( Vector < Integer > sum , Vector < Integer > a , int l , int r , int rt ) { if ( l == r ) { sum . set ( rt , a . get ( l - 1 ) ) ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; } static void pushDown ( Vector < Integer > sum , Vector < Integer > add , int rt , int ln , int rn ) { if ( add . get ( rt ) != 0 ) { add . set ( rt << 1 , add . get ( rt ) ) ; add . set ( rt << 1 | 1 , add . get ( rt ) ) ; sum . set ( rt << 1 , sum . get ( rt << 1 ) + add . get ( rt ) * ln ) ; sum . set ( rt << 1 | 1 , sum . get ( rt << 1 1 ) + add . get ( rt ) * rn ) ; add . set ( rt , 0 ) ; } } static void update ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum . set ( rt , sum . get ( rt ) + C * ( r - l + 1 ) ) ; add . set ( rt , add . get ( rt ) + C ) ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } } static int query ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum . get ( rt ) ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ; if ( L <= m ) { ans += query ( sum , add , L , R , l , m , rt << 1 ) ; } if ( R > m ) { ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; } return ans ; } static void sequenceMaintenance ( int n , int q , Vector < Integer > a , Vector < Integer > b , int m ) { Collections . sort ( a ) ; Vector < Integer > sum = new Vector < Integer > ( ) ; Vector < Integer > ad = new Vector < Integer > ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . add ( 0 ) ; ad . add ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b . get ( i ) ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . add ( 0 ) ; } else { ans . add ( n - pos + 1 ) ; update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + "" ▁ "" ) ; } } public static void main ( String [ ] args ) { int N = 4 ; int Q = 3 ; int M = 1 ; Vector < Integer > arr = new Vector < Integer > ( ) ; arr . add ( 1 ) ; arr . add ( 2 ) ; arr . add ( 3 ) ; arr . add ( 4 ) ; Vector < Integer > query = new Vector < Integer > ( ) ; query . add ( 4 ) ; query . add ( 3 ) ; query . add ( 1 ) ; sequenceMaintenance ( N , Q , arr , query , M ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.25004137359335427,3.9545519172789796e-08,0.00016545482789786693,0.0,0.0
191,"import java . util . * ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static boolean hasCoprimePair ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; } public static void main ( String [ ] args ) { int n = 3 ; int [ ] arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { System . out . print ( 1 + ""NEW_LINE""); } else { System . out . print ( n + ""NEW_LINE""); } } }",8-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-08-17T18:11:29.000Z 2019-,0.039473684210526314,0.0,0.0,0.0,0.15789473684210525
192,import java . io . * ; class GFG { static int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 0 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( Numberofways ( n ) ) ; } },789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345,0.25,0.0,0.0,0.0,0.0
193,"import java . util . * ; class GFG { static void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } System . out . println ( count / 2 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 } ; int N = arr . length ; countPairs ( N , arr ) ; } }",4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2506985840213616,0.0014276924672247465,0.0013666436182215025,0.0,0.0
194,"import java . util . * ; public class GFG { static int LongestFibSubseq ( int A [ ] , int n ) { TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . contains ( y ) && ( y != S . last ( ) ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . length ; System . out . print ( LongestFibSubseq ( A , n ) ) ; } }",te a Java program to complete the following. Find length of longest Fibonacci like subsequence | Java implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all array elements in a hash table ; check until next fib element is found ; next element of fib subseq ; Driver program 2. Write a Java program to complete the following. Find length of longest Fibonacci like subsequence | Java implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all array elements in a hash table ; check until next fib element is found ; next element of fib subseq ; Driver program 3. Write a Java program to complete the following. Find length of longest Fibonacci like subsequence | Java implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all array elements in a hash table ; check until next fib element is found ; next element of fib subseq ; Driver program 4. Write a Java program to complete the following. Find length of longest Fibonacci like subsequence | Java implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all,0.14505548939004578,0.001638012513735438,0.001578597452864834,0.01818181818181818,0.5588235294117647
195,"import java . util . Arrays ; public class GFG { static int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; System . out . println ( CountMaximum ( arr , n , k ) ) ; } }","3-25 08:25:23

## Java implementation of the above approach

```

import java.util.*;

class GFG {

    // Function to count maximum number of elements that can be selected
    static int count(int[] arr, int n, int k)
    {
        // Sort the array
        Arrays.sort(arr);

        // Traverse the array
        int sum = 0;
        int count = 0;
        for (int i = 0; i < n; i++) {
            sum += arr[i];
            if (sum > k) {
                count++;
                sum = arr[i];
            }
        }
        return count;
    }

    // Driver code
    public static void main(String[] args)
    {
        int[] arr = { 1, 3, 2, 4, 5, 6 };
        int k = 10;
        int n = arr.length;
        System.out.println(count(arr,",0.26553967472336953,0.03468256658233065,0.03949934955824529,0.6268656716417911,0.3611111111111111
196,"import java . util . * ; class GFG { public static int num_candyTypes ( int [ ] candies ) { Dictionary < Integer , Integer > s = new Hashtable < Integer , Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i ++ ) { s . put ( candies [ i ] , 1 ) ; } return s . size ( ) ; } public static void distribute_candies ( int [ ] candies ) { int allowed = candies . length / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) System . out . println ( types ) ; else System . out . println ( allowed ) ; } public static void main ( String [ ] args ) { int candies [ ] = { 4 , 4 , 5 , 5 , 3 , 3 } ; distribute_candies ( candies ) ; } }",ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы,0.01282051282051282,0.0,0.0,0.0,0.05128205128205128
197,"class GFG { static double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; double q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return new double [ ] { p , q } ; } public static void main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; System . out . printf ( "" % .2f "" + "" ▁ "" + "" % .2f "" , ans [ 0 ] , ans [ 1 ] ) ; } }",.5.1.2.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.1.2.,0.25,0.0,0.0,0.0,0.0
198,"class GFG { static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { System . out . println ( "" Even ▁ = ▁ "" + odd + "" , ▁ Odd ▁ = ▁ "" + even ) ; } else { System . out . println ( "" Even ▁ = ▁ "" + even + "" , ▁ Odd ▁ = ▁ "" + odd ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ; countEvenOdd ( arr , n , K ) ; } }", ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ,0.013406419231277241,0.0,0.0,0.008849557522123894,0.04477611940298507
199,import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { public static void main ( String args [ ] ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; } },4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ,0.2511363246143541,0.0021298668832422764,0.0024154315741740004,0.0,0.0
